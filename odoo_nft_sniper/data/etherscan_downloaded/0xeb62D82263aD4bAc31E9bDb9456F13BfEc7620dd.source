{"status":"1","message":"OK","result":[{"SourceCode":"/**\r\n *Submitted for verification at polygonscan.com on 2022-07-13\r\n*/\r\n\r\n/**\r\n *Submitted for verification at polygonscan.com on 2022-05-10\r\n*/\r\n\r\n// File: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v4.3.2/contracts/utils/introspection/IERC165.sol\r\n\r\n\r\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `to`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address to, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `from` to `to` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n/**\r\n * @dev Interface of the ERC165 standard, as defined in the\r\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\r\n *\r\n * Implementers can declare support of contract interfaces, which can then be\r\n * queried by others ({ERC165Checker}).\r\n *\r\n * For an implementation, see {ERC165}.\r\n */\r\ninterface IERC165 {\r\n    /**\r\n     * @dev Returns true if this contract implements the interface defined by\r\n     * `interfaceId`. See the corresponding\r\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\r\n     * to learn more about how these ids are created.\r\n     *\r\n     * This function call must use less than 30 000 gas.\r\n     */\r\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\r\n}\r\n\r\n// File: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v4.3.2/contracts/token/ERC721/IERC721.sol\r\n\r\n\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\n/**\r\n * @dev Required interface of an ERC721 compliant contract.\r\n */\r\ninterface IERC721 is IERC165 {\r\n    /**\r\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\r\n\r\n    /**\r\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\r\n     */\r\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\r\n\r\n    /**\r\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\r\n     */\r\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\r\n\r\n    /**\r\n     * @dev Returns the number of tokens in ``owner``'s account.\r\n     */\r\n    function balanceOf(address owner) external view returns (uint256 balance);\r\n\r\n    /**\r\n     * @dev Returns the owner of the `tokenId` token.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `tokenId` must exist.\r\n     */\r\n    function ownerOf(uint256 tokenId) external view returns (address owner);\r\n\r\n    /**\r\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\r\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `from` cannot be the zero address.\r\n     * - `to` cannot be the zero address.\r\n     * - `tokenId` token must exist and be owned by `from`.\r\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\r\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId\r\n    ) external;\r\n\r\n    /**\r\n     * @dev Transfers `tokenId` token from `from` to `to`.\r\n     *\r\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `from` cannot be the zero address.\r\n     * - `to` cannot be the zero address.\r\n     * - `tokenId` token must be owned by `from`.\r\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId\r\n    ) external;\r\n\r\n    /**\r\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\r\n     * The approval is cleared when the token is transferred.\r\n     *\r\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The caller must own the token or be an approved operator.\r\n     * - `tokenId` must exist.\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address to, uint256 tokenId) external;\r\n\r\n    /**\r\n     * @dev Returns the account approved for `tokenId` token.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `tokenId` must exist.\r\n     */\r\n    function getApproved(uint256 tokenId) external view returns (address operator);\r\n\r\n    /**\r\n     * @dev Approve or remove `operator` as an operator for the caller.\r\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The `operator` cannot be the caller.\r\n     *\r\n     * Emits an {ApprovalForAll} event.\r\n     */\r\n    function setApprovalForAll(address operator, bool _approved) external;\r\n\r\n    /**\r\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\r\n     *\r\n     * See {setApprovalForAll}\r\n     */\r\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\r\n\r\n    /**\r\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `from` cannot be the zero address.\r\n     * - `to` cannot be the zero address.\r\n     * - `tokenId` token must exist and be owned by `from`.\r\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\r\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId,\r\n        bytes calldata data\r\n    ) external;\r\n}\r\n\r\n// File: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v4.3.2/contracts/token/ERC1155/IERC1155.sol\r\n\r\n\r\n// OpenZeppelin Contracts v4.4.1 (token/ERC1155/IERC1155.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\n/**\r\n * @dev Required interface of an ERC1155 compliant contract, as defined in the\r\n * https://eips.ethereum.org/EIPS/eip-1155[EIP].\r\n *\r\n * _Available since v3.1._\r\n */\r\ninterface IERC1155 is IERC165 {\r\n    /**\r\n     * @dev Emitted when `value` tokens of token type `id` are transferred from `from` to `to` by `operator`.\r\n     */\r\n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\r\n\r\n    /**\r\n     * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all\r\n     * transfers.\r\n     */\r\n    event TransferBatch(\r\n        address indexed operator,\r\n        address indexed from,\r\n        address indexed to,\r\n        uint256[] ids,\r\n        uint256[] values\r\n    );\r\n\r\n    /**\r\n     * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to\r\n     * `approved`.\r\n     */\r\n    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\r\n\r\n    /**\r\n     * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.\r\n     *\r\n     * If an {URI} event was emitted for `id`, the standard\r\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value\r\n     * returned by {IERC1155MetadataURI-uri}.\r\n     */\r\n    event URI(string value, uint256 indexed id);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens of token type `id` owned by `account`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `account` cannot be the zero address.\r\n     */\r\n    function balanceOf(address account, uint256 id) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `accounts` and `ids` must have the same length.\r\n     */\r\n    function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids)\r\n        external\r\n        view\r\n        returns (uint256[] memory);\r\n\r\n    /**\r\n     * @dev Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`,\r\n     *\r\n     * Emits an {ApprovalForAll} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `operator` cannot be the caller.\r\n     */\r\n    function setApprovalForAll(address operator, bool approved) external;\r\n\r\n    /**\r\n     * @dev Returns true if `operator` is approved to transfer ``account``'s tokens.\r\n     *\r\n     * See {setApprovalForAll}.\r\n     */\r\n    function isApprovedForAll(address account, address operator) external view returns (bool);\r\n\r\n    /**\r\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\r\n     *\r\n     * Emits a {TransferSingle} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `to` cannot be the zero address.\r\n     * - If the caller is not `from`, it must be have been approved to spend ``from``'s tokens via {setApprovalForAll}.\r\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\r\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\r\n     * acceptance magic value.\r\n     */\r\n    function safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 id,\r\n        uint256 amount,\r\n        bytes calldata data\r\n    ) external;\r\n\r\n    /**\r\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.\r\n     *\r\n     * Emits a {TransferBatch} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `ids` and `amounts` must have the same length.\r\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\r\n     * acceptance magic value.\r\n     */\r\n    function safeBatchTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256[] calldata ids,\r\n        uint256[] calldata amounts,\r\n        bytes calldata data\r\n    ) external;\r\n}\r\n\r\n// File: contracts/Marketplace/Marketplace.sol\r\n\r\npragma solidity ^0.8.7;\r\n\r\n\r\n\r\n//This is a Suns Of DeFi: Wallet Monsters LaunchPad\r\n\r\ncontract WalletMonstersLaunchPad {\r\n\r\naddress LaunchPad; //Launchpad address\r\naddress owner; //Owner Address\r\naddress burn; //Tossed Keys Burner Address\r\naddress sodGuard; //Address Guard\r\naddress public WMTP; //WMTP contract\r\naddress public LaunchPadTokens; //LPTs contract\r\naddress public Wallebytes; // $WALY contract\r\nstring public name;\r\nstring public symbol;\r\n\r\nuint256 public walyCost; //LP WALY buy cost\r\n\r\n\r\n\r\n    constructor(){\r\n        LaunchPad = payable(address(this));\r\n        owner = msg.sender;\r\n\r\n        name = \"Wallet Monsters Launchpad\";\r\n        symbol = \"WMLP\";\r\n\r\n        burn = 0x0C2dCb65b5EB0dEe082b1B7a6F458E7cB210e321; //No Keys, tossed them - burn address - Hard coded\r\n        sodGuard = 0xfcbD40e2FDA1b292D5a15f9a2c85E94b393a5023; //Rewards holder set \r\n    }\r\n\r\n     struct AuctionItem {\r\n            uint256 id;\r\n            address tokenAddress;\r\n            uint256 tokenId;\r\n            address payable seller;\r\n            uint256 askingPrice;\r\n            uint256 units;\r\n            bool isSold;\r\n            bool useLPT; //price in native token or LPTs\r\n            uint256 tokenType; //721 or 1155\r\n        }\r\n\r\n    AuctionItem[] public itemsForSale;\r\n\r\n       \r\n    mapping(address => mapping(uint256 => bool))activeItems; //Items on Launchpad\r\n    mapping(address => bool)LaunchPadItem; //Approve contracts that can add items to LP\r\n    mapping(address => bool) public tokenApproved; //approved LPT\r\n    mapping(address => uint256) public LPlevel;\r\n\r\n    event multiItemAdded(uint256 id, uint256 tokenId, address tokenAddress,address seller, uint amount ,uint256 askingPrice, uint256 date);\r\n    event multiItemSold(uint256 id,  uint256 tokenId, address tokenAddress, address buyer, uint256 amount, uint256 askingPrice, uint256 date, bool LPTBuy);\r\n    event multiItemRemoved(uint256 id,  uint256 tokenId, address tokenAddress, uint256 amount, uint256 askingPrice, uint256 date);\r\n    event singleItemAdded(uint256 id, uint256 tokenId, address tokenAddress,address seller, uint256 askingPrice, uint256 date);\r\n    event singleItemSold(uint256 id,  uint256 tokenId, address tokenAddress, address buyer, uint256 askingPrice, uint256 date, bool LPTBuy);\r\n    event singleItemRemoved(uint256 id, uint256 tokenId, address tokenAddress, uint256 askingPrice, uint256 date);\r\n    event LaunchPadTokenReward(address LPToken, uint256 amount, address sender, address recipient, uint256 date);\r\n    event walySold(address buyer, uint256 quantity, uint256 cost, uint256 date);\r\n    \r\n    //Ensures Launch Pad exclusive to WMTP holders\r\n    modifier onlyWMTPholder()\r\n            {\r\n                IERC721 WMTPcontract = IERC721(WMTP);\r\n                require(WMTPcontract.balanceOf(msg.sender) > 0,  \"Only WMTP holders can purchase from Launch Pad\");\r\n                _;\r\n            } \r\n    //Only ERC1155 owner check\r\n    modifier OnlyItemOwner(address tokenAddress, uint256 tokenId)\r\n            {\r\n                IERC1155 tokenContract = IERC1155(tokenAddress);\r\n                require(tokenContract.balanceOf(msg.sender, tokenId) > 0, \"You dont own the specific NFT(s)\"); //check if caller is owner of this token\r\n                _;\r\n            } \r\n    //1155 approval check        \r\n    modifier HasTransferApproval(address tokenAddress)\r\n            {\r\n                IERC1155 tokenContract = IERC1155(tokenAddress);\r\n                require(tokenContract.isApprovedForAll(msg.sender, address(this)) == true, \"You need to grant LaunchPad approval first\"); //check if callers given contract approvals\r\n                _;\r\n            }\r\n    //Only 721 Owner check        \r\n    modifier onlyNFTowner(address nftContract, uint256 tokenId)\r\n            {\r\n                IERC721 nftContract = IERC721(nftContract);\r\n                require(nftContract.ownerOf(tokenId) == msg.sender,  \"You dont own this NFT\");\r\n                _;\r\n            }            \r\n    //721 token approval check        \r\n    modifier canTransferNFT(address nftContract, uint256 tokenId)\r\n            {\r\n                IERC721 nftContract = IERC721(nftContract);\r\n                require(nftContract.getApproved(tokenId) == address(this), \"You need to grant Market approval first\"); \r\n                _;\r\n            }         \r\n\r\n    modifier onlyOwner\r\n    {\r\n        require(owner == msg.sender, \"Ownable: caller is not the owner\");\r\n        _;\r\n    }         \r\n    //check that offer is listed on LaunchPad\r\n    modifier ItemExist(uint256 id)\r\n            {\r\n                require(id < itemsForSale.length && itemsForSale[id].id == id,\"could not find id on LaunchPad\");\r\n                _;\r\n            }\r\n   //check offer has not be purchased    \r\n    modifier IsForSale(uint256 id)\r\n            {\r\n                require(itemsForSale[id].isSold == false,\"id already sold\");\r\n                _;\r\n            }\r\n    //check offer being made has been approved\r\n    modifier isLaunchPadItem(address contractAddress)\r\n    {\r\n        require(LaunchPadItem[contractAddress] == true, \"Only WMON contracts can be added\");\r\n        _;\r\n    } \r\n \r\n    //LaunchPad offer listings functionality //\r\n    \r\n    //ERC1155 offers    \r\n    function add1155ToLaunchPad(uint256 tokenId, address tokenAddress, uint256 units, uint256 askingPrice, bool useLTP) OnlyItemOwner(tokenAddress,tokenId) HasTransferApproval(tokenAddress) isLaunchPadItem(tokenAddress) onlyOwner external returns(uint256){\r\n                        \r\n            uint256 newItemId = itemsForSale.length;\r\n           \r\n            itemsForSale.push(AuctionItem(newItemId, tokenAddress, tokenId, payable(msg.sender), askingPrice, units, false, useLTP, 1155));\r\n           \r\n            activeItems[tokenAddress][tokenId] = true; //items now up for sale\r\n                      \r\n            assert(itemsForSale[newItemId].id == newItemId);\r\n            \r\n            emit multiItemAdded(newItemId, tokenId, tokenAddress, msg.sender, units ,askingPrice, block.timestamp);\r\n\r\n            return newItemId;      \r\n     }\r\n\r\n    //ERC721 offers\r\n    function add721toLaunchPad(uint256 tokenId, address tokenAddress, uint256 askingPrice, bool useLPT) onlyNFTowner(tokenAddress, tokenId) canTransferNFT(tokenAddress, tokenId) isLaunchPadItem(tokenAddress) onlyOwner external returns(uint256){\r\n          require(activeItems[tokenAddress][tokenId] == false,\"Item up for sale already\");\r\n          \r\n          uint256 newItemId = itemsForSale.length; \r\n\r\n          itemsForSale.push(AuctionItem(newItemId, tokenAddress, tokenId, payable(msg.sender), askingPrice, 1, false, useLPT, 721));\r\n           \r\n          activeItems[tokenAddress][tokenId] = true; \r\n                      \r\n          assert(itemsForSale[newItemId].id == newItemId);\r\n\r\n          emit singleItemAdded(newItemId, tokenId, tokenAddress, msg.sender, askingPrice, block.timestamp);\r\n\r\n          return newItemId;\r\n    }     \r\n\r\n\r\n\r\n    //WMTP Holders functions/Interactions//\r\n    \r\n    //Buy ERC1155 offers\r\n    function buyERC1155Offer(uint256 id) payable external ItemExist(id) IsForSale(id) onlyWMTPholder() {\r\n            //if offer is being listed in LPTs...\r\n            if(itemsForSale[id].useLPT == true){\r\n        \r\n                require(tokenApproved[LaunchPadTokens] == true,\"LaunchPad Token has not been approved\");\r\n                require(IERC20(LaunchPadTokens).balanceOf(msg.sender) >= itemsForSale[id].askingPrice, \"Not enough LaunchPad Tokens\");\r\n                require(msg.sender != itemsForSale[id].seller, \"cannot buy your own item, remove instead!\");\r\n\r\n                itemsForSale[id].isSold = true;\r\n                activeItems[itemsForSale[id].tokenAddress][itemsForSale[id].tokenId] = false; \r\n\r\n                IERC20(LaunchPadTokens).transferFrom(msg.sender, burn, itemsForSale[id].askingPrice *(10**18)); //Forever locks LPT \r\n\r\n                IERC1155(itemsForSale[id].tokenAddress).safeTransferFrom(itemsForSale[id].seller, msg.sender, itemsForSale[id].tokenId, itemsForSale[id].units, ''); //Transfer offerings to buyer\r\n\r\n                emit multiItemSold(id, itemsForSale[id].tokenId, itemsForSale[id].tokenAddress, msg.sender, itemsForSale[id].units ,itemsForSale[id].askingPrice, block.timestamp, true);\r\n\r\n            }else if(itemsForSale[id].useLPT == false){\r\n                //if offer is being listed in Native Token...\r\n                require(msg.value >= itemsForSale[id].askingPrice, \"Not enough funds\");\r\n                require(msg.sender != itemsForSale[id].seller, \"your item, remove\");\r\n            \r\n                itemsForSale[id].isSold = true;\r\n                activeItems[itemsForSale[id].tokenAddress][itemsForSale[id].tokenId] = false;\r\n          \r\n                itemsForSale[id].seller.transfer(msg.value);\r\n\r\n                LPlevel[msg.sender]+=1; //increase LPlevel for user\r\n                \r\n                //WMTP holders earn LaunchPad Tokens for each purchase from LaunchPad, LPTs can be used to purchase items\r\n                \r\n\r\n                uint256 guardBal = IERC20(LaunchPadTokens).balanceOf(sodGuard); \r\n               \r\n                IERC721 trainerPass = IERC721(WMTP);\r\n                uint256 wmtpBonus = trainerPass.balanceOf(msg.sender);\r\n\r\n                uint256 LPTbonus = wmtpBonus * 100; \r\n\r\n                //if sodGuard can cover rewards, pay out if not continue.\r\n                if(guardBal >= LPTbonus){\r\n                    //reward rates\r\n                    IERC20(LaunchPadTokens).transferFrom(sodGuard, msg.sender, LPTbonus *(10**18)); //transfer  LaunchPad Rewards\r\n   \r\n                    emit LaunchPadTokenReward(LaunchPadTokens, LPTbonus, sodGuard, msg.sender, block.timestamp);\r\n                }\r\n\r\n                //Finally transfer LaunchPad offers\r\n                IERC1155(itemsForSale[id].tokenAddress).safeTransferFrom(itemsForSale[id].seller, msg.sender, itemsForSale[id].tokenId, itemsForSale[id].units, '');\r\n\r\n                emit multiItemSold(id, itemsForSale[id].tokenId, itemsForSale[id].tokenAddress, msg.sender, itemsForSale[id].units ,itemsForSale[id].askingPrice, block.timestamp, false);\r\n            } \r\n        }\r\n\r\n   \r\n    //Buy ERC721 offers\r\n    function buyERC721Offer(uint256 id) payable external ItemExist(id) IsForSale(id) onlyWMTPholder()  {\r\n            //if offer is being listed in LPTs...\r\n            if(itemsForSale[id].useLPT == true){\r\n\r\n                require(tokenApproved[LaunchPadTokens] == true,\"LPT not approved\");\r\n                require(IERC20(LaunchPadTokens).balanceOf(msg.sender) >= itemsForSale[id].askingPrice, \"Not enough LPT\");\r\n                require(msg.sender != itemsForSale[id].seller, \"your item, remove\");\r\n\r\n                itemsForSale[id].isSold = true; \r\n                activeItems[itemsForSale[id].tokenAddress][itemsForSale[id].tokenId] = false;\r\n\r\n                IERC20(LaunchPadTokens).transferFrom(msg.sender, burn, itemsForSale[id].askingPrice *(10**18)); //for ever lock up\r\n\r\n                IERC721(itemsForSale[id].tokenAddress).safeTransferFrom(itemsForSale[id].seller, msg.sender, itemsForSale[id].tokenId, '');\r\n\r\n                emit singleItemSold(id,itemsForSale[id].tokenId, itemsForSale[id].tokenAddress, msg.sender, itemsForSale[id].askingPrice, block.timestamp, true);\r\n\r\n            }else if(itemsForSale[id].useLPT == false){\r\n                //if offer is being listed in Native token...\r\n                require(msg.value >= itemsForSale[id].askingPrice, \"Not enough funds\");\r\n                require(msg.sender != itemsForSale[id].seller, \"your item, remove\");\r\n\r\n                itemsForSale[id].isSold = true; \r\n                activeItems[itemsForSale[id].tokenAddress][itemsForSale[id].tokenId] = false; \r\n\r\n                LPlevel[msg.sender]+=1; //increase LPlevel for user\r\n\r\n                itemsForSale[id].seller.transfer(msg.value);\r\n\r\n                //WMTP holders earn LaunchPad Tokens for each purchase from LaunchPad, LPTs can be used to purchase items\r\n\r\n                uint256 guardBal = IERC20(LaunchPadTokens).balanceOf(sodGuard); //Get balance of remaining LPTs\r\n               \r\n                IERC721 trainerPass = IERC721(WMTP);\r\n                uint256 wmtpBonus = trainerPass.balanceOf(msg.sender);\r\n\r\n                uint256 LPTbonus = wmtpBonus * 100; //LPT rewards amount\r\n\r\n                 if(guardBal >= LPTbonus){\r\n                        \r\n                        IERC20(LaunchPadTokens).transferFrom(sodGuard, msg.sender, LPTbonus *(10**18)); //reward LPT\r\n    \r\n                        emit LaunchPadTokenReward(LaunchPadTokens, LPTbonus, sodGuard, msg.sender, block.timestamp);\r\n                    }\r\n                \r\n                //finally transfer item\r\n                IERC721(itemsForSale[id].tokenAddress).safeTransferFrom(itemsForSale[id].seller, msg.sender, itemsForSale[id].tokenId, '');\r\n\r\n                emit singleItemSold(id,itemsForSale[id].tokenId, itemsForSale[id].tokenAddress, msg.sender, itemsForSale[id].askingPrice, block.timestamp, false);\r\n\r\n            }\r\n            \r\n        }       \r\n    //Buy Discounted $WALY\r\n    function discountedWALY() public payable onlyWMTPholder() {\r\n\r\n        require(tokenApproved[Wallebytes] == true, \"$WALY not approved\");\r\n        require(IERC20(Wallebytes).balanceOf(sodGuard) >= 100000, \"reserve depleted\");\r\n        require(msg.value >= walyCost, \"Not enough funds\");\r\n        \r\n        payable(sodGuard).transfer(msg.value);\r\n\r\n        LPlevel[msg.sender]+=1; //increase LPlevel for user\r\n\r\n        IERC20(Wallebytes).transferFrom(sodGuard, msg.sender, 100000 *(10**18));\r\n\r\n        emit walySold(msg.sender, 100000, walyCost, block.timestamp);\r\n    }\r\n\r\n    //Remove Offer from LaunchPad\r\n    function removeOffer(uint256 id) public ItemExist(id) IsForSale(id) onlyOwner returns(bool success){\r\n             require(msg.sender == itemsForSale[id].seller);\r\n           \r\n            //if ERC721...\r\n            if(itemsForSale[id].tokenType == 721){\r\n                activeItems[itemsForSale[id].tokenAddress][itemsForSale[id].tokenId] = false;\r\n                delete itemsForSale[id];\r\n             \r\n             //!\r\n              emit singleItemRemoved(id, itemsForSale[id].tokenId, itemsForSale[id].tokenAddress, itemsForSale[id].askingPrice, block.timestamp);\r\n\r\n            }else if(itemsForSale[id].tokenType == 1155){\r\n                //if ERC1155...\r\n                activeItems[itemsForSale[id].tokenAddress][itemsForSale[id].tokenId] = false;\r\n                delete itemsForSale[id];\r\n             \r\n             emit multiItemRemoved(id, itemsForSale[id].tokenId, itemsForSale[id].tokenAddress, itemsForSale[id].units , itemsForSale[id].askingPrice, block.timestamp);\r\n\r\n            }\r\n            \r\n            return success;\r\n        } \r\n\r\n    \r\n    //Owner Utility functions\r\n        //Sets //\r\n\r\n  //Wallet Monsters Trainer Pass\r\n  function setWMTPcontract(address _WMTP) public onlyOwner returns(address){\r\n            WMTP = _WMTP;\r\n\r\n            return WMTP;\r\n  }\r\n  //LaunchPad Tokens\r\n  function setLPTcontract(address _LPT) public onlyOwner returns(address){\r\n            LaunchPadTokens = _LPT;\r\n\r\n            return LaunchPadTokens;\r\n  }\r\n    //WalleBytes\r\n  function setWALYcontract(address _WALY) public onlyOwner returns(address){\r\n                Wallebytes = _WALY;\r\n\r\n                return Wallebytes;\r\n    }  \r\n    //set discounted Price\r\n    function setWALYprice(uint256 _cost) public onlyOwner returns(uint256){\r\n            walyCost = _cost;\r\n\r\n        return walyCost;\r\n    } \r\n\r\n        //Set Approvals//\r\n\r\n  //Interoperable contracts from Wallet Monster Metaverse      \r\n  function addProject(address Contract, bool _status) public onlyOwner returns(bool){\r\n      LaunchPadItem[Contract] = _status;\r\n      \r\n      return  _status;\r\n  }\r\n\r\n  //$WALY Tokens\r\n  function approveWALY(bool _status) public onlyOwner returns(bool){\r\n            tokenApproved[Wallebytes] = _status;            \r\n\r\n            return  tokenApproved[Wallebytes];\r\n  } \r\n\r\n  //LaunchPad Tokens \r\n  function approveLPT(bool _status) public onlyOwner returns(bool){\r\n            tokenApproved[LaunchPadTokens] = _status;\r\n\r\n            return tokenApproved[LaunchPadTokens];\r\n  }\r\n\r\n  //check approvals\r\n\r\n  //check if Launchpad items contract has been approved  \r\n  function approvedProjects(address sodContract) public view returns(bool){\r\n      return LaunchPadItem[sodContract];\r\n  }\r\n    //check if tokens been approved\r\n   function approvedTokens(address _Contract) public view returns(bool){\r\n      return tokenApproved[_Contract];\r\n  }\r\n\r\n\r\n\r\n  //Happenstance withdrawl is needed, (donations etc no tokens are transferred or held within contract\r\n\r\nfunction withdraw() public payable onlyOwner {\r\n    // This will pay partner 50% of every withdraw.\r\n    // =============================================================================\r\n    (bool hs, ) = payable(0x625Cd0169A8B36E138D84a00BCa1d9d1c8b45f51).call{value: address(this).balance * 50 / 100}(\"\");\r\n    require(hs);\r\n    // =============================================================================\r\n    \r\n    // This will payout the owner 50% of the contract balance.\r\n    // =============================================================================\r\n    (bool os, ) = payable(owner).call{value: address(this).balance}(\"\");\r\n    require(os);\r\n    // =============================================================================\r\n  }\r\n\r\n  //LP Level\r\n  function launchpadLevel(address _trainer) public view returns(uint256){\r\n      return LPlevel[_trainer];\r\n  }\r\n\r\n  //items listed on launchPad\r\n  function LaunchPadListingCount() public view returns(uint256){\r\n      return itemsForSale.length;\r\n  }\r\n\r\n  //LaunchPad Balances  \r\nfunction launchPadBalance() onlyOwner public view returns(uint256 balance){\r\n      return address(this).balance;\r\n  }   \r\n\r\n\r\n//Suns Of DeFi ~ IBN5X ~ Prof. Kalito ~ Suns Of DeFi\r\n}","ABI":"[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"LPToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"date\",\"type\":\"uint256\"}],\"name\":\"LaunchPadTokenReward\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"seller\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"askingPrice\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"date\",\"type\":\"uint256\"}],\"name\":\"multiItemAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"askingPrice\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"date\",\"type\":\"uint256\"}],\"name\":\"multiItemRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"buyer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"askingPrice\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"date\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"LPTBuy\",\"type\":\"bool\"}],\"name\":\"multiItemSold\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"seller\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"askingPrice\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"date\",\"type\":\"uint256\"}],\"name\":\"singleItemAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"askingPrice\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"date\",\"type\":\"uint256\"}],\"name\":\"singleItemRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"buyer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"askingPrice\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"date\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"LPTBuy\",\"type\":\"bool\"}],\"name\":\"singleItemSold\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"buyer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"quantity\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"cost\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"date\",\"type\":\"uint256\"}],\"name\":\"walySold\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"LPlevel\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"LaunchPadListingCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"LaunchPadTokens\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"WMTP\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"Wallebytes\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"units\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"askingPrice\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"useLTP\",\"type\":\"bool\"}],\"name\":\"add1155ToLaunchPad\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"askingPrice\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"useLPT\",\"type\":\"bool\"}],\"name\":\"add721toLaunchPad\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"Contract\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_status\",\"type\":\"bool\"}],\"name\":\"addProject\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_status\",\"type\":\"bool\"}],\"name\":\"approveLPT\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_status\",\"type\":\"bool\"}],\"name\":\"approveWALY\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sodContract\",\"type\":\"address\"}],\"name\":\"approvedProjects\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_Contract\",\"type\":\"address\"}],\"name\":\"approvedTokens\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"buyERC1155Offer\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"buyERC721Offer\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"discountedWALY\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"itemsForSale\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"address payable\",\"name\":\"seller\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"askingPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"units\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isSold\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"useLPT\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"tokenType\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"launchPadBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_trainer\",\"type\":\"address\"}],\"name\":\"launchpadLevel\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"removeOffer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_LPT\",\"type\":\"address\"}],\"name\":\"setLPTcontract\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_WALY\",\"type\":\"address\"}],\"name\":\"setWALYcontract\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_cost\",\"type\":\"uint256\"}],\"name\":\"setWALYprice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_WMTP\",\"type\":\"address\"}],\"name\":\"setWMTPcontract\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"tokenApproved\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"walyCost\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"}]","ContractName":"WalletMonstersLaunchPad","CompilerVersion":"v0.8.7+commit.e28d00a7","OptimizationUsed":"1","Runs":"1","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"ipfs://12d1165d29a39a04c0d44b8124dc38ac05bbe5eefb45dc7bb6cd7bcecf128245"}]}