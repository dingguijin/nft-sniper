{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity =0.6.6;\r\n\r\n//ERC20相关接口\r\ninterface IERC20Interface {\r\n    function balanceOf(address tokenOwner) external view returns (uint balance);\r\n    function transfer(address to, uint tokens) external returns (bool success);\r\n    function approve(address spender, uint tokens) external returns (bool success);\r\n}\r\n\r\n// UniswapV2相关接口\r\ninterface IUniswapV2Pair {\r\n    function token0() external view returns (address);\r\n    function token1() external view returns (address);\r\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\r\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\r\n}\r\n\r\ninterface IUniswapV2Factory {\r\n    function getPair(address token0, address token1) external view returns (address pair);\r\n}\r\n\r\ncontract CustomQuoterNew {\r\n\r\n    address constant private lucky = address(666);\r\n    bytes4 private constant SELECTOR = bytes4(keccak256(bytes('transfer(address,uint256)')));\r\n\r\n    /**\r\n     * @dev 批量获取代币的某个交易对 \r\n     * @param facs 所有factory\r\n     * @param tokens 所有代币\r\n     * @param coins 所有基准币（交易对手另一种币)\r\n     * @return pairs 返回所有代币获取的第一个交易对，如果没有，则为address(0)\r\n     */\r\n    function getPairs(address[] calldata facs, address[] calldata tokens, address[] calldata coins) external view returns(address[] memory pairs) {\r\n        pairs = new address[](tokens.length);\r\n        for(uint i=0;i< tokens.length;i++) {\r\n            address token = tokens[i];\r\n            for(uint j=0;j<facs.length;j++) {\r\n                address fac = facs[j];\r\n                for(uint k=0;k<coins.length;k++) {\r\n                    address addr = IUniswapV2Factory(fac).getPair(token,coins[k]);\r\n                    if(addr != address(0)) {\r\n                        pairs[i] = addr;\r\n                        break;\r\n                    }\r\n                }\r\n                if(pairs[i] != address(0)) {\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n\r\n    /**\r\n     * @dev 批量查询代币的损耗率\r\n     * @notice 所有交易对必须通过上在的getPairs 函数查询，并剔除掉零地址\r\n     * @param tokens 所有代币\r\n     * @param pairs 所有包含该代币的uniswapv2交易对\r\n     * @return rates 所有代币的三种损耗率\r\n     */\r\n    function batchQuoteRates(address[] calldata tokens, address[] calldata pairs) external returns (uint[] memory rates) {\r\n        require(tokens.length > 0 && tokens.length == pairs.length);\r\n        rates = new uint[](tokens.length);\r\n        for(uint i=0;i<tokens.length;i++) {\r\n            address pair = pairs[i];\r\n            address token = tokens[i];\r\n            address token0 =  IUniswapV2Pair(pair).token0();\r\n            (uint reserve00, uint reserve01, ) = IUniswapV2Pair(pair).getReserves();\r\n            uint amountOut0 = token0 == token ?  reserve00 / 100000000 : 0;\r\n            uint amountOut1 = token0 == token ? 0 : reserve01 /100000000;\r\n            try \r\n                IUniswapV2Pair(pair).swap(amountOut0,amountOut1,address(this),bytes(\"amm\"))\r\n            {} catch (bytes memory reason) {\r\n                rates[i] =  parseRevertReasonM(reason);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev 查询某个代币的损耗率\r\n     * @param token 查询的代币\r\n     * @param pair  包含查询代币的任意UniswapV2交易对。注意交易对要标准的支持闪电贷。\r\n     * @return rate 买卖和转移过程中的损耗率\r\n     */\r\n    function quoteRate(address token, address pair) public returns (uint rate) {\r\n        address token0 =  IUniswapV2Pair(pair).token0();\r\n        (uint reserve00, uint reserve01, ) = IUniswapV2Pair(pair).getReserves();\r\n        uint amountOut0 = token0 == token ?  reserve00 / 10000000 : 0;\r\n        uint amountOut1 = token0 == token ? 0 : reserve01 /10000000;\r\n        try \r\n            IUniswapV2Pair(pair).swap(amountOut0,amountOut1,address(this),bytes(\"amm\"))\r\n        {} catch (bytes memory reason) {\r\n            return parseRevertReasonS(reason);\r\n        }\r\n    }\r\n\r\n    function parseRevertReasonS(bytes memory reason) private pure returns (uint256) {\r\n        if (reason.length != 32) {\r\n            if (reason.length < 68) revert('Unexpected error');\r\n            assembly {\r\n                reason := add(reason, 0x04)\r\n            }\r\n            revert(abi.decode(reason, (string)));\r\n        }\r\n        return abi.decode(reason, (uint256));\r\n    }\r\n\r\n\r\n\r\n    /// @dev Parses a revert reason that should contain the numeric quote\r\n    function parseRevertReasonM(bytes memory reason) private pure returns (uint256) {\r\n        if (reason.length != 32) {\r\n            // if (reason.length < 68) revert('Unexpected error');\r\n            // assembly {\r\n            //     reason := add(reason, 0x04)\r\n            // }\r\n            // revert(abi.decode(reason, (string)));\r\n            return uint(-1);\r\n        }\r\n        return abi.decode(reason, (uint256));\r\n    }\r\n\r\n    fallback () external payable virtual {\r\n        bytes memory data = msg.data;\r\n        uint amount0;\r\n        uint amount1;\r\n        assembly {\r\n            amount0 := mload(add(data,68))\r\n            amount1 := mload(add(data,100))\r\n        }\r\n        address token0 = IUniswapV2Pair(msg.sender).token0();\r\n        address token1 = IUniswapV2Pair(msg.sender).token1();\r\n        address token = amount0 > 0 ? token0 : token1;\r\n        uint amount = amount0 > 0 ? amount0 : amount1;\r\n        uint bal =  IERC20Interface(token).balanceOf(address(this));\r\n        require(amount >= bal,\"inner error\");\r\n        uint buyRate = 1000 * (amount - bal) / amount;\r\n\r\n        uint send_value = bal/2;\r\n        uint bal_before = IERC20Interface(token).balanceOf(msg.sender);\r\n        _safeTransfer(token,msg.sender,send_value);\r\n        uint bal_after = IERC20Interface(token).balanceOf(msg.sender);\r\n        uint dev = bal_after - bal_before;\r\n        uint sellRate = (send_value - dev ) * 1000 / send_value;\r\n\r\n        bal_before = IERC20Interface(token).balanceOf(lucky);\r\n        _safeTransfer(token,lucky,send_value);\r\n        bal_after = IERC20Interface(token).balanceOf(lucky);\r\n        dev = bal_after - bal_before;\r\n        uint transferRate = (send_value - dev ) * 1000 / send_value;\r\n        uint rate = (buyRate << 32) + (sellRate << 16) + transferRate;\r\n        assembly {\r\n            let ptr := mload(0x40)\r\n            mstore(ptr, rate)\r\n            revert(ptr, 32)\r\n        }\r\n    }\r\n\r\n    function _safeTransfer(address token, address to, uint value) private {\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(SELECTOR, to, value));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'UniswapV2: TRANSFER_FAILED');\r\n    }\r\n\r\n}","ABI":"[{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"tokens\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"pairs\",\"type\":\"address[]\"}],\"name\":\"batchQuoteRates\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"rates\",\"type\":\"uint256[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"facs\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"tokens\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"coins\",\"type\":\"address[]\"}],\"name\":\"getPairs\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"pairs\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"pair\",\"type\":\"address\"}],\"name\":\"quoteRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"rate\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"CustomQuoterNew","CompilerVersion":"v0.6.6+commit.6c089d02","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"Unknown","Proxy":"0","Implementation":"","SwarmSource":"ipfs://2d9745bb25e77e3b25d19c67920bca1fbf8c481250728eb4fae6111aa6527da4"}]}