{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"settings\": {\r\n    \"evmVersion\": \"istanbul\",\r\n    \"libraries\": {},\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"remappings\": [],\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  },\r\n  \"sources\": {\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if the sender is not the owner.\\n     */\\n    function _checkOwner() internal view virtual {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/Sources/SourceENS.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\npragma solidity 0.8.15;\\n\\nimport { Ownable } from \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport { NameEncoder } from \\\"../libraries/NameEncoder.sol\\\";\\nimport { ISource } from \\\"../interfaces/ISource.sol\\\";\\nimport { IReverseRegistrar } from \\\"../interfaces/ENS/IReverseRegistrar.sol\\\";\\nimport { ITextResolver } from \\\"../interfaces/ENS/ITextResolver.sol\\\";\\nimport { IDefaultReverseResolver } from \\\"../interfaces/ENS/IDefaultReverseResolver.sol\\\";\\n\\ncontract SourceENS is ISource, Ownable {\\n  using NameEncoder for string;\\n\\n  string[] private _keys;\\n  address private constant RESOLVER = 0x4976fb03C32e5B8cfe2b6cCB31c09Ba78EBaBa41;\\n  address private constant REVERSE_REGISTRAR = 0x084b1c3C81545d370f3634392De611CaaBFf8148;\\n  address private constant DEFAULT_REVERSE_RESOLVER = 0xA2C122BE93b0074270ebeE7f6b7292C7deB45047;\\n\\n  constructor() {\\n    _keys.push(\\\"avatar\\\");\\n    _keys.push(\\\"url\\\");\\n    _keys.push(\\\"description\\\");\\n    _keys.push(\\\"com.github\\\");\\n    _keys.push(\\\"com.twitter\\\");\\n    _keys.push(\\\"org.telegram\\\");\\n    _keys.push(\\\"did\\\");\\n  }\\n\\n  /* ===================================================================================== */\\n  /* External Functions                                                                    */\\n  /* ===================================================================================== */\\n\\n  /**\\n   * @notice Get Keys\\n   * @return keys string[]\\n   */\\n  function getKeys() external view returns (string[] memory keys) {\\n    return _keys;\\n  }\\n\\n  /**\\n   * @notice Get data fields count for user\\n   * @return count uint256\\n   */\\n  function count(address user) external view returns (uint256 count) {\\n    (, bytes32 node_, ITextResolver res_) = _resolveOwner(user);\\n    (string[] memory keys_, ) = _fetchNodeTextFields(_keys, node_, res_);\\n    return keys_.length;\\n  }\\n\\n  /**\\n   * @notice Get all available data for user\\n   * @param user address\\n   * @return keys string[]\\n   * @return values string[]\\n   */\\n  function getData(address user)\\n    external\\n    view\\n    returns (string[] memory keys, string[] memory values)\\n  {\\n    (, bytes32 node_, ITextResolver res_) = _resolveOwner(user);\\n    (string[] memory keys_, string[] memory values_) = _fetchNodeTextFields(_keys, node_, res_);\\n    return (keys_, values_);\\n  }\\n\\n  function getMetadata(address _address)\\n    external\\n    view\\n    returns (\\n      bytes32 node,\\n      string memory name,\\n      address resolver\\n    )\\n  {\\n    (string memory name, bytes32 node, ITextResolver resolver) = _resolveOwner(_address);\\n    return (node, name, address(resolver));\\n  }\\n\\n  /**\\n   * @notice Get data value for user\\n   * @param user address\\n   * @param key string\\n   * @return value string\\n   */\\n  function getValue(address user, string memory key) external view returns (string memory) {\\n    (, bytes32 node_, ITextResolver res_) = _resolveOwner(user);\\n    return res_.text(node_, key);\\n  }\\n\\n  /**\\n   * @notice Append Key\\n   * @param key string\\n   */\\n  function appendKey(string calldata key) external onlyOwner {\\n    _keys.push(key);\\n  }\\n\\n  /**\\n   * @notice Set Key\\n   * @param idx uint256\\n   * @param key string\\n   */\\n  function updateKey(uint256 idx, string calldata key) external onlyOwner {\\n    _keys[idx] = key;\\n  }\\n\\n  /* ===================================================================================== */\\n  /* Internal Functions                                                                    */\\n  /* ===================================================================================== */\\n\\n  function _resolveOwner(address owner_)\\n    internal\\n    view\\n    returns (\\n      string memory,\\n      bytes32,\\n      ITextResolver\\n    )\\n  {\\n    bytes32 node_ = IReverseRegistrar(REVERSE_REGISTRAR).node(owner_);\\n    string memory _name = IDefaultReverseResolver(DEFAULT_REVERSE_RESOLVER).name(node_);\\n    (, bytes32 _node) = _name.dnsEncodeName();\\n    ITextResolver _resolver = ITextResolver(RESOLVER);\\n    return (_name, _node, _resolver);\\n  }\\n\\n  function _fetchNodeTextFields(\\n    string[] memory _traits,\\n    bytes32 _node,\\n    ITextResolver _resolver\\n  ) internal view returns (string[] memory keys_, string[] memory values_) {\\n    string[] memory __keys = new string[](_traits.length);\\n    string[] memory __values = new string[](_traits.length);\\n    for (uint256 i = 0; i < _traits.length; i++) {\\n      __keys[i] = _traits[i];\\n      __values[i] = _resolver.text(_node, _traits[i]);\\n    }\\n    return (__keys, __values);\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ENS/IDefaultReverseResolver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.4;\\n\\ninterface IDefaultReverseResolver {\\n  function name(bytes32 input) external view returns (string calldata);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ENS/IReverseRegistrar.sol\": {\r\n      \"content\": \"pragma solidity >=0.8.4;\\n\\ninterface IReverseRegistrar {\\n  function setDefaultResolver(address resolver) external;\\n\\n  function claim(address owner) external returns (bytes32);\\n\\n  function claimForAddr(\\n    address addr,\\n    address owner,\\n    address resolver\\n  ) external returns (bytes32);\\n\\n  function claimWithResolver(address owner, address resolver) external returns (bytes32);\\n\\n  function setName(string memory name) external returns (bytes32);\\n\\n  function setNameForAddr(\\n    address addr,\\n    address owner,\\n    address resolver,\\n    string memory name\\n  ) external returns (bytes32);\\n\\n  function node(address addr) external pure returns (bytes32);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ENS/ITextResolver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.4;\\n\\ninterface ITextResolver {\\n  event TextChanged(bytes32 indexed node, string indexed indexedKey, string key);\\n\\n  /**\\n   * Returns the text data associated with an ENS node and key.\\n   * @param node The ENS node to query.\\n   * @param key The text data key to query.\\n   * @return The associated text data.\\n   */\\n  function text(bytes32 node, string calldata key) external view returns (string memory);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ISource.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: MIT\\npragma solidity 0.8.15;\\n\\ninterface ISource {\\n  function count(address _address) external view returns (uint256);\\n\\n  function getData(address _address)\\n    external\\n    view\\n    returns (string[] memory keys, string[] memory values);\\n\\n  function getValue(address _address, string memory _key) external view returns (string memory);\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/BytesUtils.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: MIT\\npragma solidity >=0.8.4;\\n\\nlibrary BytesUtils {\\n  /*\\n   * @dev Returns the keccak-256 hash of a byte range.\\n   * @param self The byte string to hash.\\n   * @param offset The position to start hashing at.\\n   * @param len The number of bytes to hash.\\n   * @return The hash of the byte range.\\n   */\\n  function keccak(\\n    bytes memory self,\\n    uint256 offset,\\n    uint256 len\\n  ) internal pure returns (bytes32 ret) {\\n    require(offset + len <= self.length);\\n    assembly {\\n      ret := keccak256(add(add(self, 32), offset), len)\\n    }\\n  }\\n\\n  /**\\n   * @dev Returns the ENS namehash of a DNS-encoded name.\\n   * @param self The DNS-encoded name to hash.\\n   * @param offset The offset at which to start hashing.\\n   * @return The namehash of the name.\\n   */\\n  function namehash(bytes memory self, uint256 offset) internal pure returns (bytes32) {\\n    (bytes32 labelhash, uint256 newOffset) = readLabel(self, offset);\\n    if (labelhash == bytes32(0)) {\\n      require(offset == self.length - 1, \\\"namehash: Junk at end of name\\\");\\n      return bytes32(0);\\n    }\\n    return keccak256(abi.encodePacked(namehash(self, newOffset), labelhash));\\n  }\\n\\n  /**\\n   * @dev Returns the keccak-256 hash of a DNS-encoded label, and the offset to the start of the next label.\\n   * @param self The byte string to read a label from.\\n   * @param idx The index to read a label at.\\n   * @return labelhash The hash of the label at the specified index, or 0 if it is the last label.\\n   * @return newIdx The index of the start of the next label.\\n   */\\n  function readLabel(bytes memory self, uint256 idx)\\n    internal\\n    pure\\n    returns (bytes32 labelhash, uint256 newIdx)\\n  {\\n    require(idx < self.length, \\\"readLabel: Index out of bounds\\\");\\n    uint256 len = uint256(uint8(self[idx]));\\n    if (len > 0) {\\n      labelhash = keccak(self, idx + 1, len);\\n    } else {\\n      labelhash = bytes32(0);\\n    }\\n    newIdx = idx + len + 1;\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/NameEncoder.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.15;\\n\\nimport \\\"./BytesUtils.sol\\\";\\n\\nlibrary NameEncoder {\\n  using BytesUtils for bytes;\\n\\n  function dnsEncodeName(string memory name)\\n    internal\\n    pure\\n    returns (bytes memory dnsName, bytes32 node)\\n  {\\n    uint8 labelLength = 0;\\n    bytes memory bytesName = bytes(name);\\n    uint256 length = bytesName.length;\\n    dnsName = new bytes(length + 2);\\n    node = 0;\\n    if (length == 0) {\\n      dnsName[0] = 0;\\n      return (dnsName, node);\\n    }\\n\\n    // use unchecked to save gas since we check for an underflow\\n    // and we check for the length before the loop\\n    unchecked {\\n      for (uint256 i = length - 1; i >= 0; i--) {\\n        if (bytesName[i] == \\\".\\\") {\\n          dnsName[i + 1] = bytes1(labelLength);\\n          node = keccak256(abi.encodePacked(node, bytesName.keccak(i + 1, labelLength)));\\n          labelLength = 0;\\n        } else {\\n          labelLength += 1;\\n          dnsName[i + 1] = bytesName[i];\\n        }\\n        if (i == 0) {\\n          break;\\n        }\\n      }\\n    }\\n\\n    node = keccak256(abi.encodePacked(node, bytesName.keccak(0, labelLength)));\\n\\n    dnsName[0] = bytes1(labelLength);\\n    return (dnsName, node);\\n  }\\n}\\n\"\r\n    }\r\n  }\r\n}}","ABI":"[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"key\",\"type\":\"string\"}],\"name\":\"appendKey\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"count\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"count\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getData\",\"outputs\":[{\"internalType\":\"string[]\",\"name\":\"keys\",\"type\":\"string[]\"},{\"internalType\":\"string[]\",\"name\":\"values\",\"type\":\"string[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getKeys\",\"outputs\":[{\"internalType\":\"string[]\",\"name\":\"keys\",\"type\":\"string[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"getMetadata\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"node\",\"type\":\"bytes32\"},{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"resolver\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"key\",\"type\":\"string\"}],\"name\":\"getValue\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"idx\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"key\",\"type\":\"string\"}],\"name\":\"updateKey\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"SourceENS","CompilerVersion":"v0.8.15+commit.e14f2714","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"GNU GPLv3","Proxy":"0","Implementation":"","SwarmSource":""}]}