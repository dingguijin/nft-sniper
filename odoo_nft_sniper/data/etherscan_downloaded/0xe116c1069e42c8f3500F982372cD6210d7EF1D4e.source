{"status":"1","message":"OK","result":[{"SourceCode":"//SPDX-License-Identifier: MIT\r\npragma solidity 0.8.14;\r\n\r\n/**\r\n * @dev These functions deal with verification of Merkle Trees proofs.\r\n *\r\n * The proofs can be generated using the JavaScript library\r\n * https://github.com/miguelmota/merkletreejs[merkletreejs].\r\n * Note: the hashing algorithm should be keccak256 and pair sorting should be enabled.\r\n *\r\n * See `test/utils/cryptography/MerkleProof.test.js` for some examples.\r\n */\r\nlibrary MerkleProof {\r\n    /**\r\n     * @dev Returns true if a `leaf` can be proved to be a part of a Merkle tree\r\n     * defined by `root`. For this, a `proof` must be provided, containing\r\n     * sibling hashes on the branch from the leaf to the root of the tree. Each\r\n     * pair of leaves and each pair of pre-images are assumed to be sorted.\r\n     */\r\n    function verify(\r\n        bytes32[] memory proof,\r\n        bytes32 root,\r\n        bytes32 leaf\r\n    ) internal pure returns (bool) {\r\n        return processProof(proof, leaf) == root;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the rebuilt hash obtained by traversing a Merklee tree up\r\n     * from `leaf` using `proof`. A `proof` is valid if and only if the rebuilt\r\n     * hash matches the root of the tree. When processing the proof, the pairs\r\n     * of leafs & pre-images are assumed to be sorted.\r\n     *\r\n     * _Available since v4.4._\r\n     */\r\n    function processProof(bytes32[] memory proof, bytes32 leaf) internal pure returns (bytes32) {\r\n        bytes32 computedHash = leaf;\r\n        for (uint256 i = 0; i < proof.length; i++) {\r\n            bytes32 proofElement = proof[i];\r\n            if (computedHash <= proofElement) {\r\n                // Hash(current computed hash + current element of the proof)\r\n                computedHash = _efficientHash(computedHash, proofElement);\r\n            } else {\r\n                // Hash(current element of the proof + current computed hash)\r\n                computedHash = _efficientHash(proofElement, computedHash);\r\n            }\r\n        }\r\n        return computedHash;\r\n    }\r\n\r\n    function _efficientHash(bytes32 a, bytes32 b) private pure returns (bytes32 value) {\r\n        assembly {\r\n            mstore(0x00, a)\r\n            mstore(0x20, b)\r\n            value := keccak256(0x00, 0x40)\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * @dev Interface of the ERC165 standard, as defined in the\r\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\r\n *\r\n * Implementers can declare support of contract interfaces, which can then be\r\n * queried by others ({ERC165Checker}).\r\n *\r\n * For an implementation, see {ERC165}.\r\n */\r\ninterface IERC165 {\r\n    /**\r\n     * @dev Returns true if this contract implements the interface defined by\r\n     * `interfaceId`. See the corresponding\r\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\r\n     * to learn more about how these ids are created.\r\n     *\r\n     * This function call must use less than 30 000 gas.\r\n     */\r\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\r\n}\r\n\r\n/**\r\n * @dev Implementation of the {IERC165} interface.\r\n *\r\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\r\n * for the additional interface id that will be supported. For example:\r\n *\r\n * ```solidity\r\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\r\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\r\n * }\r\n * ```\r\n *\r\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\r\n */\r\nabstract contract ERC165 is IERC165 {\r\n    /**\r\n     * @dev See {IERC165-supportsInterface}.\r\n     */\r\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\r\n        return interfaceId == type(IERC165).interfaceId;\r\n    }\r\n}\r\n\r\n/**\r\n * @dev Required interface of an ERC721 compliant contract.\r\n */\r\ninterface IERC721 is IERC165 {\r\n    /**\r\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\r\n\r\n    /**\r\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\r\n     */\r\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\r\n\r\n    /**\r\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\r\n     */\r\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\r\n\r\n    /**\r\n     * @dev Returns the number of tokens in ``owner``'s account.\r\n     */\r\n    function balanceOf(address owner) external view returns (uint256 balance);\r\n\r\n    /**\r\n     * @dev Returns the owner of the `tokenId` token.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `tokenId` must exist.\r\n     */\r\n    function ownerOf(uint256 tokenId) external view returns (address owner);\r\n\r\n    /**\r\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\r\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `from` cannot be the zero address.\r\n     * - `to` cannot be the zero address.\r\n     * - `tokenId` token must exist and be owned by `from`.\r\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\r\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId\r\n    ) external;\r\n\r\n    /**\r\n     * @dev Transfers `tokenId` token from `from` to `to`.\r\n     *\r\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `from` cannot be the zero address.\r\n     * - `to` cannot be the zero address.\r\n     * - `tokenId` token must be owned by `from`.\r\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId\r\n    ) external;\r\n\r\n    /**\r\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\r\n     * The approval is cleared when the token is transferred.\r\n     *\r\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The caller must own the token or be an approved operator.\r\n     * - `tokenId` must exist.\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address to, uint256 tokenId) external;\r\n\r\n    /**\r\n     * @dev Returns the account approved for `tokenId` token.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `tokenId` must exist.\r\n     */\r\n    function getApproved(uint256 tokenId) external view returns (address operator);\r\n\r\n    /**\r\n     * @dev Approve or remove `operator` as an operator for the caller.\r\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The `operator` cannot be the caller.\r\n     *\r\n     * Emits an {ApprovalForAll} event.\r\n     */\r\n    function setApprovalForAll(address operator, bool _approved) external;\r\n\r\n    /**\r\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\r\n     *\r\n     * See {setApprovalForAll}\r\n     */\r\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\r\n\r\n    /**\r\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `from` cannot be the zero address.\r\n     * - `to` cannot be the zero address.\r\n     * - `tokenId` token must exist and be owned by `from`.\r\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\r\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId,\r\n        bytes calldata data\r\n    ) external;\r\n}\r\n\r\n/**\r\n * @title ERC721 token receiver interface\r\n * @dev Interface for any contract that wants to support safeTransfers\r\n * from ERC721 asset contracts.\r\n */\r\ninterface IERC721Receiver {\r\n    /**\r\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\r\n     * by `operator` from `from`, this function is called.\r\n     *\r\n     * It must return its Solidity selector to confirm the token transfer.\r\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\r\n     *\r\n     * The selector can be obtained in Solidity with `IERC721.onERC721Received.selector`.\r\n     */\r\n    function onERC721Received(\r\n        address operator,\r\n        address from,\r\n        uint256 tokenId,\r\n        bytes calldata data\r\n    ) external returns (bytes4);\r\n}\r\n\r\n\r\n/**\r\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\r\n * @dev See https://eips.ethereum.org/EIPS/eip-721\r\n */\r\ninterface IERC721Metadata is IERC721 {\r\n    /**\r\n     * @dev Returns the token collection name.\r\n     */\r\n    function name() external view returns (string memory);\r\n\r\n    /**\r\n     * @dev Returns the token collection symbol.\r\n     */\r\n    function symbol() external view returns (string memory);\r\n\r\n    /**\r\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\r\n     */\r\n    function tokenURI(uint256 tokenId) external view returns (string memory);\r\n}\r\n\r\nlibrary Address {\r\n\r\n    /**\r\n     * @dev Returns true if `account` is a contract.\r\n     *\r\n     * [IMPORTANT]\r\n     * ====\r\n     * It is unsafe to assume that an address for which this function returns\r\n     * false is an externally-owned account (EOA) and not a contract.\r\n     *\r\n     * Among others, `isContract` will return false for the following\r\n     * types of addresses:\r\n     *\r\n     *  - an externally-owned account\r\n     *  - a contract in construction\r\n     *  - an address where a contract will be created\r\n     *  - an address where a contract lived, but was destroyed\r\n     * ====\r\n     */\r\n    function isContract(address account) internal view returns (bool) {\r\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\r\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\r\n        // for accounts without code, i.e. `keccak256('')`\r\n        bytes32 codehash;\r\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly { codehash := extcodehash(account) }\r\n        return (codehash != accountHash && codehash != 0x0);\r\n    }\r\n\r\n    /**\r\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\r\n     * `recipient`, forwarding all available gas and reverting on errors.\r\n     *\r\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\r\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\r\n     * imposed by `transfer`, making them unable to receive funds via\r\n     * `transfer`. {sendValue} removes this limitation.\r\n     *\r\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\r\n     *\r\n     * IMPORTANT: because control is transferred to `recipient`, care must be\r\n     * taken to not create reentrancy vulnerabilities. Consider using\r\n     * {ReentrancyGuard} or the\r\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\r\n     */\r\n    function sendValue(address payable recipient, uint256 amount) internal {\r\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\r\n        (bool success, ) = recipient.call{ value: amount }(\"\");\r\n        require(success, \"Address: unable to send value, recipient may have reverted\");\r\n    }\r\n\r\n    /**\r\n     * @dev Performs a Solidity function call using a low level `call`. A\r\n     * plain`call` is an unsafe replacement for a function call: use this\r\n     * function instead.\r\n     *\r\n     * If `target` reverts with a revert reason, it is bubbled up by this\r\n     * function (like regular Solidity function calls).\r\n     *\r\n     * Returns the raw returned data. To convert to the expected return value,\r\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `target` must be a contract.\r\n     * - calling `target` with `data` must not revert.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\r\n        return functionCall(target, data, \"Address: low-level call failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\r\n     * `errorMessage` as a fallback revert reason when `target` reverts.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\r\n        return _functionCallWithValue(target, data, 0, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but also transferring `value` wei to `target`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - the calling contract must have an ETH balance of at least `value`.\r\n     * - the called Solidity function must be `payable`.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\r\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\r\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\r\n        return _functionCallWithValue(target, data, value, errorMessage);\r\n    }\r\n\r\n    function _functionCallWithValue(address target, bytes memory data, uint256 weiValue, string memory errorMessage) private returns (bytes memory) {\r\n        require(isContract(target), \"Address: call to non-contract\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, bytes memory returndata) = target.call{ value: weiValue }(data);\r\n        if (success) {\r\n            return returndata;\r\n        } else {\r\n            // Look for revert reason and bubble it up if present\r\n            if (returndata.length > 0) {\r\n                // The easiest way to bubble the revert reason is using memory via assembly\r\n\r\n                // solhint-disable-next-line no-inline-assembly\r\n                assembly {\r\n                    let returndata_size := mload(returndata)\r\n                    revert(add(32, returndata), returndata_size)\r\n                }\r\n            } else {\r\n                revert(errorMessage);\r\n            }\r\n        }\r\n    }\r\n\r\n}\r\n\r\n/**\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n */\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes calldata) {\r\n        return msg.data;\r\n    }\r\n}\r\n\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts with custom message when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n\r\ninterface IERC20 {\r\n\r\n    function totalSupply() external view returns (uint256);\r\n    \r\n    function symbol() external view returns(string memory);\r\n    \r\n    function name() external view returns(string memory);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n    \r\n    /**\r\n     * @dev Returns the number of decimal places\r\n     */\r\n    function decimals() external view returns (uint8);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\ncontract Ownable {\r\n\r\n    address private owner;\r\n    \r\n    // event for EVM logging\r\n    event OwnerSet(address indexed oldOwner, address indexed newOwner);\r\n    \r\n    // modifier to check if caller is owner\r\n    modifier onlyOwner() {\r\n        // If the first argument of 'require' evaluates to 'false', execution terminates and all\r\n        // changes to the state and to Ether balances are reverted.\r\n        // This used to consume all gas in old EVM versions, but not anymore.\r\n        // It is often a good idea to use 'require' to check if functions are called correctly.\r\n        // As a second argument, you can also provide an explanation about what went wrong.\r\n        require(msg.sender == owner, \"Caller is not owner\");\r\n        _;\r\n    }\r\n    \r\n    /**\r\n     * @dev Set contract deployer as owner\r\n     */\r\n    constructor() {\r\n        owner = msg.sender; // 'msg.sender' is sender of current call, contract deployer for a constructor\r\n        emit OwnerSet(address(0), owner);\r\n    }\r\n\r\n    /**\r\n     * @dev Change owner\r\n     * @param newOwner address of new owner\r\n     */\r\n    function changeOwner(address newOwner) public onlyOwner {\r\n        emit OwnerSet(owner, newOwner);\r\n        owner = newOwner;\r\n    }\r\n\r\n    /**\r\n     * @dev Return owner address \r\n     * @return address of owner\r\n     */\r\n    function getOwner() external view returns (address) {\r\n        return owner;\r\n    }\r\n}\r\n\r\ncontract IECWolves is Context, ERC165, IERC721, IERC721Metadata, Ownable {\r\n\r\n    using Address for address;\r\n    using SafeMath for uint256;\r\n\r\n    // Token name\r\n    string private constant _name = \"IEC Wolves\";\r\n\r\n    // Token symbol\r\n    string private constant _symbol = \"IEC WOLVES\";\r\n\r\n    // total number of NFTs Minted\r\n    uint256 public _totalSupply;\r\n\r\n    // max supply cap\r\n    uint256 public MAX_SUPPLY = 10_000;\r\n\r\n    // Mapping from token ID to owner address\r\n    mapping(uint256 => address) private _owners;\r\n\r\n    // Mapping owner address to token count\r\n    mapping(address => uint256) private _balances;\r\n\r\n    // Mapping from token ID to approved address\r\n    mapping(uint256 => address) private _tokenApprovals;\r\n\r\n    // Mapping from owner to operator approvals\r\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\r\n\r\n    // Mapping from tokenID to excluded rewards\r\n    mapping(uint256 => uint256) private totalExcluded;\r\n\r\n    // total dividends percentage denominator\r\n    uint256 private constant percentageDenom = 10000;\r\n\r\n    // total rewards received\r\n    uint256 public totalRewards;\r\n\r\n    // precision factor\r\n    uint256 private PRECISION = 10**18;\r\n\r\n    /**\r\n        Mapping From tokenID to Rank\r\n        Rank 0 = Bronze\r\n        Rank 1 = Silver\r\n        Rank 2 = Gold\r\n        Rank 3 = Executive\r\n        Rank 4 = VIP\r\n     */\r\n    mapping ( uint256 => uint256 ) public getRank;\r\n\r\n    // Ranks\r\n    struct Rank {\r\n        uint256 total;\r\n        uint256 max;\r\n        uint256 cost;\r\n        uint256 dividends;\r\n        uint256 dividendPercentage;\r\n    }\r\n    mapping ( uint256 => Rank ) public ranks;\r\n\r\n    // Max rank\r\n    uint256 public constant MAX_RANK = 4;\r\n\r\n    // Payment Recipient\r\n    address payable public paymentReceiver;\r\n\r\n    // max holdings per wallet post mint\r\n    uint256 private constant MAX_HOLDINGS = 25;\r\n\r\n    // Merkle Proof Root For White list\r\n    bytes32 public merkleRoot;\r\n\r\n    // cost for minting NFT\r\n    uint256 public cost = 10**18;\r\n\r\n    // base URI\r\n    string private baseURI = \"https://opensea.mypinata.cloud/ipfs/Qma54XdskCs7yKRJPwZeAeJsRfC1eKHTkejTE9WFYBGjkr\";\r\n    string private ending = \"\";\r\n\r\n    // Reward Token\r\n    IERC20 public token;\r\n\r\n    // Enable Trading\r\n    bool public tradingEnabled = false;\r\n    bool public massRankUpgradeEnabled = true;\r\n    bool public whitelistEnabled = true;\r\n\r\n    constructor(address payable paymentReceiver_){\r\n        ranks[0] = Rank({\r\n            total: 0,\r\n            max: 10000,\r\n            cost: 0,\r\n            dividends: 0,\r\n            dividendPercentage: 1250\r\n        });\r\n        ranks[1] = Rank({\r\n            total: 0,\r\n            max: 3000,\r\n            cost: 10**17,\r\n            dividends: 0,\r\n            dividendPercentage: 1875\r\n        });\r\n        ranks[2] = Rank({\r\n            total: 0,\r\n            max: 1500,\r\n            cost: 2 * 10**17,\r\n            dividends: 0,\r\n            dividendPercentage: 1875\r\n        });\r\n        ranks[3] = Rank({\r\n            total: 0,\r\n            max: 1000,\r\n            cost: 4 * 10**17,\r\n            dividends: 0,\r\n            dividendPercentage: 2500\r\n        });\r\n        ranks[4] = Rank({\r\n            total: 0,\r\n            max: 500,\r\n            cost: 8 * 10**17,\r\n            dividends: 0,\r\n            dividendPercentage: 2500\r\n        });\r\n\r\n        paymentReceiver = paymentReceiver_;\r\n    }\r\n\r\n\r\n    ////////////////////////////////////////////////\r\n    ///////////   RESTRICTED FUNCTIONS   ///////////\r\n    ////////////////////////////////////////////////\r\n\r\n    function massUpgrade(uint256[] calldata tokenIds, uint256[] calldata newRanks) external onlyOwner {\r\n        require(\r\n            massRankUpgradeEnabled,\r\n            'D'\r\n        );\r\n        \r\n        uint length = tokenIds.length;\r\n        require(length == newRanks.length, 'M');\r\n\r\n        for (uint i = 0; i < length;) {\r\n            require(\r\n                getRank[tokenIds[i]] == 0 && newRanks[i] > 0,\r\n                'F'\r\n            );\r\n            getRank[tokenIds[i]] = newRanks[i];\r\n            ranks[newRanks[i]].total++;\r\n            ranks[0].total--;\r\n            totalExcluded[tokenIds[i]] = getCumulativeDividends(tokenIds[i]);\r\n            unchecked { ++i; }\r\n        }\r\n    }\r\n\r\n    function setRewardToken(address token_) external onlyOwner {\r\n        token = IERC20(token_);\r\n    }\r\n\r\n    function disableMassRankUpgrades() external onlyOwner {\r\n        massRankUpgradeEnabled = false;\r\n    }\r\n\r\n    function enableTrading() external onlyOwner {\r\n        tradingEnabled = true;\r\n    }\r\n\r\n    function disableTrading() external onlyOwner {\r\n        tradingEnabled = false;\r\n    }\r\n\r\n    function disableWhitelist() external onlyOwner {\r\n        whitelistEnabled = false;\r\n    }\r\n\r\n    function withdraw() external onlyOwner {\r\n        (bool s,) = payable(paymentReceiver).call{value: address(this).balance}(\"\");\r\n        require(s);\r\n    }\r\n\r\n    function withdrawToken(address token_) external onlyOwner {\r\n        require(token_ != address(token), 'Cannot withdraw IEC Tokens');\r\n        IERC20(token_).transfer(msg.sender, IERC20(token_).balanceOf(address(this)));\r\n    }\r\n\r\n    function setCost(uint256 newCost) external onlyOwner {\r\n        cost = newCost;\r\n    }\r\n\r\n    function setBaseURI(string calldata newURI) external onlyOwner {\r\n        baseURI = newURI;\r\n    }\r\n\r\n    function setURIExtention(string calldata newExtention) external onlyOwner {\r\n        ending = newExtention;\r\n    }\r\n\r\n    function setPaymentReceiver(address payable newReceiver) external onlyOwner {\r\n        paymentReceiver = newReceiver;\r\n    }\r\n\r\n    function setUpgradeCost(uint256 rank, uint256 newCost) external onlyOwner {\r\n        require(\r\n            rank < MAX_RANK,\r\n            'Max rank'\r\n        );\r\n        ranks[rank].cost = newCost;\r\n    }\r\n\r\n    function setRewardDistribution(\r\n        uint bronzeP,\r\n        uint silverP,\r\n        uint goldP,\r\n        uint execP,\r\n        uint vipP\r\n    ) external onlyOwner {\r\n        require(\r\n            bronzeP + silverP + goldP + execP + vipP == percentageDenom,\r\n            'Invalid Percentages'\r\n        );\r\n        ranks[0].dividendPercentage = bronzeP;\r\n        ranks[1].dividendPercentage = silverP;\r\n        ranks[2].dividendPercentage = goldP;\r\n        ranks[3].dividendPercentage = execP;\r\n        ranks[4].dividendPercentage = vipP;\r\n    }\r\n\r\n    function setMerkleRoot(bytes32 root) external onlyOwner {\r\n        merkleRoot = root;\r\n    }\r\n\r\n    function capCollectionAtSupply() external onlyOwner {\r\n        MAX_SUPPLY = _totalSupply;\r\n    }\r\n\r\n    ////////////////////////////////////////////////\r\n    ///////////     PUBLIC FUNCTIONS     ///////////\r\n    ////////////////////////////////////////////////\r\n\r\n\r\n    function upgrade(uint256 tokenId, uint256 newRank) external payable {\r\n        require(\r\n            !massRankUpgradeEnabled,\r\n            'Mass Rank Upgrades Are Still Enabled'\r\n        );\r\n        require(\r\n            _isApprovedOrOwner(_msgSender(), tokenId), \r\n            \"Caller Not Owner Nor Approved\"\r\n        );\r\n        require(\r\n            newRank <= MAX_RANK,\r\n            'Max Rank Exceeded'\r\n        );\r\n        // current token rank\r\n        uint currentRank = getRank[tokenId];\r\n        require(\r\n            currentRank < newRank,\r\n            'Cannot Rank Backwards'\r\n        );\r\n        require(\r\n            ranks[newRank].total < ranks[newRank].max,\r\n            'Max NFTs In Rank'\r\n        );\r\n\r\n        // calculate cost to upgrade\r\n        uint costToUpgrade = 0;\r\n        for (uint i = currentRank; i < newRank; i++) {\r\n            costToUpgrade += ranks[i + 1].cost;\r\n        }\r\n        require(\r\n            msg.value >= costToUpgrade,\r\n            'Insufficient Value Sent'\r\n        );\r\n\r\n        // claim pending rewards for token ID\r\n        _claimRewards(_msgSender(), tokenId);\r\n\r\n        // decrement old rank total\r\n        ranks[currentRank].total--;\r\n\r\n        // increment new rank total\r\n        ranks[newRank].total++;\r\n\r\n        // increment tokenId Rank\r\n        getRank[tokenId] = newRank;\r\n\r\n        // reset total excluded for new rank\r\n        totalExcluded[tokenId] = getCumulativeDividends(tokenId);\r\n    }\r\n\r\n    /** \r\n     * Mints `numberOfMints` NFTs To Caller\r\n     */\r\n    function mint(uint256 numberOfMints) external payable {\r\n        require(\r\n            tradingEnabled,\r\n            'Trading Not Enabled'\r\n        );\r\n        require(\r\n            !whitelistEnabled,\r\n            'White list is enabled'\r\n        );\r\n\r\n        require(numberOfMints > 0, 'Invalid Input');\r\n        require(cost * numberOfMints <= msg.value, 'Incorrect Value Sent');\r\n\r\n        for (uint i = 0; i < numberOfMints; i++) {\r\n            _safeMint(msg.sender, _totalSupply);\r\n        }\r\n\r\n        require(\r\n            _balances[msg.sender] <= MAX_HOLDINGS,\r\n            'Max Holdings Exceeded'\r\n        );\r\n    }\r\n\r\n    /** \r\n     * Mints `numberOfMints` NFTs To Caller if Caller is whitelisted\r\n     */\r\n    function whitelistMint(uint256 numberOfMints, bytes32[] calldata proof) external payable {\r\n        require(\r\n            tradingEnabled,\r\n            'Trading Not Enabled'\r\n        );\r\n        require(\r\n            whitelistEnabled,\r\n            'White list is disabled'\r\n        );\r\n        require(\r\n            MerkleProof.verify(\r\n                proof,\r\n                merkleRoot,\r\n                toBytes32(_msgSender())\r\n            ) == true,\r\n            \"User Is Not Whitelisted\"\r\n        );\r\n\r\n        require(numberOfMints > 0, 'Invalid Input');\r\n        require(cost * numberOfMints <= msg.value, 'Incorrect Value Sent');\r\n\r\n        for (uint i = 0; i < numberOfMints; i++) {\r\n            _safeMint(msg.sender, _totalSupply);\r\n        }\r\n\r\n        require(\r\n            _balances[msg.sender] <= MAX_HOLDINGS,\r\n            'Max Holdings Exceeded'\r\n        );\r\n        \r\n    }\r\n\r\n    function batchClaim(uint256[] calldata tokenIds) external {\r\n        \r\n        // define length prior to save gas\r\n        uint length = tokenIds.length;\r\n        require(\r\n            length > 0,\r\n            'Zero Length'\r\n        );\r\n\r\n        // save gas by declaring early\r\n        uint totalPending = 0;\r\n        uint currentID = 0;\r\n        address sender = _msgSender();\r\n\r\n        // loop through IDs, accruing pending rewards and resetting pending rewards\r\n        for (uint i = 0; i < length;) {\r\n            // current ID in list\r\n            currentID = tokenIds[i];\r\n            // require ID is owned by sender\r\n            require(_isApprovedOrOwner(sender, currentID), \"caller not owner nor approved\");\r\n            // add value to total pending\r\n            totalPending += pendingRewards(currentID);\r\n            // reset total excluded - resetting rewards\r\n            totalExcluded[currentID] = getCumulativeDividends(currentID);\r\n            // increment loop\r\n            unchecked { ++i; }\r\n        }\r\n\r\n        // total available balance\r\n        uint bal = token.balanceOf(address(this));\r\n\r\n        // avoid round off error\r\n        if (totalPending > bal) {\r\n            totalPending = bal;\r\n        }\r\n\r\n        // return if no rewards\r\n        if (totalPending == 0) {\r\n            return;\r\n        }\r\n\r\n        // transfer reward to user\r\n        require(\r\n            token.transfer(sender, totalPending),\r\n            'Failure On Token Transfer'\r\n        );\r\n    }\r\n\r\n    function claimRewards(uint256 tokenId) external {\r\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"caller not owner nor approved\");\r\n        _claimRewards(_owners[tokenId], tokenId);\r\n    }\r\n\r\n    function giveRewards(uint amount) external {\r\n        if (massRankUpgradeEnabled) {\r\n            return;\r\n        }\r\n\r\n        // transfer in rewards\r\n        uint before = token.balanceOf(address(this));\r\n        require(\r\n            token.transferFrom(\r\n                msg.sender,\r\n                address(this),\r\n                amount\r\n            ),\r\n            'Failure On Token Transfer'\r\n        );\r\n        uint After = token.balanceOf(address(this));\r\n        // ensure tokens were received\r\n        require(\r\n            After > before,\r\n            'Zero Received'\r\n        );\r\n        uint received = After - before;\r\n\r\n        // increment total rewards\r\n        totalRewards += received;\r\n\r\n        // fetch distributions\r\n        (uint bp, uint sp, uint gp, uint ep, uint vp) = _fetchDistributionPercentages();\r\n\r\n        // roll over if zero\r\n        if (ranks[4].total == 0) {\r\n            bp += vp / 4;\r\n            sp += vp / 4;\r\n            gp += vp / 4;\r\n            ep += vp / 4;\r\n            vp = 0;\r\n        }\r\n        if (ranks[3].total == 0) {\r\n            bp += ep / 3;\r\n            sp += ep / 3;\r\n            gp += ep / 3;\r\n            ep = 0;\r\n        }\r\n        if (ranks[2].total == 0) {\r\n            bp += gp / 2;\r\n            sp += gp / 2;\r\n            gp = 0;\r\n        }\r\n        if (ranks[1].total == 0) {\r\n            bp += sp;\r\n            sp = 0;\r\n        }\r\n\r\n        // split up amounts for each sector\r\n        uint forBronze = received.mul(bp).div(percentageDenom);\r\n        uint forSilver = received.mul(sp).div(percentageDenom);\r\n        uint forGold = received.mul(gp).div(percentageDenom);\r\n        uint forExec = received.mul(ep).div(percentageDenom);\r\n        uint forVIP = received.mul(vp).div(percentageDenom);\r\n\r\n        // Increment Dividend Rewards\r\n        if (ranks[4].total > 0) {\r\n            ranks[4].dividends += forVIP.mul(PRECISION).div(ranks[4].total);\r\n        }\r\n        if (ranks[3].total > 0) {\r\n            ranks[3].dividends += forExec.mul(PRECISION).div(ranks[3].total);\r\n        }\r\n        if (ranks[2].total > 0) {\r\n            ranks[2].dividends += forGold.mul(PRECISION).div(ranks[2].total);\r\n        }\r\n        if (ranks[1].total > 0) {\r\n            ranks[1].dividends += forSilver.mul(PRECISION).div(ranks[1].total);\r\n        }\r\n        if (ranks[0].total > 0) {\r\n            ranks[0].dividends += forBronze.mul(PRECISION).div(ranks[0].total);\r\n        }\r\n        \r\n    }\r\n\r\n    function _fetchDistributionPercentages() internal view returns (uint, uint, uint, uint, uint) {\r\n        return (\r\n            ranks[0].dividendPercentage, \r\n            ranks[1].dividendPercentage, \r\n            ranks[2].dividendPercentage,\r\n            ranks[3].dividendPercentage,\r\n            ranks[4].dividendPercentage\r\n        );\r\n    }\r\n\r\n    function toBytes32(address addr) pure internal returns (bytes32) {\r\n        return bytes32(uint256(uint160(addr)));\r\n    }\r\n\r\n    receive() external payable {}\r\n\r\n    /**\r\n     * @dev See {IERC721-approve}.\r\n     */\r\n    function approve(address to, uint256 tokenId) public override {\r\n        address wpowner = ownerOf(tokenId);\r\n        require(to != wpowner, \"ERC721: approval to current owner\");\r\n\r\n        require(\r\n            _msgSender() == wpowner || isApprovedForAll(wpowner, _msgSender()),\r\n            \"ERC721: not approved or owner\"\r\n        );\r\n\r\n        _approve(to, tokenId);\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC721-setApprovalForAll}.\r\n     */\r\n    function setApprovalForAll(address _operator, bool approved) public override {\r\n        _setApprovalForAll(_msgSender(), _operator, approved);\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC721-transferFrom}.\r\n     */\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId\r\n    ) public override {\r\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"caller not owner nor approved\");\r\n        _transfer(from, to, tokenId);\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC721-safeTransferFrom}.\r\n     */\r\n    function safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId\r\n    ) public override {\r\n        safeTransferFrom(from, to, tokenId, \"\");\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC721-safeTransferFrom}.\r\n     */\r\n    function safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId,\r\n        bytes memory _data\r\n    ) public override {\r\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"caller not owner nor approved\");\r\n        _safeTransfer(from, to, tokenId, _data);\r\n    }\r\n\r\n\r\n    ////////////////////////////////////////////////\r\n    ///////////     READ FUNCTIONS       ///////////\r\n    ////////////////////////////////////////////////\r\n\r\n    function totalSupply() external view returns (uint256) {\r\n        return _totalSupply;\r\n    }\r\n\r\n    function getIDsByOwner(address owner) external view returns (uint256[] memory) {\r\n        uint256[] memory ids = new uint256[](balanceOf(owner));\r\n        if (owner == address(0)) { return ids; }\r\n        if (balanceOf(owner) == 0) { return ids; }\r\n        uint256 count = 0;\r\n        for (uint i = 0; i < _totalSupply;) {\r\n            if (_owners[i] == owner) {\r\n                ids[count] = i;\r\n                count++;\r\n            }\r\n            unchecked { ++i; }\r\n        }\r\n        return ids;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC165-supportsInterface}.\r\n     */\r\n    function supportsInterface(bytes4 interfaceId) public view override(ERC165, IERC165) returns (bool) {\r\n        return\r\n            interfaceId == type(IERC721).interfaceId ||\r\n            interfaceId == type(IERC721Metadata).interfaceId ||\r\n            super.supportsInterface(interfaceId);\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC721-balanceOf}.\r\n     */\r\n    function balanceOf(address wpowner) public view override returns (uint256) {\r\n        require(wpowner != address(0), \"query for the zero address\");\r\n        return _balances[wpowner];\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC721-ownerOf}.\r\n     */\r\n    function ownerOf(uint256 tokenId) public view override returns (address) {\r\n        address wpowner = _owners[tokenId];\r\n        require(wpowner != address(0), \"query for nonexistent token\");\r\n        return wpowner;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC721Metadata-name}.\r\n     */\r\n    function name() public pure override returns (string memory) {\r\n        return _name;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC721Metadata-symbol}.\r\n     */\r\n    function symbol() public pure override returns (string memory) {\r\n        return _symbol;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC721Metadata-tokenURI}.\r\n     */\r\n    function tokenURI(uint256 tokenId) public view override returns (string memory) {\r\n        require(_exists(tokenId), \"nonexistent token\");\r\n\r\n        string memory fHalf = string.concat(baseURI, uint2str(getRank[tokenId]));\r\n        string memory sHalf = string.concat(fHalf, '-');\r\n        string memory tHalf = string.concat(sHalf, uint2str(tokenId));\r\n        return string.concat(tHalf, ending);\r\n    }\r\n\r\n    /**\r\n        Converts A Uint Into a String\r\n    */\r\n    function uint2str(uint _i) internal pure returns (string memory _uintAsString) {\r\n        if (_i == 0) {\r\n            return \"0\";\r\n        }\r\n        uint j = _i;\r\n        uint len;\r\n        while (j != 0) {\r\n            len++;\r\n            j /= 10;\r\n        }\r\n        bytes memory bstr = new bytes(len);\r\n        uint k = len;\r\n        while (_i != 0) {\r\n            k = k-1;\r\n            uint8 temp = (48 + uint8(_i - _i / 10 * 10));\r\n            bytes1 b1 = bytes1(temp);\r\n            bstr[k] = b1;\r\n            _i /= 10;\r\n        }\r\n        return string(bstr);\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC721-getApproved}.\r\n     */\r\n    function getApproved(uint256 tokenId) public view override returns (address) {\r\n        require(_exists(tokenId), \"ERC721: query for nonexistent token\");\r\n\r\n        return _tokenApprovals[tokenId];\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC721-isApprovedForAll}.\r\n     */\r\n    function isApprovedForAll(address wpowner, address _operator) public view override returns (bool) {\r\n        return _operatorApprovals[wpowner][_operator];\r\n    }\r\n\r\n    /**\r\n        Pending IEC Rewards For `tokenId`\r\n     */\r\n    function pendingRewards(uint256 tokenId) public view returns (uint256) {\r\n\r\n        uint256 tokenIDDividends = getCumulativeDividends(tokenId);\r\n        uint256 tokenIDExcluded = totalExcluded[tokenId];\r\n\r\n        if(tokenIDDividends <= tokenIDExcluded){ return 0; }\r\n\r\n        return tokenIDDividends - tokenIDExcluded;\r\n    }\r\n\r\n    /**\r\n        Cumulative Dividends For A Number Of Tokens\r\n     */\r\n    function getCumulativeDividends(uint256 tokenId) internal view returns (uint256) {\r\n        return ranks[getRank[tokenId]].dividends.div(PRECISION);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns whether `tokenId` exists.\r\n     *\r\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\r\n     *\r\n     * Tokens start existing when they are minted\r\n     */\r\n    function _exists(uint256 tokenId) internal view returns (bool) {\r\n        return _owners[tokenId] != address(0);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns whether `spender` is allowed to manage `tokenId`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `tokenId` must exist.\r\n     */\r\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view returns (bool) {\r\n        require(_exists(tokenId), \"ERC721: nonexistent token\");\r\n        address wpowner = ownerOf(tokenId);\r\n        return (spender == wpowner || getApproved(tokenId) == spender || isApprovedForAll(wpowner, spender));\r\n    }\r\n\r\n    ////////////////////////////////////////////////\r\n    ///////////    INTERNAL FUNCTIONS    ///////////\r\n    ////////////////////////////////////////////////\r\n\r\n\r\n    /**\r\n     * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is\r\n     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\r\n     */\r\n    function _safeMint(\r\n        address to,\r\n        uint256 tokenId\r\n    ) internal {\r\n        _mint(to, tokenId);\r\n        require(\r\n            _checkOnERC721Received(address(0), to, tokenId, \"\"),\r\n            \"ERC721: transfer to non ERC721Receiver implementer\"\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @dev Mints `tokenId` and transfers it to `to`.\r\n     *\r\n     * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `tokenId` must not exist.\r\n     * - `to` cannot be the zero address.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function _mint(address to, uint256 tokenId) internal {\r\n        require(!_exists(tokenId), \"ERC721: token already minted\");\r\n        require(_totalSupply < MAX_SUPPLY, 'All NFTs Have Been Minted');\r\n\r\n        _balances[to] += 1;\r\n        _owners[tokenId] = to;\r\n        _totalSupply += 1;\r\n        ranks[0].total++;\r\n        totalExcluded[tokenId] = getCumulativeDividends(tokenId);\r\n\r\n        emit Transfer(address(0), to, tokenId);\r\n    }\r\n\r\n    /**\r\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\r\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\r\n     *\r\n     * `_data` is additional data, it has no specified format and it is sent in call to `to`.\r\n     *\r\n     * This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.\r\n     * implement alternative mechanisms to perform token transfer, such as signature-based.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `from` cannot be the zero address.\r\n     * - `to` cannot be the zero address.\r\n     * - `tokenId` token must exist and be owned by `from`.\r\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function _safeTransfer(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId,\r\n        bytes memory _data\r\n    ) internal {\r\n        _transfer(from, to, tokenId);\r\n        require(_checkOnERC721Received(from, to, tokenId, _data), \"ERC721: non ERC721Receiver implementer\");\r\n    }\r\n\r\n\r\n    /**\r\n     * @dev Transfers `tokenId` from `from` to `to`.\r\n     *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `to` cannot be the zero address.\r\n     * - `tokenId` token must be owned by `from`.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function _transfer(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId\r\n    ) internal {\r\n        require(ownerOf(tokenId) == from, \"Incorrect owner\");\r\n        require(to != address(0), \"zero address\");\r\n        require(balanceOf(from) > 0, 'Zero Balance');\r\n\r\n        // Clear approvals from the previous owner\r\n        _approve(address(0), tokenId);\r\n\r\n        // claim rewards for tokenId\r\n        _claimRewards(from, tokenId);\r\n\r\n        // Allocate balances\r\n        _balances[from] -= 1;\r\n        _balances[to] += 1;\r\n        _owners[tokenId] = to;\r\n\r\n        // emit transfer\r\n        emit Transfer(from, to, tokenId);\r\n    }\r\n\r\n    /**\r\n        Claims IEC Reward For User\r\n     */\r\n    function _claimRewards(address owner, uint256 tokenId) internal {\r\n\r\n        // fetch pending rewards\r\n        uint pending = pendingRewards(tokenId);\r\n        uint bal = token.balanceOf(address(this));\r\n\r\n        // avoid round off error\r\n        if (pending > bal) {\r\n            pending = bal;\r\n        }\r\n\r\n        // return if no rewards\r\n        if (pending == 0) {\r\n            return;\r\n        }\r\n        \r\n        // reset total rewards\r\n        totalExcluded[tokenId] = getCumulativeDividends(tokenId);\r\n\r\n        // transfer reward to user\r\n        require(\r\n            token.transfer(owner, pending),\r\n            'Failure On Token Transfer'\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @dev Approve `to` to operate on `tokenId`\r\n     *\r\n     * Emits a {Approval} event.\r\n     */\r\n    function _approve(address to, uint256 tokenId) internal {\r\n        _tokenApprovals[tokenId] = to;\r\n        emit Approval(ownerOf(tokenId), to, tokenId);\r\n    }\r\n\r\n    /**\r\n     * @dev Approve `operator` to operate on all of `owner` tokens\r\n     *\r\n     * Emits a {ApprovalForAll} event.\r\n     */\r\n    function _setApprovalForAll(\r\n        address wpowner,\r\n        address _operator,\r\n        bool approved\r\n    ) internal {\r\n        require(wpowner != _operator, \"ERC721: approve to caller\");\r\n        _operatorApprovals[wpowner][_operator] = approved;\r\n        emit ApprovalForAll(wpowner, _operator, approved);\r\n    }\r\n\r\n    function onReceivedRetval() public pure returns (bytes4) {\r\n        return IERC721Receiver.onERC721Received.selector;\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\r\n     * The call is not executed if the target address is not a contract.\r\n     *\r\n     * @param from address representing the previous owner of the given token ID\r\n     * @param to target address that will receive the tokens\r\n     * @param tokenId uint256 ID of the token to be transferred\r\n     * @param _data bytes optional data to send along with the call\r\n     * @return bool whether the call correctly returned the expected magic value\r\n     */\r\n    function _checkOnERC721Received(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId,\r\n        bytes memory _data\r\n    ) private returns (bool) {\r\n        if (to.isContract()) {\r\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, _data) returns (bytes4 retval) {\r\n                return retval == IERC721Receiver.onERC721Received.selector;\r\n            } catch (bytes memory reason) {\r\n                if (reason.length == 0) {\r\n                    revert(\"ERC721: non ERC721Receiver implementer\");\r\n                } else {\r\n                    assembly {\r\n                        revert(add(32, reason), mload(reason))\r\n                    }\r\n                }\r\n            }\r\n        } else {\r\n            return true;\r\n        }\r\n    }\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"paymentReceiver_\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"approved\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"oldOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnerSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"MAX_RANK\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_SUPPLY\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"wpowner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"tokenIds\",\"type\":\"uint256[]\"}],\"name\":\"batchClaim\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"capCollectionAtSupply\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"changeOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"claimRewards\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"cost\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"disableMassRankUpgrades\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"disableTrading\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"disableWhitelist\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"enableTrading\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getApproved\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"getIDsByOwner\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"getRank\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"giveRewards\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"wpowner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_operator\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"massRankUpgradeEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"tokenIds\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"newRanks\",\"type\":\"uint256[]\"}],\"name\":\"massUpgrade\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"merkleRoot\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"numberOfMints\",\"type\":\"uint256\"}],\"name\":\"mint\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"onReceivedRetval\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paymentReceiver\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"pendingRewards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"ranks\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"total\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"max\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"cost\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"dividends\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"dividendPercentage\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_operator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"newURI\",\"type\":\"string\"}],\"name\":\"setBaseURI\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newCost\",\"type\":\"uint256\"}],\"name\":\"setCost\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"root\",\"type\":\"bytes32\"}],\"name\":\"setMerkleRoot\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"newReceiver\",\"type\":\"address\"}],\"name\":\"setPaymentReceiver\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"bronzeP\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"silverP\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"goldP\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"execP\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"vipP\",\"type\":\"uint256\"}],\"name\":\"setRewardDistribution\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token_\",\"type\":\"address\"}],\"name\":\"setRewardToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"newExtention\",\"type\":\"string\"}],\"name\":\"setURIExtention\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"rank\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"newCost\",\"type\":\"uint256\"}],\"name\":\"setUpgradeCost\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"tokenURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalRewards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tradingEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"newRank\",\"type\":\"uint256\"}],\"name\":\"upgrade\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"whitelistEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"numberOfMints\",\"type\":\"uint256\"},{\"internalType\":\"bytes32[]\",\"name\":\"proof\",\"type\":\"bytes32[]\"}],\"name\":\"whitelistMint\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token_\",\"type\":\"address\"}],\"name\":\"withdrawToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]","ContractName":"IECWolves","CompilerVersion":"v0.8.14+commit.80d49f37","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000ca155171f67e7bd27f4fde729a28c0ff20b88c1f","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"ipfs://3a32a27c7ae5f2a6e4ab78ad9f6efbb9a8362240fae7522684e1e7c446e45bde"}]}