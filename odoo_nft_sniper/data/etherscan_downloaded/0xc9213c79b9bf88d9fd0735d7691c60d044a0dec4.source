{"status":"1","message":"OK","result":[{"SourceCode":"// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.12;\r\n\r\ninterface callableNFT {\r\n    function transferFrom(address from, address to, uint256 tokenID) external;\r\n    function safeTransferFrom(address from, address to, uint256 tokenID) external;\r\n    function ownerOf(uint256 tokenId) external view returns (address);\r\n}\r\n\r\ncontract BMCMissionToMars {\r\n\r\n    event OwnerUpdated(address indexed user, address indexed newOwner);\r\n\r\n    callableNFT public og;\r\n    callableNFT public ultra;\r\n    callableNFT public droid;\r\n    callableNFT public alpha;\r\n    callableNFT public beta;\r\n    callableNFT public gamma;\r\n\r\n    struct units {\r\n      uint256[] stakedOGs;\r\n      uint256[] stakedULTRAs;\r\n      uint256[] stakedDROIDs;\r\n      uint256[] stakedALPHAs;\r\n      uint256[] stakedBETAs;\r\n      uint256[] stakedGAMMAs;\r\n    }\r\n\r\n    struct tokenData {\r\n        uint64 timestamp;\r\n        address realOwner;\r\n    }\r\n\r\n    address public owner;\r\n    bool public depositPaused;\r\n    uint256 private locked = 1;\r\n    \r\n    mapping(address => units) private _staker;\r\n    mapping(address => mapping(uint256 => tokenData)) private _tokenData;\r\n\r\n    constructor(address _og, address _ultra, address _droid) {\r\n        og = callableNFT(_og);\r\n        ultra = callableNFT(_ultra);\r\n        droid = callableNFT(_droid);\r\n\r\n        owner = _msgSender();\r\n        emit OwnerUpdated(address(0), owner);\r\n        pauseDeposits(true);\r\n\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(_msgSender() == owner, \"Non Owner\");\r\n        _;\r\n    }\r\n\r\n    modifier nonReentrant() {\r\n        require(locked == 1, \"No Reentry\");\r\n        locked = 2;\r\n        _;\r\n        locked = 1;\r\n    }\r\n\r\n    function _msgSender() internal view returns (address) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function multiDeposit(address[] memory _contractAddresses, uint256 [][] memory tokenIDs) public nonReentrant {\r\n        require(!depositPaused, \"Deposits Paused\");\r\n        uint256 iterations = tokenIDs.length;\r\n        require(_contractAddresses.length == iterations && iterations > 0 && iterations < 7, \"Invalid Parameters\");\r\n\r\n        for (uint256 i; i < iterations; ) {\r\n            _deposit(_contractAddresses[i], tokenIDs[i]);\r\n\r\n            unchecked {\r\n                ++i;\r\n            }\r\n        }\r\n\r\n    }\r\n\r\n    function multiWithdraw(address[] memory _contractAddresses, uint256 [][] memory tokenIDs) public nonReentrant {\r\n        uint256 iterations = tokenIDs.length;\r\n        require(_contractAddresses.length == iterations && iterations > 0 && iterations < 7, \"Invalid Parameters\");\r\n \r\n        for (uint256 i; i < iterations; ) {\r\n            _withdraw(_contractAddresses[i], tokenIDs[i]);\r\n\r\n            unchecked {\r\n                ++i;\r\n            }\r\n        }\r\n\r\n    }\r\n\r\n    function _deposit(address _contractAddress, uint256[] memory tokenIds) internal {\r\n      require(isValidContract(_contractAddress), \"Unknown contract\");\r\n\r\n      uint256 tokens = tokenIds.length;\r\n      require(tokens > 0, \"No Tokens Passed\");\r\n\r\n      units storage currentAddress = _staker[_msgSender()];\r\n      callableNFT depositAddress = callableNFT(_contractAddress);\r\n      uint256 currentToken;\r\n\r\n      for (uint256 i; i < tokens; ) {\r\n        currentToken = tokenIds[i++];\r\n\r\n        require(depositAddress.ownerOf(currentToken) == _msgSender(), \"Not the owner\");\r\n        depositAddress.safeTransferFrom(_msgSender(), address(this), currentToken);\r\n        _tokenData[_contractAddress][currentToken].realOwner = _msgSender();\r\n        _tokenData[_contractAddress][currentToken].timestamp = uint64(block.timestamp);\r\n\r\n        if (depositAddress == og) {\r\n            currentAddress.stakedOGs.push(currentToken);\r\n            continue;\r\n        }\r\n        if (depositAddress == ultra) { \r\n            currentAddress.stakedULTRAs.push(currentToken);\r\n            continue;\r\n        }\r\n        if (depositAddress == droid) { \r\n            currentAddress.stakedDROIDs.push(currentToken);\r\n            continue;\r\n        }\r\n        if (depositAddress == alpha) { \r\n            currentAddress.stakedALPHAs.push(currentToken);\r\n            continue;\r\n        }\r\n        if (depositAddress == beta) { \r\n            currentAddress.stakedBETAs.push(currentToken);\r\n            continue;\r\n        }\r\n        if (depositAddress == gamma) { \r\n            currentAddress.stakedGAMMAs.push(currentToken);\r\n        }\r\n\r\n      }\r\n\r\n    }\r\n\r\n    function _withdraw(address _contractAddress, uint256[] memory tokenIds) internal {\r\n      require(isValidContract(_contractAddress), \"Unknown contract\");\r\n      uint256 tokens = tokenIds.length;\r\n      require(tokens > 0, \"No Tokens Passed\");\r\n\r\n      units storage currentAddress = _staker[_msgSender()];\r\n      callableNFT withdrawAddress = callableNFT(_contractAddress);\r\n      uint256 currentToken;\r\n\r\n      for (uint256 i; i < tokens; ) {\r\n        currentToken = tokenIds[i++];  \r\n        require(withdrawAddress.ownerOf(currentToken) == address(this), \"Contract Not Owner\");//Ownership is checked in _OrganizeArrayEntries\r\n        delete _tokenData[_contractAddress][currentToken];\r\n\r\n        if (withdrawAddress == og){\r\n          currentAddress.stakedOGs = _OrganizeArrayEntries(currentAddress.stakedOGs, currentToken);\r\n          currentAddress.stakedOGs.pop();\r\n          withdrawAddress.safeTransferFrom(address(this), _msgSender(), currentToken);\r\n          continue;\r\n        }\r\n        if (withdrawAddress == ultra){\r\n          currentAddress.stakedULTRAs = _OrganizeArrayEntries(currentAddress.stakedULTRAs, currentToken);\r\n          currentAddress.stakedULTRAs.pop();\r\n          withdrawAddress.safeTransferFrom(address(this), _msgSender(), currentToken);\r\n          continue;\r\n        }\r\n        if (withdrawAddress == droid){\r\n          currentAddress.stakedDROIDs = _OrganizeArrayEntries(currentAddress.stakedDROIDs, currentToken);\r\n          currentAddress.stakedDROIDs.pop();\r\n          withdrawAddress.safeTransferFrom(address(this), _msgSender(), currentToken);\r\n          continue;\r\n        }\r\n        if (withdrawAddress == alpha){\r\n          currentAddress.stakedALPHAs = _OrganizeArrayEntries(currentAddress.stakedALPHAs, currentToken);\r\n          currentAddress.stakedALPHAs.pop();\r\n          withdrawAddress.safeTransferFrom(address(this), _msgSender(), currentToken);\r\n          continue;\r\n        }\r\n        if (withdrawAddress == beta){\r\n          currentAddress.stakedBETAs = _OrganizeArrayEntries(currentAddress.stakedBETAs, currentToken);\r\n          currentAddress.stakedBETAs.pop();\r\n          withdrawAddress.safeTransferFrom(address(this), _msgSender(), currentToken);\r\n          continue;\r\n        }\r\n        if (withdrawAddress == gamma){\r\n          currentAddress.stakedGAMMAs = _OrganizeArrayEntries(currentAddress.stakedGAMMAs, currentToken);\r\n          currentAddress.stakedGAMMAs.pop();\r\n          withdrawAddress.safeTransferFrom(address(this), _msgSender(), currentToken);\r\n        }\r\n\r\n      }\r\n\r\n    }\r\n\r\n    function isValidContract(address _contract) public view returns (bool) {\r\n        if (_contract == address (0)) return false;\r\n        callableNFT _callableContract = callableNFT(_contract);\r\n        \r\n        if (_callableContract == og || \r\n            _callableContract == ultra ||\r\n            _callableContract == droid ||\r\n            _callableContract == alpha ||\r\n            _callableContract == beta ||\r\n            _callableContract == gamma) return true;\r\n\r\n        return false;\r\n    }\r\n\r\n    function _OrganizeArrayEntries(uint256[] memory _list, uint256 tokenId) internal pure returns (uint256[] memory) {\r\n      uint256 arrayIndex;\r\n      uint256 arrayLength = _list.length;\r\n      uint256 lastArrayIndex = arrayLength - 1;\r\n\r\n      unchecked {\r\n      for(uint256 i; i < arrayLength; ) {\r\n        if (_list[i++] == tokenId) {\r\n          arrayIndex = i;\r\n          break;\r\n        }\r\n      }\r\n      \r\n      }//cannot overflow because array entries only added on successful deposit of token\r\n\r\n      require(arrayIndex != 0, \"Caller Not Token Owner\");\r\n      unchecked {\r\n          arrayIndex--;\r\n      }//cannot underflow by prior logic\r\n      \r\n      if (arrayIndex != lastArrayIndex) {\r\n        _list[arrayIndex] = _list[lastArrayIndex];\r\n        _list[lastArrayIndex] = tokenId;\r\n      }\r\n\r\n      return _list;\r\n    }\r\n\r\n    function ownerOf(address _contractAddress, uint256 tokenId) public view returns (address) {\r\n      return _tokenData[_contractAddress][tokenId].realOwner;\r\n    }\r\n\r\n    function timestampOf(address _contractAddress, uint256 tokenId) public view returns (uint256) {\r\n      return _tokenData[_contractAddress][tokenId].timestamp;\r\n    }\r\n\r\n    function getStakedOGs(address _address) public view returns (uint256[] memory){\r\n      return _staker[_address].stakedOGs;\r\n    }\r\n\r\n    function getStakedULTRAs(address _address) public view returns (uint256[] memory){\r\n      return _staker[_address].stakedULTRAs;\r\n    }\r\n\r\n    function getStakedDROIDs(address _address) public view returns (uint256[] memory){\r\n      return _staker[_address].stakedDROIDs;\r\n    }\r\n\r\n    function getStakedALPHAs(address _address) public view returns (uint256[] memory){\r\n      return _staker[_address].stakedALPHAs;\r\n    }\r\n\r\n    function getStakedBETAs(address _address) public view returns (uint256[] memory){\r\n      return _staker[_address].stakedBETAs;\r\n    }\r\n\r\n    function getStakedGAMMAs(address _address) public view returns (uint256[] memory){\r\n      return _staker[_address].stakedGAMMAs;\r\n    }\r\n\r\n    function setOGContract(address _newAddress) public onlyOwner {\r\n      og = callableNFT(_newAddress);\r\n    }\r\n\r\n    function setULTRAContract(address _newAddress) public onlyOwner {\r\n      ultra = callableNFT(_newAddress);\r\n    }\r\n\r\n    function setDROIDContract(address _newAddress) public onlyOwner {\r\n      droid = callableNFT(_newAddress);\r\n    }\r\n\r\n    function setALPHAContract(address _newAddress) public onlyOwner {\r\n      alpha = callableNFT(_newAddress);\r\n    }\r\n\r\n    function setBETAContract(address _newAddress) public onlyOwner {\r\n      beta = callableNFT(_newAddress);\r\n    }\r\n\r\n    function setGAMMAContract(address _newAddress) public onlyOwner {\r\n      gamma = callableNFT(_newAddress);\r\n    }\r\n\r\n    function pauseDeposits(bool _state) public onlyOwner {\r\n      depositPaused = _state;\r\n    }\r\n\r\n    /**\r\n    * @dev Allows BMC team to emergency eject NFTs if theres an issue.\r\n    */\r\n    function emergencyWithdraw(address _contractAddress, uint256[] memory tokenIds) public onlyOwner {\r\n      pauseDeposits(true);\r\n      uint256 tokens = tokenIds.length;//save mLOADs\r\n      callableNFT withdrawAddress = callableNFT(_contractAddress);\r\n      uint256 currentToken;\r\n    \r\n      for (uint256 i; i < tokens; ) {\r\n        currentToken = tokenIds[i++];\r\n        address receiver = _tokenData[_contractAddress][currentToken].realOwner;\r\n        if (receiver != address(0) && withdrawAddress.ownerOf(currentToken) == address(this)) {\r\n          withdrawAddress.transferFrom(address(this), receiver, currentToken);\r\n          delete _tokenData[_contractAddress][currentToken];\r\n          \r\n        }\r\n\r\n      }\r\n\r\n    }\r\n\r\n    /**\r\n    * @dev Needed for safeTransferFrom interface\r\n    */\r\n    function onERC721Received(address, address, uint256, bytes calldata) external pure returns(bytes4){\r\n      return bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"));\r\n    }\r\n\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_og\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_ultra\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_droid\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnerUpdated\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"alpha\",\"outputs\":[{\"internalType\":\"contract callableNFT\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"beta\",\"outputs\":[{\"internalType\":\"contract callableNFT\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"depositPaused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"droid\",\"outputs\":[{\"internalType\":\"contract callableNFT\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_contractAddress\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"tokenIds\",\"type\":\"uint256[]\"}],\"name\":\"emergencyWithdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"gamma\",\"outputs\":[{\"internalType\":\"contract callableNFT\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"getStakedALPHAs\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"getStakedBETAs\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"getStakedDROIDs\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"getStakedGAMMAs\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"getStakedOGs\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"getStakedULTRAs\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_contract\",\"type\":\"address\"}],\"name\":\"isValidContract\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_contractAddresses\",\"type\":\"address[]\"},{\"internalType\":\"uint256[][]\",\"name\":\"tokenIDs\",\"type\":\"uint256[][]\"}],\"name\":\"multiDeposit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_contractAddresses\",\"type\":\"address[]\"},{\"internalType\":\"uint256[][]\",\"name\":\"tokenIDs\",\"type\":\"uint256[][]\"}],\"name\":\"multiWithdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"og\",\"outputs\":[{\"internalType\":\"contract callableNFT\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"onERC721Received\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_contractAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_state\",\"type\":\"bool\"}],\"name\":\"pauseDeposits\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newAddress\",\"type\":\"address\"}],\"name\":\"setALPHAContract\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newAddress\",\"type\":\"address\"}],\"name\":\"setBETAContract\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newAddress\",\"type\":\"address\"}],\"name\":\"setDROIDContract\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newAddress\",\"type\":\"address\"}],\"name\":\"setGAMMAContract\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newAddress\",\"type\":\"address\"}],\"name\":\"setOGContract\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newAddress\",\"type\":\"address\"}],\"name\":\"setULTRAContract\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_contractAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"timestampOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ultra\",\"outputs\":[{\"internalType\":\"contract callableNFT\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"BMCMissionToMars","CompilerVersion":"v0.8.15+commit.e14f2714","OptimizationUsed":"1","Runs":"2000","ConstructorArguments":"00000000000000000000000047bd71b482b27ebdb57af6e372cab46c7280bf440000000000000000000000000c6822ca73de6871f27acd9ca05a05b99294b805000000000000000000000000aaab5040164ead4427cd43366610740692897c40","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"ipfs://6714a6fd108f4bb0b5764d60dc3616219101f309a10e9a6cefaa05e9b659ac2b"}]}