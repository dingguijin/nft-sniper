{"status":"1","message":"OK","result":[{"SourceCode":"// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0 ;\r\n\r\ninterface IERC20 {\r\n    function transfer(address _to, uint256 _value) external returns (bool);\r\n    function transferFrom(address _from, address _to, uint256 _value) external returns (bool);\r\n    function lucaToFragment(uint256 value) external view returns (uint256);\r\n    function fragmentToLuca(uint256 value) external view returns (uint256);\r\n}\r\n\r\ninterface IPledge {\r\n    function addNodeAddr(address[] calldata _nodeAddrs) external;\r\n    function deleteNodeAddr(address[] calldata _nodeAddrs) external;\r\n    function updateExecutor(address _admin) external;\r\n    function stakeLuca(address _nodeAddr, uint256 _amount) external;\r\n    function stakeWLuca(address _nodeAddr, uint256 _amount, address _sender) external returns(bool);\r\n    function cancleStakeLuca(uint256[] calldata _indexs) external;\r\n    function cancleStakeWLuca(address _sender) external returns(bool);\r\n    function nodeRank(uint256 start, uint256 end) external;\r\n\r\n    event StakeLuca(uint256 indexed _stakeNum, address _userAddr, address _nodeAddr, uint256 _amount, uint256 _time);\r\n    event EndStakeLuca(uint256 indexed _stakeNum, address indexed _userAddr, address _nodeAddr, uint256 _time);\r\n    event StakeWLuca(uint256 indexed _stakeNum, address indexed _userAddr, address _nodeAddr, address _linkAddr, uint256 _amount, uint256 _time);\r\n    event EndStakeWLuca(uint256 indexed _stakeNum, address indexed _userAddr, address _nodeAddr, address _linkAddr, uint256 _time);\r\n}\r\n\r\n\r\ninterface ILucaFactory {\r\n    function isLink(address _link) external view returns(bool);\r\n}\r\n\r\nabstract contract Initializable {\r\n    /**\r\n     * @dev Indicates that the contract has been initialized.\r\n     */\r\n    bool private _initialized;\r\n\r\n    /**\r\n     * @dev Indicates that the contract is in the process of being initialized.\r\n     */\r\n    bool private _initializing;\r\n\r\n    /**\r\n     * @dev Modifier to protect an initializer function from being invoked twice.\r\n     */\r\n    modifier initializer() {\r\n        require(_initializing || !_initialized, \"Initializable: contract is already initialized\");\r\n\r\n        bool isTopLevelCall = !_initializing;\r\n        if (isTopLevelCall) {\r\n            _initializing = true;\r\n            _initialized = true;\r\n        }\r\n\r\n        _;\r\n\r\n        if (isTopLevelCall) {\r\n            _initializing = false;\r\n        }\r\n    }\r\n}\r\n\r\ncontract Ownable is Initializable{\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    function __Ownable_init_unchained() internal initializer {\r\n        address msgSender = msg.sender;\r\n        _owner = msgSender;\r\n        emit OwnershipTransferred(address(0), msgSender);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(isOwner(), \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the caller is the current owner.\r\n     */\r\n    function isOwner() public view returns (bool) {\r\n        return msg.sender == _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Leaves the contract without owner. It will not be possible to call\r\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\r\n     *\r\n     * NOTE: Renouncing ownership will leave the contract without an owner,\r\n     * thereby removing any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() public onlyOwner {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     */\r\n    function _transferOwnership(address newOwner) internal {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n}\r\n\r\ncontract  Pledge is Initializable,Ownable,IPledge{\r\n    using SafeMath for uint256;\r\n    address public executor;\r\n    IERC20 public  lucaToken;\r\n    ILucaFactory public lucaFactory;\r\n    uint256 public exchangeRate;\r\n    uint256 public  nodeNum;                           \r\n    mapping(address => uint256) nodeAddrIndex;  \r\n    mapping(uint256 => address) public nodeIndexAddr;  \r\n    mapping(address => uint256) nodeFragmentAmount;     \r\n    mapping(address => uint256) public nodeWLucaAmount;     \r\n    mapping(address => bool) public nodeAddrSta;\r\n    uint256 public  stakeLucaNum;         \r\n    mapping(uint256 => StakeLucaMsg) public stakeLucaMsg;  \r\n    mapping(address => uint256) public userStakeLucaNum;  \r\n    mapping(address => mapping(uint256 => uint256)) public userStakeLucaIndex;\r\n    uint256 public  stakeWLucaNum;          \r\n    mapping(uint256 => StakeWLucaMsg) public stakeWLucaMsg;  \r\n    mapping(address => uint256) public userStakeWLucaNum;  \r\n    mapping(address => mapping(uint256 => uint256)) public userStakeWLucaIndex; \r\n    mapping(address => mapping(address => uint256)) public userLinkIndex; \r\n    event UpdateExecutor(address _executor);\r\n    event AddNodeAddr(address _nodeAddr);\r\n    event DeleteNodeAddr(address _nodeAddr);\r\n\r\n    struct StakeNodeMsg {\r\n        uint256 fragment;  \r\n        uint256 wLucaAmount;\r\n    }\r\n\r\n    struct StakeLucaMsg {\r\n        address userAddr;    \r\n        address nodeAddr;   \r\n        uint256 start;  \r\n        uint256 end;  \r\n        uint256 fragment;  \r\n    }\r\n\r\n    struct StakeWLucaMsg {\r\n        address userAddr;    \r\n        address linkAddr;\r\n        address nodeAddr;   \r\n        uint256 start;  \r\n        uint256 end;  \r\n        uint256 wLucaAmount;  \r\n    }\r\n\r\n    modifier onlyNodeAddr(address _nodeAddr) {\r\n        require(nodeAddrSta[_nodeAddr], \"PledgeContract: The pledge address is not a node address\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyExecutor() {\r\n        require(msg.sender == executor, \"PledgeContract: caller is not the admin\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyLinkContract(address _addr) {\r\n        require( lucaFactory.isLink(_addr), \"PledgeContract: This method can only be called by the link contract\");\r\n        _;\r\n    }\r\n\r\n    function init(address _lucaToken, address _lucaFactory, address _executor) external initializer{\r\n        __Ownable_init_unchained();\r\n        __Pledge_init_unchained(_lucaToken, _lucaFactory, _executor);\r\n    }\r\n\r\n    function __Pledge_init_unchained(address _lucaToken, address _lucaFactory, address _executor) internal initializer{\r\n        lucaToken = IERC20(_lucaToken);\r\n        lucaFactory = ILucaFactory(_lucaFactory);\r\n        executor = _executor;\r\n        exchangeRate = lucaToken.fragmentToLuca(10**30);\r\n    }\r\n    \r\n    receive() payable external{\r\n\r\n    }\r\n    \r\n    fallback() payable external{\r\n\r\n    }\r\n  \r\n    /**\r\n    * @notice A method to add a list of trusted nodes\r\n    * @param _nodeAddrs a list of trusted nodes\r\n    */\r\n    function addNodeAddr(address[] calldata _nodeAddrs) override external onlyExecutor{\r\n        for (uint256 i = 0; i< _nodeAddrs.length; i++){\r\n            address _nodeAddr = _nodeAddrs[i];\r\n            require(!nodeAddrSta[_nodeAddr], \"This node is already a pledged node\");\r\n            nodeAddrSta[_nodeAddr] = true;\r\n            uint256 _nodeAddrIndex = nodeAddrIndex[_nodeAddr];\r\n            if (_nodeAddrIndex == 0){\r\n                _nodeAddrIndex = ++nodeNum;\r\n                nodeAddrIndex[_nodeAddr] = _nodeAddrIndex;\r\n                nodeIndexAddr[_nodeAddrIndex] = _nodeAddr;\r\n                addNodeStake(_nodeAddrIndex);\r\n            }\r\n            emit AddNodeAddr(_nodeAddrs[i]);\r\n        }\r\n    }\r\n    \r\n    /**\r\n    * @notice A method to cancel the list of untrusted nodes\r\n    * @param _nodeAddrs the list of untrusted nodes\r\n    */\r\n    function deleteNodeAddr(address[] calldata _nodeAddrs) override external onlyExecutor{\r\n        for (uint256 i = 0; i< _nodeAddrs.length; i++){\r\n            address _nodeAddr = _nodeAddrs[i];\r\n            require(nodeAddrSta[_nodeAddr], \"This node is not a pledge node\");\r\n            nodeAddrSta[_nodeAddr] = false;\r\n            uint256 _nodeAddrIndex = nodeAddrIndex[_nodeAddr];\r\n            if (_nodeAddrIndex > 0){\r\n                uint256 _nodeNum = nodeNum;\r\n                address _lastNodeAddr = nodeIndexAddr[_nodeNum];\r\n                nodeAddrIndex[_lastNodeAddr] = _nodeAddrIndex;\r\n                nodeIndexAddr[_nodeAddrIndex] = _lastNodeAddr;\r\n                nodeAddrIndex[_nodeAddr] = 0;\r\n                nodeIndexAddr[_nodeNum] = address(0x0);\r\n                nodeNum--;\r\n                cancelNodeStake(_lastNodeAddr);\r\n            }\r\n            emit DeleteNodeAddr(_nodeAddrs[i]);\r\n        }\r\n    }\r\n\r\n    function updateExecutor(address _executor) override external onlyOwner{\r\n        executor = _executor;\r\n        emit UpdateExecutor(_executor);\r\n    }\r\n    \r\n    /**\r\n    * @notice A method in which users pledge LUCA to trusted nodes. \r\n    * The nodes must be in the top 11 of the pledge, \r\n    * and the user's pledge can obtain the pledge income\r\n    * @param _nodeAddr trusted node\r\n    * @param _amount the pledge number\r\n    */\r\n    function stakeLuca(address _nodeAddr, uint256 _amount) override external onlyNodeAddr(_nodeAddr){\r\n        address _sender = msg.sender;\r\n        require(lucaToken.transferFrom(_sender,address(this),_amount), \"Token transfer failed\");\r\n        uint256 fragment = lucaToken.lucaToFragment(_amount);\r\n        require(fragment > 0, \"Share calculation anomaly\");\r\n        _stake(_nodeAddr, fragment, _sender, address(0x0), true);\r\n    }\r\n    \r\n    /**\r\n    * @notice A method in which the user pledges trusted nodes in the link contract. \r\n    * The nodes must be in the top 11 of the pledge, \r\n    * and the user's pledge can obtain the pledge income\r\n    * @param _nodeAddr trusted node\r\n    * @param _amount the pledge number\r\n    * @param _sender the pledge user\r\n    */\r\n    function stakeWLuca(\r\n        address _nodeAddr, \r\n        uint256 _amount, \r\n        address _sender\r\n    ) \r\n        override \r\n        external \r\n        onlyNodeAddr(_nodeAddr) \r\n        onlyLinkContract(msg.sender) \r\n        returns(bool)\r\n    {\r\n        return  _stake(_nodeAddr, _amount, _sender, msg.sender, false);\r\n    }\r\n    \r\n    /**\r\n    * @notice A method to the user cancels the pledges\r\n    * @param _indexs the user pledges a collection of ids\r\n    */\r\n    function cancleStakeLuca(uint256[] calldata _indexs) override external {\r\n        address _sender = msg.sender;\r\n        uint256 _amount;\r\n        for (uint256 i = 0; i < _indexs.length; i++) {\r\n            uint256 _stakeLucaMark = _indexs[i];\r\n            if (_stakeLucaMark > 0){\r\n                StakeLucaMsg storage _stakeMsg = stakeLucaMsg[_stakeLucaMark];\r\n                require(_stakeMsg.userAddr == _sender, \"Has no authority to remove the pledge not his own\");\r\n                require(_stakeMsg.end == 0, \"The pledge has been redeemed\");\r\n                _stakeMsg.end = block.timestamp;\r\n                _amount += _stakeMsg.fragment;\r\n                nodeFragmentAmount[_stakeMsg.nodeAddr] = nodeFragmentAmount[_stakeMsg.nodeAddr].sub(_stakeMsg.fragment);\r\n                if (nodeAddrSta[_stakeMsg.nodeAddr]){           \r\n                    cancelNodeStake(_stakeMsg.nodeAddr);\r\n                }\r\n                emit EndStakeLuca(_stakeLucaMark, _sender, _stakeMsg.nodeAddr, block.timestamp);\r\n            }\r\n        }\r\n        _amount = lucaToken.fragmentToLuca(_amount);\r\n        require(lucaToken.transfer(_sender,_amount), \"Token transfer failed\");\r\n    }\r\n    \r\n    /**\r\n    * @notice A method to the user cancels the pledge of the link contract\r\n    * @param _user user address\r\n    */\r\n    function cancleStakeWLuca(address _user) override external  onlyLinkContract(msg.sender) returns(bool){\r\n        address _sender = msg.sender;\r\n        uint256 _index = userLinkIndex[_sender][_user];\r\n        require(_index > 0, \"The corresponding pledge information does not exist\");\r\n        userLinkIndex[_sender][_user] = 0;\r\n        StakeWLucaMsg  memory _stakeMsg = stakeWLucaMsg[_index];\r\n        stakeWLucaMsg[_index].end = block.timestamp;\r\n        nodeWLucaAmount[_stakeMsg.nodeAddr] = nodeWLucaAmount[_stakeMsg.nodeAddr].sub(_stakeMsg.wLucaAmount);\r\n        if (nodeAddrSta[_stakeMsg.nodeAddr]){          \r\n            cancelNodeStake(_stakeMsg.nodeAddr);\r\n        }\r\n        emit EndStakeWLuca(_index, _user, _stakeMsg.nodeAddr, _stakeMsg.linkAddr, block.timestamp);\r\n        return true;\r\n    }\r\n        \r\n    function queryStakeLuca(\r\n        address _userAddr,\r\n        uint256 _page,\r\n        uint256 _limit\r\n    )\r\n        external\r\n        view\r\n        returns(\r\n            address[] memory nodeAddrs,\r\n            uint256[] memory stakeMsgData,\r\n            uint256 _num\r\n        )\r\n    {\r\n        _num = userStakeLucaNum[_userAddr];\r\n\r\n        if (_limit > _num){\r\n            _limit = _num;\r\n        }\r\n        if (_page<2){\r\n            _page = 1;\r\n        }\r\n        _page--;\r\n        uint256 start = _page.mul(_limit);\r\n        uint256 end = start.add(_limit);\r\n        if (end > _num){\r\n            end = _num;\r\n            _limit = end.sub(start);\r\n        }\r\n        nodeAddrs = new address[](_limit);\r\n        stakeMsgData = new uint256[](_limit*4);\r\n        if (_num > 0){\r\n            require(end > start, \"Query index range out of limit\");\r\n            uint256 j;\r\n            for (uint256 i = start; i < end; i++) {\r\n                uint256 _index;\r\n                _index = userStakeLucaIndex[_userAddr][i.add(1)];\r\n                StakeLucaMsg memory _stakeMsg = stakeLucaMsg[_index];\r\n                nodeAddrs[j] = _stakeMsg.nodeAddr;\r\n                stakeMsgData[j*4] = _stakeMsg.start;\r\n                stakeMsgData[j*4+1] = _stakeMsg.end;\r\n                stakeMsgData[j*4+2] = lucaToken.fragmentToLuca(_stakeMsg.fragment);\r\n                stakeMsgData[j*4+3] = _index;\r\n                j++;\r\n            }\r\n        }\r\n    }\r\n\r\n    function queryStakeWLuca(\r\n        address _userAddr,\r\n        uint256 _page,\r\n        uint256 _limit\r\n    )\r\n        external\r\n        view\r\n        returns(\r\n            address[] memory linkAddrs,\r\n            address[] memory nodeAddrs,\r\n            uint256[] memory stakeMsgData,\r\n            uint256 _num\r\n        )\r\n    {\r\n        _num = userStakeWLucaNum[_userAddr];\r\n        if (_limit > _num){\r\n            _limit = _num;\r\n        }\r\n        if (_page<2){\r\n            _page = 1;\r\n        }\r\n        _page--;\r\n        uint256 start = _page.mul(_limit);\r\n        uint256 end = start.add(_limit);\r\n        if (end > _num){\r\n            end = _num;\r\n            _limit = end.sub(start);\r\n        }\r\n        linkAddrs = new address[](_limit);\r\n        nodeAddrs = new address[](_limit);\r\n        stakeMsgData = new uint256[](_limit*4);\r\n        if (_num > 0){\r\n            require(end > start, \"Query index range out of limit\");\r\n            uint256 j;\r\n            for (uint256 i = start; i < end; i++) {\r\n                uint256 _index;\r\n                _index = userStakeWLucaIndex[_userAddr][i.add(1)];\r\n                StakeWLucaMsg memory _stakeMsg = stakeWLucaMsg[_index];\r\n                linkAddrs[j] = _stakeMsg.linkAddr;\r\n                nodeAddrs[j] = _stakeMsg.nodeAddr;\r\n                stakeMsgData[j*4] = _stakeMsg.start;\r\n                stakeMsgData[j*4+1] = _stakeMsg.end;\r\n                stakeMsgData[j*4+2] = _stakeMsg.wLucaAmount;\r\n                stakeMsgData[j*4+3] = _index;\r\n                j++;\r\n            }\r\n        }\r\n    }\r\n\r\n    function queryNodeRank(uint256 start, uint256 end) external view returns (address[] memory, uint256[] memory) {\r\n        require(start > 0, \"start must larger than 0\");\r\n        if (end > nodeNum){\r\n            end = nodeNum;\r\n        }\r\n        address[] memory _addrArray = new address[](1) ;\r\n        uint256[] memory _stakeAmount = new uint256[](1) ;\r\n        uint256 j;\r\n        if (end >= start){\r\n            uint256 len = end.sub(start).add(1);\r\n            _addrArray = new address[](len) ;\r\n            _stakeAmount = new uint256[](len) ;\r\n            for (uint256 i = start; i <= end; i++) {\r\n                address _nodeAddr = nodeIndexAddr[i];\r\n                _addrArray[j] = _nodeAddr;\r\n                _stakeAmount[j] = lucaToken.fragmentToLuca(nodeFragmentAmount[_nodeAddr]).add(nodeWLucaAmount[_nodeAddr]);\r\n                j++;\r\n            }\r\n        }\r\n        return (_addrArray, _stakeAmount);\r\n    }\r\n    \r\n    function queryNodeIndex(address _nodeAddr) external view returns(uint256){\r\n        return nodeAddrIndex[_nodeAddr];\r\n    }\r\n\r\n    function queryNodeStakeAmount(address _nodeAddr) external view returns(uint256){\r\n        uint256 lucaStakeAmount = lucaToken.fragmentToLuca(nodeFragmentAmount[_nodeAddr]).add(nodeWLucaAmount[_nodeAddr]);\r\n        return lucaStakeAmount;\r\n    }\r\n\r\n    function nodeRank(uint256 start, uint256 end) override public {\r\n        uint256 _exchangeRate= lucaToken.fragmentToLuca(10**30);\r\n        exchangeRate = _exchangeRate;\r\n        uint256 _nodeNum = nodeNum;\r\n        if (_nodeNum > end){\r\n            _nodeNum = end;\r\n        }\r\n        for (uint256 i=start; i <= _nodeNum; i++){\r\n            for (uint256 j=i+start ; j <= _nodeNum; j++){\r\n                address nextAddr = nodeIndexAddr[j];\r\n                address prefixAddr = nodeIndexAddr[i];\r\n                uint256 _nextSum = nodeFragmentAmount[nextAddr].mul(_exchangeRate).div(10**30).add(nodeWLucaAmount[nextAddr]);\r\n                uint256 _prefixSum = nodeFragmentAmount[prefixAddr].mul(_exchangeRate).div(10**30).add(nodeWLucaAmount[prefixAddr]);\r\n                if (_prefixSum < _nextSum){\r\n                    nodeAddrIndex[prefixAddr] = j;\r\n                    nodeAddrIndex[nextAddr] = i;\r\n                    nodeIndexAddr[i] = nextAddr;\r\n                    nodeIndexAddr[j] = prefixAddr;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    function _stake(address _nodeAddr, uint256 _amount, address _sender, address _linkAddr, bool _sta) internal  returns(bool){\r\n        uint256 _nodeNum = nodeNum;\r\n        uint256 _nodeAddrIndex = nodeAddrIndex[_nodeAddr];\r\n        if (_nodeAddrIndex == 0){\r\n            _nodeAddrIndex = ++nodeNum;\r\n            _nodeNum = _nodeAddrIndex;\r\n            nodeAddrIndex[_nodeAddr] = _nodeAddrIndex;\r\n            nodeIndexAddr[_nodeAddrIndex] = _nodeAddr;\r\n        }\r\n        if (_sta){\r\n            uint256 _stakeLucaNum = ++stakeLucaNum;\r\n            uint256 _userStakeLucaNum = ++userStakeLucaNum[_sender];\r\n            userStakeLucaIndex[_sender][_userStakeLucaNum] = _stakeLucaNum;\r\n            nodeFragmentAmount[_nodeAddr] += _amount;\r\n            stakeLucaMsg[_stakeLucaNum] = StakeLucaMsg(_sender, _nodeAddr, block.timestamp, 0, _amount);\r\n            emit StakeLuca(_stakeLucaNum, _sender, _nodeAddr, _amount, block.timestamp);\r\n        }else{\r\n            uint256 _stakeWLucaNum = ++stakeWLucaNum;\r\n            uint256 _userStakeWLucaNum = ++userStakeWLucaNum[_sender];\r\n            userStakeWLucaIndex[_sender][_userStakeWLucaNum] = _stakeWLucaNum;\r\n            nodeWLucaAmount[_nodeAddr] += _amount;\r\n            stakeWLucaMsg[_stakeWLucaNum] = StakeWLucaMsg(_sender, _linkAddr, _nodeAddr, block.timestamp, 0, _amount);\r\n            require(userLinkIndex[_linkAddr][_sender] == 0, \"The corresponding pledge information already exists\");\r\n            userLinkIndex[_linkAddr][_sender] = _stakeWLucaNum;\r\n            emit StakeWLuca(_stakeWLucaNum, _sender, _nodeAddr, _linkAddr, _amount, block.timestamp);\r\n        }\r\n        addNodeStake(_nodeAddrIndex);\r\n        return true;\r\n    }\r\n\r\n    function addNodeStake(uint256 _nodeAddrIndex) internal {\r\n        uint256 _exchangeRate = exchangeRate;\r\n        for (uint256 i = _nodeAddrIndex; i > 1; i--) {\r\n            address _nodeAddr = nodeIndexAddr[i];\r\n            uint256 _prefixIndex = i.sub(1);\r\n            address prefixAddr = nodeIndexAddr[_prefixIndex];\r\n            uint256 _nodeSum = nodeFragmentAmount[_nodeAddr].mul(_exchangeRate).div(10**30).add(nodeWLucaAmount[_nodeAddr]);\r\n            uint256 _prefixSum = nodeFragmentAmount[prefixAddr].mul(_exchangeRate).div(10**30).add(nodeWLucaAmount[prefixAddr]);\r\n            if (_prefixSum < _nodeSum){\r\n                nodeAddrIndex[prefixAddr] = i;\r\n                nodeAddrIndex[_nodeAddr] = _prefixIndex;\r\n                nodeIndexAddr[i] = prefixAddr;\r\n                nodeIndexAddr[_prefixIndex] = _nodeAddr;\r\n            }else{\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    function cancelNodeStake(address _addr) internal {\r\n        uint256 _nodeNum = nodeNum;\r\n        uint256 _exchangeRate = exchangeRate;\r\n        uint256 _nodeAddrIndex = nodeAddrIndex[_addr];\r\n        for (uint256 i = _nodeAddrIndex; i < _nodeNum; i++) {\r\n            address _nodeAddr = nodeIndexAddr[i];\r\n            uint256 _lastIndex = i.add(1);\r\n            address lastAddr = nodeIndexAddr[_lastIndex];\r\n            uint256 _nodeSum = nodeFragmentAmount[_nodeAddr].mul(_exchangeRate).div(10**30).add(nodeWLucaAmount[_nodeAddr]);\r\n            uint256 _lastSum = nodeFragmentAmount[lastAddr].mul(_exchangeRate).div(10**30).add(nodeWLucaAmount[lastAddr]);\r\n            if (_lastSum > _nodeSum){\r\n                nodeAddrIndex[lastAddr] = i;\r\n                nodeAddrIndex[_nodeAddr] = _lastIndex;\r\n                nodeIndexAddr[i] = lastAddr;\r\n                nodeIndexAddr[_lastIndex] = _nodeAddr;\r\n            }else{\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n}\r\nlibrary SafeMath {\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        uint256 c = a * b;\r\n        assert(c / a == b);\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\r\n}","ABI":"[{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_nodeAddr\",\"type\":\"address\"}],\"name\":\"AddNodeAddr\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_nodeAddr\",\"type\":\"address\"}],\"name\":\"DeleteNodeAddr\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_stakeNum\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_userAddr\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_nodeAddr\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_time\",\"type\":\"uint256\"}],\"name\":\"EndStakeLuca\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_stakeNum\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_userAddr\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_nodeAddr\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_linkAddr\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_time\",\"type\":\"uint256\"}],\"name\":\"EndStakeWLuca\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_stakeNum\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_userAddr\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_nodeAddr\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_time\",\"type\":\"uint256\"}],\"name\":\"StakeLuca\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_stakeNum\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_userAddr\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_nodeAddr\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_linkAddr\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_time\",\"type\":\"uint256\"}],\"name\":\"StakeWLuca\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_executor\",\"type\":\"address\"}],\"name\":\"UpdateExecutor\",\"type\":\"event\"},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_nodeAddrs\",\"type\":\"address[]\"}],\"name\":\"addNodeAddr\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"_indexs\",\"type\":\"uint256[]\"}],\"name\":\"cancleStakeLuca\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"cancleStakeWLuca\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_nodeAddrs\",\"type\":\"address[]\"}],\"name\":\"deleteNodeAddr\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"exchangeRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"executor\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_lucaToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_lucaFactory\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_executor\",\"type\":\"address\"}],\"name\":\"init\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isOwner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lucaFactory\",\"outputs\":[{\"internalType\":\"contract ILucaFactory\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lucaToken\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"nodeAddrSta\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"nodeIndexAddr\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nodeNum\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"start\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"end\",\"type\":\"uint256\"}],\"name\":\"nodeRank\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"nodeWLucaAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_nodeAddr\",\"type\":\"address\"}],\"name\":\"queryNodeIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"start\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"end\",\"type\":\"uint256\"}],\"name\":\"queryNodeRank\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_nodeAddr\",\"type\":\"address\"}],\"name\":\"queryNodeStakeAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_userAddr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_page\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_limit\",\"type\":\"uint256\"}],\"name\":\"queryStakeLuca\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"nodeAddrs\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"stakeMsgData\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"_num\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_userAddr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_page\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_limit\",\"type\":\"uint256\"}],\"name\":\"queryStakeWLuca\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"linkAddrs\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"nodeAddrs\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"stakeMsgData\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"_num\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_nodeAddr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"stakeLuca\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"stakeLucaMsg\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"userAddr\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"nodeAddr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"start\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"end\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"fragment\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stakeLucaNum\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_nodeAddr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_sender\",\"type\":\"address\"}],\"name\":\"stakeWLuca\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"stakeWLucaMsg\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"userAddr\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"linkAddr\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"nodeAddr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"start\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"end\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"wLucaAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stakeWLucaNum\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_executor\",\"type\":\"address\"}],\"name\":\"updateExecutor\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"userLinkIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"userStakeLucaIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"userStakeLucaNum\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"userStakeWLucaIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"userStakeWLucaNum\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]","ContractName":"Pledge","CompilerVersion":"v0.8.0+commit.c7dfd78e","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"ipfs://b6309c989665140998f47573f884668407e8f286b1e90ba9ed960cb418cd8a2c"}]}