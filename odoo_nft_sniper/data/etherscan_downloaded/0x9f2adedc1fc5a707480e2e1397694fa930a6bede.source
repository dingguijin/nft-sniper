{"status":"1","message":"OK","result":[{"SourceCode":"// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.7;\r\n\r\nlibrary Types {\r\n\r\n    enum AssetDenomination { Wei, Par }\r\n    enum AssetReference { Delta, Target }\r\n\r\n    struct AssetAmount {\r\n        bool sign;\r\n        AssetDenomination denomination;\r\n        AssetReference ref;\r\n        uint256 value;\r\n    }\r\n}\r\n\r\nlibrary Account {\r\n    struct Info {\r\n        address owner;\r\n        uint256 number;\r\n    }\r\n}\r\n\r\nlibrary Actions {\r\n    enum ActionType {\r\n        Deposit, Withdraw, Transfer, Buy, Sell, Trade, Liquidate, Vaporize, Call\r\n    }\r\n\r\n    struct ActionArgs {\r\n        ActionType actionType;\r\n        uint256 accountId;\r\n        Types.AssetAmount amount;\r\n        uint256 primaryMarketId;\r\n        uint256 secondaryMarketId;\r\n        address otherAddress;\r\n        uint256 otherAccountId;\r\n        bytes data;\r\n    }\r\n}\r\n\r\ninterface ISoloMargin {\r\n    function operate(Account.Info[] memory accounts, Actions.ActionArgs[] memory actions) external;\r\n    function getNumMarkets() external view returns (uint256);\r\n    function getMarketTokenAddress(uint256 marketId) external view returns (address);\r\n}\r\n\r\nabstract contract ICallee {\r\n    address internal constant soloMargin = 0x1E0447b19BB6EcFdAe1e4AE1694b0C3659614e4e;\r\n\r\n    function callFunction(address sender, Account.Info memory accountInfo, bytes memory data) external virtual;\r\n\r\n    function getWithdrawAction(\r\n        uint256 marketId,\r\n        uint256 amount\r\n    ) internal view returns (Actions.ActionArgs memory) {\r\n        return Actions.ActionArgs({\r\n            actionType: Actions.ActionType.Withdraw,\r\n            accountId: 0,\r\n            amount: Types.AssetAmount({\r\n                sign: false,\r\n                denomination: Types.AssetDenomination.Wei,\r\n                ref: Types.AssetReference.Delta,\r\n                value: amount\r\n            }),\r\n            primaryMarketId: marketId,\r\n            secondaryMarketId: 0,\r\n            otherAddress: address(this),\r\n            otherAccountId: 0,\r\n            data: \"\"\r\n        });\r\n    }\r\n\r\n    function getCallAction(\r\n        bytes memory data\r\n    ) internal view returns (Actions.ActionArgs memory) {\r\n        return Actions.ActionArgs({\r\n            actionType: Actions.ActionType.Call,\r\n            accountId: 0,\r\n            amount: Types.AssetAmount({\r\n                sign: false,\r\n                denomination: Types.AssetDenomination.Wei,\r\n                ref: Types.AssetReference.Delta,\r\n                value: 0\r\n            }),\r\n            primaryMarketId: 0,\r\n            secondaryMarketId: 0,\r\n            otherAddress: address(this),\r\n            otherAccountId: 0,\r\n            data: data\r\n        });\r\n    }\r\n\r\n    function getDepositAction(\r\n        uint256 marketId,\r\n        uint256 amount\r\n    ) internal view returns (Actions.ActionArgs memory) {\r\n        return Actions.ActionArgs({\r\n            actionType: Actions.ActionType.Deposit,\r\n            accountId: 0,\r\n            amount: Types.AssetAmount({\r\n                sign: true,\r\n                denomination: Types.AssetDenomination.Wei,\r\n                ref: Types.AssetReference.Delta,\r\n                value: amount\r\n            }),\r\n            primaryMarketId: marketId,\r\n            secondaryMarketId: 0,\r\n            otherAddress: address(this),\r\n            otherAccountId: 0,\r\n            data: \"\"\r\n        });\r\n    }\r\n}\r\n\r\n\r\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/IERC20.sol)\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\ninterface IERC20Metadata is IERC20 {\r\n    /**\r\n     * @dev Returns the name of the token.\r\n     */\r\n    function name() external view returns (string memory);\r\n\r\n    /**\r\n     * @dev Returns the symbol of the token.\r\n     */\r\n    function symbol() external view returns (string memory);\r\n\r\n    /**\r\n     * @dev Returns the decimals places of the token.\r\n     */\r\n    function decimals() external view returns (uint8);\r\n}\r\n\r\n/**\r\n * @dev adjusted\r\n */\r\ninterface ERC20 is IERC20Metadata {}\r\n\r\n\r\ninterface CToken is IERC20Metadata {\r\n    function interestRateModel() external view returns (address);\r\n    function underlying() external view returns (address);\r\n    function totalBorrows() external view returns (uint256);\r\n    function totalReserves() external view returns (uint256);\r\n    function reserveFactorMantissa() external view returns (uint256);\r\n    function exchangeRateStored() external view returns (uint);\r\n    function borrowBalanceStored(address account) external view returns (uint);\r\n    function getCash() external view returns (uint);\r\n    function totalBorrowsCurrent() external view returns (uint);\r\n    function borrowRatePerBlock() external view returns (uint);\r\n    function supplyRatePerBlock() external view returns (uint);\r\n    function getAccountSnapshot(address account) external view returns (uint, uint, uint, uint);\r\n\r\n    function mint(uint mintAmount) external returns (uint);\r\n    function redeem(uint redeemTokens) external returns (uint);\r\n    function balanceOfUnderlying(address owner) external returns (uint);\r\n    function borrowBalanceCurrent(address account) external returns (uint);\r\n    function redeemUnderlying(uint redeemUnderlyingAmount) external returns (uint);\r\n    function repayBorrow(uint repayAmount) external returns (uint);\r\n    function borrow(uint borrowAmount) external returns (uint);\r\n\r\n}\r\n\r\ninterface InterestRateModel {\r\n    function utilizationRate(uint cash, uint borrows, uint reserves) external pure returns (uint);\r\n    function kink() external pure returns (uint);\r\n    function jumpMultiplierPerBlock() external pure returns (uint);\r\n    function baseRatePerBlock() external pure returns (uint);\r\n    function multiplierPerBlock() external pure returns (uint);\r\n}\r\n\r\ninterface PriceOracle {\r\n    function getUnderlyingPrice(CToken cToken) external view returns (uint);\r\n}\r\n\r\ninterface Comptroller {\r\n    struct Market {\r\n       bool isListed;\r\n       uint collateralFactorMantissa;\r\n       bool isComped;\r\n    }\r\n\r\n    function markets(address cToken) external view returns (Market memory);\r\n    function compAccrued(address cToken) external view returns (uint256);\r\n    function closeFactorMantissa() external view returns (uint256);\r\n    function liquidationIncentiveMantissa() external view returns (uint256);\r\n    function oracle() external view returns (address);\r\n    function getAccountLiquidity(address account) external view returns (uint, uint, uint);\r\n    function getAssetsIn(address account) external view returns (address[] memory);\r\n    function compSupplySpeeds(address cTokenAddress) external view returns(uint);\r\n    function compBorrowSpeeds(address cTokenAddress) external view returns(uint);\r\n    function getAllMarkets() external view returns (CToken[] memory);\r\n\r\n    function enterMarkets(address[] calldata cTokens) external returns (uint[] memory);\r\n    function claimComp(address) external;\r\n\r\n}\r\n\r\ninterface CompoundLens {\r\n    struct CompBalanceMetadataExt{\r\n        uint balance;\r\n        uint votes;\r\n        address delegate;\r\n        uint allocated;\r\n    }\r\n    function claimComp(address) external;\r\n    function getCompBalanceMetadataExt(address comp, address comptroller, address account) external returns (CompBalanceMetadataExt memory);\r\n}\r\n\r\n\r\n/// @title Contains 512-bit math functions - Credit to Uniswap, adjusted to v0.8.0\r\n/// @notice Facilitates multiplication and division that can have overflow of an intermediate value without any loss of precision\r\n/// @dev Handles \"phantom overflow\" i.e., allows multiplication and division where an intermediate value overflows 256 bits\r\nlibrary FullMath {\r\n    /// @notice Calculates floor(a×b÷denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\r\n    /// @param a The multiplicand\r\n    /// @param b The multiplier\r\n    /// @param denominator The divisor\r\n    /// @return result The 256-bit result\r\n    /// @dev Credit to Remco Bloemen under MIT license https://xn--2-umb.com/21/muldiv\r\n    function mulDiv(\r\n        uint256 a,\r\n        uint256 b,\r\n        uint256 denominator\r\n    ) internal pure returns (uint256 result) {\r\n        // 512-bit multiply [prod1 prod0] = a * b\r\n        // Compute the product mod 2**256 and mod 2**256 - 1\r\n        // then use the Chinese Remainder Theorem to reconstruct\r\n        // the 512 bit result. The result is stored in two 256\r\n        // variables such that product = prod1 * 2**256 + prod0\r\n        uint256 prod0; // Least significant 256 bits of the product\r\n        uint256 prod1; // Most significant 256 bits of the product\r\n        assembly {\r\n            let mm := mulmod(a, b, not(0))\r\n            prod0 := mul(a, b)\r\n            prod1 := sub(sub(mm, prod0), lt(mm, prod0))\r\n        }\r\n\r\n        // Handle non-overflow cases, 256 by 256 division\r\n        if (prod1 == 0) {\r\n            require(denominator > 0);\r\n            assembly {\r\n                result := div(prod0, denominator)\r\n            }\r\n            return result;\r\n        }\r\n\r\n        // Make sure the result is less than 2**256.\r\n        // Also prevents denominator == 0\r\n        require(denominator > prod1);\r\n\r\n        ///////////////////////////////////////////////\r\n        // 512 by 256 division.\r\n        ///////////////////////////////////////////////\r\n\r\n        // Make division exact by subtracting the remainder from [prod1 prod0]\r\n        // Compute remainder using mulmod\r\n        uint256 remainder;\r\n        assembly {\r\n            remainder := mulmod(a, b, denominator)\r\n        }\r\n        // Subtract 256 bit number from 512 bit number\r\n        assembly {\r\n            prod1 := sub(prod1, gt(remainder, prod0))\r\n            prod0 := sub(prod0, remainder)\r\n        }\r\n\r\n        // Factor powers of two out of denominator\r\n        // Compute largest power of two divisor of denominator.\r\n        // Always >= 1.\r\n        uint256 twos = (type(uint256).max - denominator + 1) & denominator;\r\n        // Divide denominator by power of two\r\n        assembly {\r\n            denominator := div(denominator, twos)\r\n        }\r\n\r\n        // Divide [prod1 prod0] by the factors of two\r\n        assembly {\r\n            prod0 := div(prod0, twos)\r\n        }\r\n        // Shift in bits from prod1 into prod0. For this we need\r\n        // to flip `twos` such that it is 2**256 / twos.\r\n        // If twos is zero, then it becomes one\r\n        assembly {\r\n            twos := add(div(sub(0, twos), twos), 1)\r\n        }\r\n        prod0 |= prod1 * twos;\r\n\r\n        // Invert denominator mod 2**256\r\n        // Now that denominator is an odd number, it has an inverse\r\n        // modulo 2**256 such that denominator * inv = 1 mod 2**256.\r\n        // Compute the inverse by starting with a seed that is correct\r\n        // correct for four bits. That is, denominator * inv = 1 mod 2**4\r\n        uint256 inv = (3 * denominator) ^ 2;\r\n        // Now use Newton-Raphson iteration to improve the precision.\r\n        // Thanks to Hensel's lifting lemma, this also works in modular\r\n        // arithmetic, doubling the correct bits in each step.\r\n        inv *= 2 - denominator * inv; // inverse mod 2**8\r\n        inv *= 2 - denominator * inv; // inverse mod 2**16\r\n        inv *= 2 - denominator * inv; // inverse mod 2**32\r\n        inv *= 2 - denominator * inv; // inverse mod 2**64\r\n        inv *= 2 - denominator * inv; // inverse mod 2**128\r\n        inv *= 2 - denominator * inv; // inverse mod 2**256\r\n\r\n        // Because the division is now exact we can divide by multiplying\r\n        // with the modular inverse of denominator. This will give us the\r\n        // correct result modulo 2**256. Since the precoditions guarantee\r\n        // that the outcome is less than 2**256, this is the final result.\r\n        // We don't need to compute the high bits of the result and prod1\r\n        // is no longer required.\r\n        result = prod0 * inv;\r\n        return result;\r\n    }\r\n\r\n\r\n}\r\n\r\n\r\nlibrary CompoundLib {\r\n    address internal constant cETH = 0x4Ddc2D193948926D02f9B1fE9e1daa0718270ED5;\r\n    address internal constant cSAI = 0xF5DCe57282A584D2746FaF1593d3121Fcac444dC;\r\n    address internal constant cUSDC = 0x39AA39c021dfbaE8faC545936693aC917d5E7563;\r\n    address internal constant cUSDT = 0xf650C3d88D12dB855b8bf7D11Be6C55A4e07dCC9;\r\n    address internal constant cWBTC = 0xC11b1268C1A384e55C48c2391d8d480264A3A7F4;\r\n    address internal constant cWBTC2 = 0xccF4429DB6322D5C611ee964527D42E5d685DD6a; //migrated at block number 12069867\r\n    address internal constant COMP = 0xc00e94Cb662C3520282E6f5717214004A7f26888;\r\n    address internal constant comptroller = 0x3d9819210A31b4961b30EF54bE2aeD79B9c9Cd3B;\r\n    address internal constant compoundLens = 0xd513d22422a3062Bd342Ae374b4b9c20E0a9a074;\r\n\r\n    uint256 internal constant one = 1e18;\r\n\r\n    using FullMath for uint256;\r\n\r\n    function getUnderlyingSymbol(address cToken, address underlying) internal view returns (string memory) {\r\n        if(cToken == cETH) return \"ETH\";\r\n        if(cToken == cSAI) return \"SAI\";\r\n\r\n        return ERC20(underlying).symbol();\r\n    }\r\n\r\n    function getUnderlyingDecimals(address cToken, address underlying) internal view returns (uint256) {\r\n        if(cToken == cETH) return 18;\r\n        return ERC20(underlying).decimals();\r\n    }\r\n\r\n    function getUnderlying(address cToken) internal view returns (address) {\r\n        if(cToken == cETH) return address(0);\r\n        return CToken(cToken).underlying();\r\n    }\r\n\r\n    function getCollateralFactor(address cToken) internal view returns (uint256) {\r\n        Comptroller.Market memory cm = Comptroller(comptroller).markets(cToken);\r\n\r\n        if(!cm.isListed) return 0;\r\n        return cm.collateralFactorMantissa;\r\n    }\r\n\r\n    function getUnderlyingBalance(address cToken, address acc) internal view returns (uint256) {\r\n        return ERC20(cToken).balanceOf(acc).mulDiv(\r\n            CToken(cToken).exchangeRateStored(),\r\n            one\r\n        );\r\n    }\r\n\r\n    function getUnderlyingValueInUSD(address cToken, uint256 underlyingDecimals, uint256 underlyingBalance) internal view returns (uint256) {\r\n        return getUnderlyingPriceInUSD(cToken).mulDiv(underlyingBalance, 10**underlyingDecimals);\r\n    }\r\n\r\n    function getUnderlyingPriceInUSD(address cToken) internal view returns (uint256) {\r\n        PriceOracle oracle = PriceOracle(Comptroller(comptroller).oracle());\r\n\r\n        if(cToken == cUSDC || cToken == cUSDT) return one;\r\n        if(cToken == cWBTC2 || cToken == cWBTC) return oracle.getUnderlyingPrice(CToken(cToken)) / 1e10;\r\n\r\n        return oracle.getUnderlyingPrice(CToken(cToken));\r\n    }\r\n\r\n    function getCompSpeedPerBlock(address cToken, bool supplyOrBorrow) internal view returns (uint256 speed){\r\n        if(supplyOrBorrow) return Comptroller(comptroller).compSupplySpeeds(cToken);\r\n        return Comptroller(comptroller).compBorrowSpeeds(cToken);\r\n    }\r\n\r\n    function getTotalSupplyAmt(address cToken) internal view returns (uint256) {\r\n        return CToken(cToken).totalSupply().mulDiv(CToken(cToken).exchangeRateStored(), one);\r\n    }\r\n\r\n}\r\n\r\n\r\nlibrary AccountProfileLib {\r\n    using CompoundLib for address;\r\n    using FullMath for uint256;\r\n\r\n    struct AssetProfile {\r\n        Supply supply;\r\n        Borrow borrow;\r\n        Asset asset;\r\n        uint256 principal_;\r\n        uint256 borrowLimitPCT_;\r\n        uint256 compRewardPerBlock_;\r\n    }\r\n\r\n    struct Supply {\r\n        uint256 cTokenAmt;\r\n        uint256 amount_;\r\n        uint256 exchangeRate_;\r\n        uint256 collateralFactor_;\r\n        uint256 compSupplySpeed_;\r\n    }\r\n\r\n    struct Borrow {\r\n        uint256 amount;\r\n        uint256 compBorrowSpeed_;\r\n    }\r\n\r\n    struct Asset {\r\n        address cToken;\r\n        uint256 underlyingDecimals_;\r\n    }\r\n\r\n    function newAssetProfile(address cToken, uint256 supplyCTokenAmt, uint256 borrowAmt) internal view returns (AssetProfile memory assetProfile) {\r\n        assetProfile.supply = newSupply(cToken, supplyCTokenAmt);\r\n        assetProfile.borrow = newBorrow(cToken, borrowAmt);\r\n        assetProfile.asset = newAsset(cToken);\r\n\r\n        if(assetProfile.supply.amount_ == 0) {\r\n            // borrowLimitPCT_ = 100% (supplyAmt != 0)\r\n            assetProfile.borrowLimitPCT_ = 0;\r\n        } else {\r\n            // borrowLimitPCT_ = borrowAmt / (supplyAmt * collFactor) = borrowAmt / supplyAmt / collFactor (supplyAmt != 0)\r\n            assetProfile.borrowLimitPCT_ = assetProfile.borrow.amount.mulDiv(\r\n              CompoundLib.one,\r\n              assetProfile.supply.amount_\r\n            ).mulDiv(\r\n              CompoundLib.one,\r\n              assetProfile.supply.collateralFactor_\r\n            );\r\n        }\r\n        uint256 supplyAmt = assetProfile.supply.amount_;\r\n        // principal = supplyAmt - borrowAmt\r\n        if(supplyAmt >= borrowAmt) {\r\n            assetProfile.principal_ = supplyAmt - borrowAmt;\r\n        } else {\r\n            assetProfile.principal_ = 0;\r\n        }\r\n\r\n        // compRewardPerBlock_\r\n        // speed_comp_s*(cTokenAmt_s/cTokenTotalSupply) + speed_comp_b*(amt_b/amt_b_total);\r\n        assetProfile.compRewardPerBlock_ = assetProfile.supply.compSupplySpeed_.mulDiv(\r\n            assetProfile.supply.cTokenAmt,\r\n            CToken(cToken).totalSupply()\r\n        ) + assetProfile.borrow.compBorrowSpeed_.mulDiv(\r\n            assetProfile.borrow.amount,\r\n            CToken(cToken).totalBorrows()\r\n        );\r\n    }\r\n\r\n    function newSupply(address cToken, uint256 cTokenAmt) private view returns (Supply memory supply) {\r\n        supply.cTokenAmt = cTokenAmt;\r\n        supply.collateralFactor_ = cToken.getCollateralFactor();\r\n        supply.compSupplySpeed_ = cToken.getCompSpeedPerBlock(true);\r\n        supply.exchangeRate_ = CToken(cToken).exchangeRateStored();\r\n        supply.amount_ = cTokenAmt.mulDiv(supply.exchangeRate_, CompoundLib.one);\r\n    }\r\n\r\n    function newBorrow(address cToken, uint256 amount) private view returns (Borrow memory borrow) {\r\n        borrow.amount = amount;\r\n        borrow.compBorrowSpeed_ = cToken.getCompSpeedPerBlock(false);\r\n    }\r\n\r\n    function newAsset(address cToken) private view returns (Asset memory asset) {\r\n        asset.cToken = cToken;\r\n        address underlying = cToken.getUnderlying();\r\n        asset.underlyingDecimals_ = cToken.getUnderlyingDecimals(underlying);\r\n    }\r\n\r\n    function calBorrowLimitPCT(uint256 col, uint256 bor) private pure returns (uint256) {\r\n        if(col == 0 || col <= bor) return CompoundLib.one;\r\n        return bor.mulDiv(CompoundLib.one, col);\r\n    }\r\n}\r\n\r\n\r\ninterface ICompFarmingMath {\r\n\r\n    /// @dev Retrieve the asset profile on a single cToken of an account\r\n    ///      The function assume the account doesn't cash in hand, meaning if the borrow amt if any will be supplied back or no borrow at all.\r\n    /// @param acc The account\r\n    /// @param cToken The cToken address\r\n    /// @return The AccountProfileLib.AssetProfile struct data\r\n    function getAssetProfile(address acc, address cToken) external view returns (AccountProfileLib.AssetProfile memory);\r\n\r\n    /// @dev Return the updated Asset Profile with updated principal, borrow limit percentage.\r\n    ///      The function assume the AccountProfile doesn't cash in hand, meaning if the borrow amt if any will be supplied back or no borrow at all.\r\n    /// @param p The Asset Profile before the compute\r\n    /// @param deltaPrincipal The delta of prinicipal btw before and after Asset Profile\r\n    /// @param deltaBorrowLimitPCT The delta borrow limit percentage btw before and fater Asset Profile.\r\n    ///                            The borrow limit percentage is only adjusted by borrowing and supply the same cToken asset.\r\n    ///                            This is for Compound yield farming purpose only.\r\n    /// @return The updated Asset Profile in a farming setup\r\n    function computeAssetProfile(AccountProfileLib.AssetProfile memory p, int256 deltaPrincipal, int256 deltaBorrowLimitPCT) external view returns (AccountProfileLib.AssetProfile memory);\r\n\r\n    /// @dev Return the constant variables for farming comp token of an cToken asset\r\n    /// @param cToken The cToken market\r\n    /// @return blockNumber The block number\r\n    /// @return rate_u The utilization rate\r\n    /// @return k The kink\r\n    /// @return rate_mul The muliplier rate per block\r\n    /// @return rate_base The base rate per block\r\n    /// @return f_reserve The reserve factor\r\n    /// @return f_c The collatral factor\r\n    /// @return rate_jump The jumper rate\r\n    /// @return compSupplySpeed The comp speed for supply\r\n    /// @return compBorrowSpeed The comp speed for borrow\r\n    function getFarmingContext(address cToken) external view returns (\r\n        uint256 blockNumber,\r\n        uint256 rate_u,\r\n        uint256 k,\r\n        uint256 rate_mul,\r\n        uint256 rate_base,\r\n        uint256 f_reserve,\r\n        uint256 f_c,\r\n        uint256 rate_jump,\r\n        uint256 compSupplySpeed,\r\n        uint256 compBorrowSpeed\r\n    );\r\n}\r\n\r\n\r\ncontract CompFarmingMath is ICompFarmingMath {\r\n    using CompoundLib for address;\r\n    using AccountProfileLib for address;\r\n    using FullMath for uint256;\r\n\r\n    error borrowLimitPCTOver100PCT(uint256);\r\n    error borrowLimitPCTLessThanZero();\r\n    error deltaPrincipalTooBig(int256);\r\n\r\n    /// @inheritdoc ICompFarmingMath\r\n    function getAssetProfile(\r\n        address acc,\r\n        address cToken\r\n    ) external override view returns (AccountProfileLib.AssetProfile memory) {\r\n        return AccountProfileLib.newAssetProfile(\r\n            cToken,\r\n            CToken(cToken).balanceOf(acc),\r\n            CToken(cToken).borrowBalanceStored(acc)\r\n        );\r\n    }\r\n    /// @inheritdoc ICompFarmingMath\r\n    function computeAssetProfile(\r\n        AccountProfileLib.AssetProfile memory p,\r\n        int256 deltaPrincipal,\r\n        int256 deltaBorrowLimitPCT\r\n    ) external override view returns (AccountProfileLib.AssetProfile memory) {\r\n        // supplyAmtToBe = principal / (collateralFactor * borrowLimitPCT - 1)\r\n        uint256 toBeBorrowLimitPCT;\r\n        {\r\n            uint256 currborrowLimitPCT = p.borrowLimitPCT_;\r\n            if (deltaBorrowLimitPCT >= 0) {\r\n                toBeBorrowLimitPCT = currborrowLimitPCT + uint256(deltaBorrowLimitPCT);\r\n                if (toBeBorrowLimitPCT >= CompoundLib.one) revert borrowLimitPCTOver100PCT(toBeBorrowLimitPCT);\r\n            } else {\r\n                if (currborrowLimitPCT < uint256(-deltaBorrowLimitPCT)) revert borrowLimitPCTLessThanZero();\r\n                toBeBorrowLimitPCT = currborrowLimitPCT - uint256(-deltaBorrowLimitPCT);\r\n            }\r\n        }\r\n\r\n        uint256 toBePrincipal;\r\n        {\r\n            uint256 currPrincipal = p.principal_;\r\n            if (deltaPrincipal >= 0) {\r\n                toBePrincipal = currPrincipal + uint256(deltaPrincipal);\r\n            } else {\r\n                if (currPrincipal < uint256(-deltaPrincipal)) revert deltaPrincipalTooBig(deltaPrincipal);\r\n                toBePrincipal = currPrincipal - uint256(-deltaPrincipal);\r\n            }\r\n        }\r\n        // supplyAmtToBe = principal / (1 - collateralFactor * borrowLimitPCT)\r\n        uint256 supplyAmtToBe = toBePrincipal.mulDiv(\r\n            CompoundLib.one,\r\n            CompoundLib.one - p.supply.collateralFactor_.mulDiv(toBeBorrowLimitPCT, CompoundLib.one)\r\n        );\r\n        // borrowAmtToBe = supplyAmt * factor * p\r\n        uint256 borrowAmtToBe = supplyAmtToBe.mulDiv(p.supply.collateralFactor_, CompoundLib.one).mulDiv(\r\n            toBeBorrowLimitPCT,\r\n            CompoundLib.one\r\n        );\r\n\r\n        return p.asset.cToken.newAssetProfile(\r\n            supplyAmtToBe.mulDiv(CompoundLib.one, p.supply.exchangeRate_),\r\n            borrowAmtToBe\r\n        );\r\n    }\r\n\r\n    // @inheritdoc ICompFarmingMath\r\n    function getFarmingContext(address cToken) external override view returns (\r\n        uint256 blockNumber,\r\n        uint256 rate_u,\r\n        uint256 k,\r\n        uint256 rate_mul,\r\n        uint256 rate_base,\r\n        uint256 f_reserve,\r\n        uint256 f_c,\r\n        uint256 rate_jump,\r\n        uint256 compSupplySpeed,\r\n        uint256 compBorrowSpeed\r\n    ) {\r\n        blockNumber = block.number;\r\n        CToken c = CToken(cToken);\r\n        InterestRateModel im = InterestRateModel(c.interestRateModel());\r\n        {\r\n            uint256 cash = c.getCash();\r\n            uint256 borrows = c.totalBorrows();\r\n            uint256 reserves = c.totalReserves();\r\n            rate_u = im.utilizationRate(cash, borrows, reserves);\r\n        }\r\n        k = im.kink();\r\n        rate_mul = im.multiplierPerBlock();\r\n        rate_base = im.baseRatePerBlock();\r\n        f_reserve = c.reserveFactorMantissa();\r\n        f_c = CompoundLib.getCollateralFactor(cToken);\r\n        rate_jump = im.jumpMultiplierPerBlock();\r\n        compSupplySpeed = CompoundLib.getCompSpeedPerBlock(cToken, true);\r\n        compBorrowSpeed = CompoundLib.getCompSpeedPerBlock(cToken, false);\r\n    }\r\n}\r\n\r\n\r\n//\r\n// interface IMyCompYield {\r\n//     function getAccountProfile(address acc) external view returns(MyCompYield.AccountProfile memory accountProfile);\r\n//     function getFarmingAccountProfileByAP(MyCompYield.AccountProfile memory accountProfile, uint targetedBorrowLimitPCTMantissa, uint offset) external view returns(bool isValidated, MyCompYield.AccountProfile memory farmingAccountProfile);\r\n//     function getMaxInterestAccountProfileByAP(MyCompYield.AccountProfile memory accountProfile) external view returns(bool isValidated, MyCompYield.AccountProfile memory maxInterestAccountProfile);\r\n//     function getUpdatedFarmingAccountProfile(address cToken, int256 deltaAmount, MyCompYield.AccountProfile memory current, uint256 borrow_limit_pct, uint offset) external view returns (bool isValidated, MyCompYield.AccountProfile memory updated);\r\n//     function getPrincipal(address acc, address cToken) external view returns (bool isValidated, uint256 principal);\r\n// }\r\n//\r\n// library MyCompYield {\r\n//     struct CompProfile{\r\n//          uint balance;\r\n//          uint yetToClaimed;\r\n//     }\r\n//\r\n//     struct AccountInterestProfile{\r\n//         CTokenInterest[] supplyInterests;\r\n//         CTokenInterest[] borrowInterests;\r\n//\r\n//         uint totalInterestInUSD_;\r\n//         bool isPositiveInterest_;\r\n//     }\r\n//\r\n//     struct CTokenInterest{\r\n//         address cTokenAddr;\r\n//         uint interestRateMantissa;\r\n//         uint balance;\r\n//         uint numberOfBlocks;\r\n//\r\n//         string underlyingSymbol_;\r\n//         uint interestInUSD_;\r\n//     }\r\n//\r\n//     struct AccountProfile{\r\n//         SupplyAsset[] suppliedAssets;\r\n//         BorrowAsset[] borrowedAssets;\r\n//\r\n//         uint totalSuppliedInUSD_;\r\n//         uint totalBorrowedInUSD_;\r\n//         uint totalSuppliedInUsdAsCollateral_;\r\n//         uint borrowLimitPCTMantissa_;\r\n//         uint accountCapital_;\r\n//\r\n//         uint[] borrowLimitPCTLineItemMantissaList;\r\n//     }\r\n//\r\n//     struct SupplyAsset{\r\n//         Asset asset;\r\n//\r\n//         uint collateralFactorMantissa_;\r\n//         uint suppliedInUsdAsCollateral_;\r\n//     }\r\n//\r\n//     struct BorrowAsset{\r\n//         Asset asset;\r\n//     }\r\n//\r\n//     struct Asset{\r\n//         address cTokenAddr;\r\n//         uint amount;\r\n//\r\n//         string underlyingSymbol_;\r\n//         uint underlyingDecimals_;\r\n//         uint valueInUSD_;\r\n//         uint compBorrowSpeed_;\r\n//         uint compSupplySpeed_;\r\n//     }\r\n//\r\n//     function getSupplyAmount(\r\n//         AccountProfile memory profile,\r\n//         address cToken\r\n//     ) internal pure returns (uint256) {\r\n//         for (uint256 i = 0; i < profile.suppliedAssets.length; i++) {\r\n//             if (profile.suppliedAssets[i].asset.cTokenAddr == cToken) {\r\n//                 return profile.suppliedAssets[i].asset.amount;\r\n//             }\r\n//         }\r\n//\r\n//         return 0;\r\n//     }\r\n//\r\n//     function getBorrowAmount(\r\n//         AccountProfile memory profile,\r\n//         address cToken\r\n//     ) internal pure returns (uint256) {\r\n//         for (uint256 i = 0; i < profile.borrowedAssets.length; i++) {\r\n//             if (profile.borrowedAssets[i].asset.cTokenAddr == cToken) {\r\n//                 return profile.borrowedAssets[i].asset.amount;\r\n//             }\r\n//         }\r\n//\r\n//         return 0;\r\n//     }\r\n// }\r\n\r\n\r\n/// @title a contract to farm Comp token\r\n/// @author Alex W.(axw.eth)\r\n/// @notice a contract to implement a Comp token farming strategy in the following medium posts\r\n///         \"https://medium.com/alex_28112/compound-finance-yield-farming-math-analysis-part-1-2158e43ce017\"\r\n///         \"https://medium.com/alex_28112/compound-finance-yield-farming-math-analysis-part-2-543c86e9c16e\"\r\n/// @dev    a user proxy contract is recommended to delegate calls to this contract\r\n///         dydx flashloan is implemented in this contract\r\ncontract CompFarmingContract is ICallee {\r\n\r\n    uint256 constant private one = 1e18;\r\n\r\n    error enterMarketFailed(address cToken);\r\n    error borrowFailed(uint256 amount, address cToken);\r\n    error repayBorrowFailed(uint256 amount, address cToken);\r\n    error invaidFarmingAccount(address);\r\n    error repayFlashLoanFailed(uint256 balance);\r\n    error redeemUnderlyingFailed(uint256);\r\n    error numberTooBig(uint256);\r\n    error deltaHasToBeSameDirection();\r\n    error deltasCanBeAllZero();\r\n    error redeemAllFailed(uint256);\r\n    error positionAlreadyClosed();\r\n\r\n    struct PreviewAccountProfileReturn {\r\n        FlashLoanParams flashLoanParams;\r\n    }\r\n\r\n    struct ActionData {\r\n        address sender;\r\n        address cToken;\r\n        address underlying;\r\n        uint256 loanAmount;\r\n        uint256 loanFees;\r\n        int256 deltaPrincipal;\r\n        int256 deltaBorrowLimitPCT;\r\n        bool close;\r\n    }\r\n\r\n    struct FlashLoanParams {\r\n        uint256 marketId;\r\n        uint256 loanAmount;\r\n        uint256 loanFees;\r\n        bytes actionData;\r\n    }\r\n\r\n\r\n    /// @notice the entry to start farming by filling out flashloan details. Farming will start after this call.\r\n    /// @dev Borrow via dydx flashloan to supply to Compound, borrow from Compound to achieve the targeted percentage of borrow rate\r\n    /// @param params FlashLoanParams.marketId The dydx flashloan market id\r\n    ///               FlashLoanParams.loanAmount How to loan from dydx\r\n    ///               FlashLoanParams.loanFees How much fees to pay dydx for the loan\r\n    ///               FlashLoanParams.actionData The encoded Struct Action Data.\r\n    ///               ActionData.sender The EOA sender to borrow and farm. This is not the proxy address if user proxy is used\r\n    ///               ActionData.cToken The cToken address used as collateral.\r\n    ///               ActionData.underlying The underlying address of the cToken\r\n    ///               ActionData.loanAmount How much underlying to borrow from Dydx\r\n    ///               ActionData.loanFees How much fees to pay dydx for the loan\r\n    ///               ActionData.deltaPrincipal How much principal to increase or reduce\r\n    ///               ActionData.deltaBorrowLimitPCT How much borrow limit percentage to increase or reduce\r\n    ///               ActionData.close Set true to close the farming position. Funds will be returned to ActionData.sender\r\n    function flashLoan(\r\n        FlashLoanParams memory params\r\n    ) external {\r\n        ActionData memory data = abi.decode(params.actionData, (ActionData));\r\n        if (params.loanAmount == 0 && !data.close) {\r\n            if (data.deltaPrincipal > 0) {\r\n                IERC20(data.underlying).transferFrom(data.sender, address(this), uint256(data.deltaPrincipal));\r\n                mintInternal(Comptroller(CompoundLib.comptroller), data.underlying, uint256(data.deltaPrincipal), data.cToken);\r\n            } else {\r\n                redeemInternal(uint256(-data.deltaPrincipal), data.cToken);\r\n            }\r\n        }else {\r\n            if (data.close) {\r\n                //closing farming position\r\n                if (CToken(data.cToken).balanceOf(address(this)) == 0) revert positionAlreadyClosed();\r\n                params.loanAmount = CToken(data.cToken).borrowBalanceCurrent(address(this));\r\n                data.loanAmount = params.loanAmount;\r\n                params.actionData = abi.encode(data);\r\n            }\r\n            Actions.ActionArgs[] memory operations = new Actions.ActionArgs[](3);\r\n            operations[0] = getWithdrawAction(params.marketId, params.loanAmount);\r\n            operations[1] = getCallAction(params.actionData);\r\n            operations[2] = getDepositAction(params.marketId, params.loanAmount + params.loanFees);\r\n            Account.Info[] memory accountInfos = new Account.Info[](1);\r\n            accountInfos[0] = Account.Info({owner: address(this), number: 1});\r\n            ISoloMargin(soloMargin).operate(accountInfos, operations);\r\n        }\r\n    }\r\n\r\n    /// @notice users will not use this function directly\r\n    /// @dev the flashloan callback function\r\n    /// @param sender The sender started the flashloan. This will be the user proxy address\r\n    /// @param actionData The ActionData Struct data passed by \"flashLoan\" function call.\r\n    function callFunction(\r\n        address sender,\r\n        Account.Info memory,\r\n        bytes memory actionData\r\n    ) external override {\r\n        ActionData memory data = abi.decode(actionData, (ActionData));\r\n\r\n        if (data.deltaPrincipal > 0){\r\n            IERC20(data.underlying).transferFrom(data.sender, address(this), uint256(data.deltaPrincipal) + data.loanFees);\r\n        } else {\r\n            IERC20(data.underlying).transferFrom(data.sender, address(this), data.loanFees);\r\n        }\r\n\r\n        if (data.deltaPrincipal > 0 || data.deltaBorrowLimitPCT > 0) {\r\n            //supply\r\n            uint256 amountToSupply = uint256(data.deltaPrincipal) + data.loanAmount;\r\n            mintInternal(Comptroller(CompoundLib.comptroller), data.underlying, amountToSupply, data.cToken);\r\n            //borrow\r\n            borrowInternal(data.loanAmount, data.cToken);\r\n        }\r\n        if (data.deltaPrincipal < 0 || data.deltaBorrowLimitPCT < 0) {\r\n            //repay borrow\r\n            repayBorrowInternal(data.underlying, data.loanAmount, data.cToken);\r\n            //redeem\r\n            uint256 amountToRedeem = data.loanAmount + uint256(-data.deltaPrincipal);\r\n            redeemInternal(amountToRedeem, data.cToken);\r\n        }\r\n        if (data.deltaPrincipal < 0) {\r\n            IERC20(data.underlying).transfer(data.sender, uint256(-data.deltaPrincipal));\r\n        }\r\n        if (data.close) {\r\n            repayBorrowInternal(data.underlying, data.loanAmount, data.cToken);\r\n            redeemAllInternal(data.cToken, address(this));\r\n            IERC20(data.underlying).transfer(\r\n              data.sender,\r\n              IERC20(data.underlying).balanceOf(address(this)) - (data.loanAmount + data.loanFees)\r\n            );\r\n        }\r\n\r\n        //repay flashloan\r\n        uint256 balance = IERC20(data.underlying).balanceOf(sender);\r\n        uint256 totalRepayAmt = data.loanAmount + data.loanFees;\r\n        if (totalRepayAmt > balance) revert repayFlashLoanFailed(balance);\r\n\r\n        IERC20(data.underlying).approve(soloMargin, totalRepayAmt);\r\n    }\r\n\r\n    /// @notice This function generates the \"flashloan\" function call's parameters\r\n    /// @dev A pre-compute function to return all the parameters used for the \"flashloan\" function\r\n    /// @param compFarmingMath The math function to optimize Comp return\r\n    /// @param deltaPrincipal The delta principal used for farming.\r\n    ///                       Positive means increasing principal. Negative means reducing principal.\r\n    /// @param cToken The cToken used as collateral\r\n    /// @param deltaBorrowLimitPCT The delta of the borrow limit percentage.\r\n    ///                            Positive means increasing the percentage. Negative means reducing percentage.\r\n    /// @param closePosition The flag to indicate closing the farming position\r\n    /// @return r The returned call data details for the \"flashLoan\" function\r\n    function previewAccountProfile(\r\n        ICompFarmingMath compFarmingMath,\r\n        address underlying,\r\n        int256 deltaPrincipal,\r\n        address cToken,\r\n        int256 deltaBorrowLimitPCT,\r\n        bool closePosition\r\n    ) external view returns (PreviewAccountProfileReturn memory r){\r\n        //find dydx market id\r\n        for(uint256 i = 0; i < ISoloMargin(soloMargin).getNumMarkets(); i++) {\r\n            if(underlying != ISoloMargin(soloMargin).getMarketTokenAddress(i)) continue;\r\n            r.flashLoanParams.marketId = i;\r\n            break;\r\n        }\r\n\r\n        if (closePosition) {\r\n            r.flashLoanParams.loanAmount = 0;\r\n            r.flashLoanParams.loanFees = 2;\r\n            r.flashLoanParams.actionData = abi.encode(ActionData({\r\n                sender: msg.sender,\r\n                cToken: cToken,\r\n                underlying: underlying,\r\n                loanAmount: 0,\r\n                loanFees: 2,\r\n                deltaPrincipal: 0,\r\n                deltaBorrowLimitPCT: 0,\r\n                close: true\r\n            }));\r\n\r\n            return r;\r\n        }\r\n        //recompute the account profile with new principal and borrow_limit_pct\r\n        if (deltaPrincipal == 0 && deltaBorrowLimitPCT == 0) revert deltasCanBeAllZero();\r\n        if (\r\n          (deltaPrincipal > 0 && deltaBorrowLimitPCT < 0)\r\n          || (deltaPrincipal < 0 && deltaBorrowLimitPCT > 0)\r\n        ) revert deltaHasToBeSameDirection();\r\n\r\n        AccountProfileLib.AssetProfile memory currAssetProfile = compFarmingMath.getAssetProfile(address(this), cToken);\r\n        AccountProfileLib.AssetProfile memory toBeAssetProfile = compFarmingMath.computeAssetProfile(currAssetProfile, deltaPrincipal, deltaBorrowLimitPCT);\r\n\r\n        if (deltaPrincipal > 0 || deltaBorrowLimitPCT > 0) {\r\n            // if deltaPrincipal > 0; find out the targeted supply amount;\r\n            // calculate loanAmount = targeted - existing - deltaPrincipal\r\n            // action - supply (deltaPrincipal+loanAmount), borrow loanAmount+2 to repay\r\n            // verification on borrow_limit_pct\r\n            uint256 toBeSupplyAmount = toBeAssetProfile.supply.amount_;\r\n            uint256 currSupplyAmount = currAssetProfile.supply.amount_;\r\n            if (toBeSupplyAmount < currSupplyAmount){\r\n                r.flashLoanParams.loanAmount = 0;\r\n            } else if (toBeSupplyAmount - currSupplyAmount < uint256(deltaPrincipal)) {\r\n                r.flashLoanParams.loanAmount = 0;\r\n            } else {\r\n                r.flashLoanParams.loanAmount = toBeSupplyAmount - currSupplyAmount - uint256(deltaPrincipal);\r\n            }\r\n        } else {\r\n            // if deltaPrincipal < 0; find out the targeted borrow amount;\r\n            // calculate loanAmount = existing - targeted\r\n            // action - repay loanAmount, redeem loanAmount+2 + abs(deltaPrincipal)\r\n            //          repay flashloan; transfer abs(deltaPrincipal) to sender\r\n            // verification on borrow_limit_pct\r\n            uint256 toBeBorrowAmount = toBeAssetProfile.borrow.amount;\r\n            uint256 currBorrowAmount = currAssetProfile.borrow.amount;\r\n            r.flashLoanParams.loanAmount = currBorrowAmount - toBeBorrowAmount;\r\n        }\r\n\r\n        r.flashLoanParams.loanFees = 2;\r\n\r\n        // compute actionData\r\n        r.flashLoanParams.actionData = abi.encode(ActionData({\r\n            sender: msg.sender,\r\n            cToken: cToken,\r\n            underlying: underlying,\r\n            loanAmount: r.flashLoanParams.loanAmount,\r\n            loanFees: 2,\r\n            deltaPrincipal: deltaPrincipal,\r\n            deltaBorrowLimitPCT: deltaBorrowLimitPCT,\r\n            close: false\r\n        }));\r\n    }\r\n\r\n    /// @notice This is to take profit from farmed token\r\n    /// @dev claim farmed Comp token and transfer to EOA\r\n    function harvest() external {\r\n        // claim\r\n        Comptroller(CompoundLib.comptroller).claimComp(address(this));\r\n        // transfer to msg.sender\r\n        ERC20 comp = ERC20(CompoundLib.COMP);\r\n        comp.transfer(msg.sender, comp.balanceOf(address(this)));\r\n    }\r\n\r\n    function mintInternal(Comptroller comptroller, address underlying, uint256 amount, address cToken) internal {\r\n        IERC20(underlying).approve(cToken, amount);\r\n        CToken(cToken).mint(amount);\r\n        enterMarketInternal(comptroller, cToken);\r\n    }\r\n\r\n    function redeemInternal(uint256 amount, address cToken) internal {\r\n        uint256 error = CToken(cToken).redeemUnderlying(amount);\r\n        if (error != 0) revert redeemUnderlyingFailed(amount);\r\n    }\r\n\r\n    function redeemAllInternal(address cToken, address owner) internal {\r\n        uint256 amount = CToken(cToken).balanceOf(owner);\r\n        uint256 error = CToken(cToken).redeem(amount);\r\n        if (error != 0) revert redeemAllFailed(amount);\r\n    }\r\n\r\n    function borrowInternal(uint256 amount, address cToken) internal {\r\n        uint256 error = CToken(cToken).borrow(amount);\r\n        if(error != 0) revert borrowFailed(amount, cToken);\r\n    }\r\n\r\n    function repayBorrowInternal(address underlying, uint256 amount, address cToken) internal {\r\n        IERC20(underlying).approve(cToken, amount);\r\n        uint256 error = CToken(cToken).repayBorrow(amount);\r\n        if(error != 0) revert repayBorrowFailed(amount, cToken);\r\n    }\r\n\r\n    function enterMarketInternal(Comptroller comptroller, address cToken) internal {\r\n        address[] memory _addresses = new address[](1);\r\n        _addresses[0] = cToken;\r\n        uint256 status = comptroller.enterMarkets(_addresses)[0];\r\n\r\n        if(status != 0) revert enterMarketFailed(cToken);\r\n    }\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"cToken\",\"type\":\"address\"}],\"name\":\"borrowFailed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"deltaHasToBeSameDirection\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"deltasCanBeAllZero\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"cToken\",\"type\":\"address\"}],\"name\":\"enterMarketFailed\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"invaidFarmingAccount\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"numberTooBig\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"positionAlreadyClosed\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"redeemAllFailed\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"redeemUnderlyingFailed\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"cToken\",\"type\":\"address\"}],\"name\":\"repayBorrowFailed\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"}],\"name\":\"repayFlashLoanFailed\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"number\",\"type\":\"uint256\"}],\"internalType\":\"struct Account.Info\",\"name\":\"\",\"type\":\"tuple\"},{\"internalType\":\"bytes\",\"name\":\"actionData\",\"type\":\"bytes\"}],\"name\":\"callFunction\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"marketId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"loanAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"loanFees\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"actionData\",\"type\":\"bytes\"}],\"internalType\":\"struct CompFarmingContract.FlashLoanParams\",\"name\":\"params\",\"type\":\"tuple\"}],\"name\":\"flashLoan\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"harvest\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract ICompFarmingMath\",\"name\":\"compFarmingMath\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"underlying\",\"type\":\"address\"},{\"internalType\":\"int256\",\"name\":\"deltaPrincipal\",\"type\":\"int256\"},{\"internalType\":\"address\",\"name\":\"cToken\",\"type\":\"address\"},{\"internalType\":\"int256\",\"name\":\"deltaBorrowLimitPCT\",\"type\":\"int256\"},{\"internalType\":\"bool\",\"name\":\"closePosition\",\"type\":\"bool\"}],\"name\":\"previewAccountProfile\",\"outputs\":[{\"components\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"marketId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"loanAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"loanFees\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"actionData\",\"type\":\"bytes\"}],\"internalType\":\"struct CompFarmingContract.FlashLoanParams\",\"name\":\"flashLoanParams\",\"type\":\"tuple\"}],\"internalType\":\"struct CompFarmingContract.PreviewAccountProfileReturn\",\"name\":\"r\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"CompFarmingContract","CompilerVersion":"v0.8.7+commit.e28d00a7","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"ipfs://54b005fdfb8ff923b73013de37ff7b1cf52c4ea6a13e6a16d0b23ea055d01dab"}]}