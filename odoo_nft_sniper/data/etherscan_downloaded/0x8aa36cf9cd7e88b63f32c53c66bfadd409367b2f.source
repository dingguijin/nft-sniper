{"status":"1","message":"OK","result":[{"SourceCode":"// Sources flattened with hardhat v2.5.0 https://hardhat.org\r\n\r\n// File contracts/libs/TransferHelper.sol\r\n\r\n// SPDX-License-Identifier: GPL-3.0-or-later\r\n\r\npragma solidity ^0.8.6;\r\n\r\n// helper methods for interacting with ERC20 tokens and sending ETH that do not consistently return true/false\r\nlibrary TransferHelper {\r\n    function safeApprove(address token, address to, uint value) internal {\r\n        // bytes4(keccak256(bytes('approve(address,uint)')));\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: APPROVE_FAILED');\r\n    }\r\n\r\n    function safeTransfer(address token, address to, uint value) internal {\r\n        // bytes4(keccak256(bytes('transfer(address,uint)')));\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FAILED');\r\n    }\r\n\r\n    function safeTransferFrom(address token, address from, address to, uint value) internal {\r\n        // bytes4(keccak256(bytes('transferFrom(address,address,uint)')));\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FROM_FAILED');\r\n    }\r\n\r\n    function safeTransferETH(address to, uint value) internal {\r\n        (bool success,) = to.call{value:value,gas:5000}(new bytes(0));\r\n        require(success, 'TransferHelper: ETH_TRANSFER_FAILED');\r\n    }\r\n}\r\n\r\n\r\n// File contracts/interfaces/INestFutures.sol\r\n\r\n// GPL-3.0-or-later\r\n\r\npragma solidity ^0.8.6;\r\n\r\n/// @dev Defines methods for Futures\r\ninterface INestFutures {\r\n    \r\n    struct FutureView {\r\n        uint index;\r\n        address tokenAddress;\r\n        uint lever;\r\n        bool orientation;\r\n        \r\n        uint balance;\r\n        // Base price\r\n        uint basePrice;\r\n        // Base block\r\n        uint baseBlock;\r\n    }\r\n\r\n    /// @dev New future event\r\n    /// @param tokenAddress Target token address, 0 means eth\r\n    /// @param lever Lever of future\r\n    /// @param orientation true: call, false: put\r\n    /// @param index Index of the future\r\n    event New(\r\n        address tokenAddress, \r\n        uint lever,\r\n        bool orientation,\r\n        uint index\r\n    );\r\n\r\n    /// @dev Buy future event\r\n    /// @param index Index of future\r\n    /// @param nestAmount Amount of paid NEST\r\n    event Buy(\r\n        uint index,\r\n        uint nestAmount,\r\n        address owner\r\n    );\r\n\r\n    /// @dev Sell future event\r\n    /// @param index Index of future\r\n    /// @param amount Amount to sell\r\n    /// @param owner The owner of future\r\n    /// @param value Amount of NEST obtained\r\n    event Sell(\r\n        uint index,\r\n        uint amount,\r\n        address owner,\r\n        uint value\r\n    );\r\n\r\n    /// @dev Settle future event\r\n    /// @param index Index of future\r\n    /// @param addr Target address\r\n    /// @param sender Address of settler\r\n    /// @param reward Liquidation reward\r\n    event Settle(\r\n        uint index,\r\n        address addr,\r\n        address sender,\r\n        uint reward\r\n    );\r\n    \r\n    /// @dev Returns the current value of target address in the specified future\r\n    /// @param index Index of future\r\n    /// @param oraclePrice Current price from oracle, usd based, 18 decimals\r\n    /// @param addr Target address\r\n    function balanceOf(uint index, uint oraclePrice, address addr) external view returns (uint);\r\n\r\n    /// @dev Find the futures of the target address (in reverse order)\r\n    /// @param start Find forward from the index corresponding to the given owner address \r\n    /// (excluding the record corresponding to start)\r\n    /// @param count Maximum number of records returned\r\n    /// @param maxFindCount Find records at most\r\n    /// @param owner Target address\r\n    /// @return futureArray Matched futures\r\n    function find(\r\n        uint start, \r\n        uint count, \r\n        uint maxFindCount, \r\n        address owner\r\n    ) external view returns (FutureView[] memory futureArray);\r\n\r\n    /// @dev List futures\r\n    /// @param offset Skip previous (offset) records\r\n    /// @param count Return (count) records\r\n    /// @param order Order. 0 reverse order, non-0 positive order\r\n    /// @return futureArray List of futures\r\n    function list(uint offset, uint count, uint order) external view returns (FutureView[] memory futureArray);\r\n\r\n    /// @dev Create future\r\n    /// @param tokenAddress Target token address, 0 means eth\r\n    /// @param levers Levers of future\r\n    /// @param orientation true: call, false: put\r\n    function create(address tokenAddress, uint[] calldata levers, bool orientation) external;\r\n\r\n    /// @dev Obtain the number of futures that have been created\r\n    /// @return Number of futures created\r\n    function getFutureCount() external view returns (uint);\r\n\r\n    /// @dev Get information of future\r\n    /// @param tokenAddress Target token address, 0 means eth\r\n    /// @param lever Lever of future\r\n    /// @param orientation true: call, false: put\r\n    /// @return Information of future\r\n    function getFutureInfo(\r\n        address tokenAddress, \r\n        uint lever,\r\n        bool orientation\r\n    ) external view returns (FutureView memory);\r\n\r\n    /// @dev Buy future\r\n    /// @param tokenAddress Target token address, 0 means eth\r\n    /// @param lever Lever of future\r\n    /// @param orientation true: call, false: put\r\n    /// @param nestAmount Amount of paid NEST\r\n    function buy(\r\n        address tokenAddress,\r\n        uint lever,\r\n        bool orientation,\r\n        uint nestAmount\r\n    ) external payable;\r\n\r\n    /// @dev Buy future direct\r\n    /// @param index Index of future\r\n    /// @param nestAmount Amount of paid NEST\r\n    function buyDirect(uint index, uint nestAmount) external payable;\r\n\r\n    /// @dev Sell future\r\n    /// @param index Index of future\r\n    /// @param amount Amount to sell\r\n    function sell(uint index, uint amount) external payable;\r\n\r\n    /// @dev Settle future\r\n    /// @param index Index of future\r\n    /// @param addresses Target addresses\r\n    function settle(uint index, address[] calldata addresses) external payable;\r\n\r\n    /// @dev K value is calculated by revised volatility\r\n    /// @param sigmaSQ sigmaSQ for token\r\n    /// @param p0 Last price (number of tokens equivalent to 2000 USD)\r\n    /// @param bn0 Block number of the price p0\r\n    /// @param p Latest price (number of tokens equivalent to 2000 USD)\r\n    /// @param bn The block number of the price p\r\n    function calcRevisedK(uint sigmaSQ, uint p0, uint bn0, uint p, uint bn) external view returns (uint k);\r\n\r\n    /// @dev Calculate the impact cost\r\n    /// @param vol Trade amount in NEST\r\n    /// @return Impact cost\r\n    function impactCost(uint vol) external pure returns (uint);\r\n}\r\n\r\n\r\n// File contracts/interfaces/INestVault.sol\r\n\r\n// GPL-3.0-or-later\r\n\r\npragma solidity ^0.8.6;\r\n\r\n/// @dev Defines methods for Nest Vault\r\ninterface INestVault {\r\n\r\n    /// @dev Approve allowance amount to target contract address\r\n    /// @dev target Target contract address\r\n    /// @dev limit Amount limit can transferred once\r\n    function approve(address target, uint limit) external;\r\n\r\n    /// @dev Transfer to by allowance\r\n    /// @param to Target receive address\r\n    /// @param amount Transfer amount\r\n    function transferTo(address to, uint amount) external;\r\n}\r\n\r\n\r\n// File contracts/custom/ChainParameter.sol\r\n\r\n// GPL-3.0-or-later\r\n\r\npragma solidity ^0.8.6;\r\n\r\n/// @dev Specific parameters for target chain\r\ncontract ChainParameter {\r\n    \r\n    // ETH:\r\n    // Block average time in milliseconds. ethereum 14 seconds, BSC 3 seconds, polygon 2.2 seconds, KCC 3 seconds\r\n    uint constant BLOCK_TIME = 14000;\r\n    // Minimal exercise block period. 180000\r\n    uint constant MIN_PERIOD = 180000;\r\n    // Minimal exercise block period for NestLPGuarantee. 180000\r\n    uint constant MIN_EXERCISE_BLOCK = 180000;\r\n\r\n    // // BSC:\r\n    // // Block average time in milliseconds. ethereum 14 seconds, BSC 3 seconds, polygon 2.2 seconds, KCC 3 seconds\r\n    // uint constant BLOCK_TIME = 3000;\r\n    // // Minimal exercise block period. 840000\r\n    // uint constant MIN_PERIOD = 840000;\r\n    // // Minimal exercise block period for NestLPGuarantee. 840000\r\n    // uint constant MIN_EXERCISE_BLOCK = 840000;\r\n\r\n    // // Polygon:\r\n    // // Block average time in milliseconds. ethereum 14 seconds, BSC 3 seconds, polygon 2.2 seconds, KCC 3 seconds\r\n    // uint constant BLOCK_TIME = 2200;\r\n    // // Minimal exercise block period. 1200000\r\n    // uint constant MIN_PERIOD = 1200000;\r\n    // // Minimal exercise block period for NestLPGuarantee. 1200000\r\n    // uint constant MIN_EXERCISE_BLOCK = 1200000;\r\n\r\n    // // KCC:\r\n    // // Block average time in milliseconds. ethereum 14 seconds, BSC 3 seconds, polygon 2.2 seconds, KCC 3 seconds\r\n    // uint constant BLOCK_TIME = 3000;\r\n    // // Minimal exercise block period. 840000\r\n    // uint constant MIN_PERIOD = 840000;\r\n    // // Minimal exercise block period for NestLPGuarantee. 840000\r\n    // uint constant MIN_EXERCISE_BLOCK = 840000;\r\n}\r\n\r\n\r\n// File contracts/interfaces/INestMapping.sol\r\n\r\n// GPL-3.0-or-later\r\n\r\npragma solidity ^0.8.6;\r\n\r\n/// @dev The interface defines methods for nest builtin contract address mapping\r\ninterface INestMapping {\r\n\r\n    /// @dev Set the built-in contract address of the system\r\n    /// @param nestTokenAddress Address of nest token contract\r\n    /// @param nestNodeAddress Address of nest node contract\r\n    /// @param nestLedgerAddress INestLedger implementation contract address\r\n    /// @param nestMiningAddress INestMining implementation contract address for nest\r\n    /// @param ntokenMiningAddress INestMining implementation contract address for ntoken\r\n    /// @param nestPriceFacadeAddress INestPriceFacade implementation contract address\r\n    /// @param nestVoteAddress INestVote implementation contract address\r\n    /// @param nestQueryAddress INestQuery implementation contract address\r\n    /// @param nnIncomeAddress NNIncome contract address\r\n    /// @param nTokenControllerAddress INTokenController implementation contract address\r\n    function setBuiltinAddress(\r\n        address nestTokenAddress,\r\n        address nestNodeAddress,\r\n        address nestLedgerAddress,\r\n        address nestMiningAddress,\r\n        address ntokenMiningAddress,\r\n        address nestPriceFacadeAddress,\r\n        address nestVoteAddress,\r\n        address nestQueryAddress,\r\n        address nnIncomeAddress,\r\n        address nTokenControllerAddress\r\n    ) external;\r\n\r\n    /// @dev Get the built-in contract address of the system\r\n    /// @return nestTokenAddress Address of nest token contract\r\n    /// @return nestNodeAddress Address of nest node contract\r\n    /// @return nestLedgerAddress INestLedger implementation contract address\r\n    /// @return nestMiningAddress INestMining implementation contract address for nest\r\n    /// @return ntokenMiningAddress INestMining implementation contract address for ntoken\r\n    /// @return nestPriceFacadeAddress INestPriceFacade implementation contract address\r\n    /// @return nestVoteAddress INestVote implementation contract address\r\n    /// @return nestQueryAddress INestQuery implementation contract address\r\n    /// @return nnIncomeAddress NNIncome contract address\r\n    /// @return nTokenControllerAddress INTokenController implementation contract address\r\n    function getBuiltinAddress() external view returns (\r\n        address nestTokenAddress,\r\n        address nestNodeAddress,\r\n        address nestLedgerAddress,\r\n        address nestMiningAddress,\r\n        address ntokenMiningAddress,\r\n        address nestPriceFacadeAddress,\r\n        address nestVoteAddress,\r\n        address nestQueryAddress,\r\n        address nnIncomeAddress,\r\n        address nTokenControllerAddress\r\n    );\r\n\r\n    /// @dev Get address of nest token contract\r\n    /// @return Address of nest token contract\r\n    function getNestTokenAddress() external view returns (address);\r\n\r\n    /// @dev Get address of nest node contract\r\n    /// @return Address of nest node contract\r\n    function getNestNodeAddress() external view returns (address);\r\n\r\n    /// @dev Get INestLedger implementation contract address\r\n    /// @return INestLedger implementation contract address\r\n    function getNestLedgerAddress() external view returns (address);\r\n\r\n    /// @dev Get INestMining implementation contract address for nest\r\n    /// @return INestMining implementation contract address for nest\r\n    function getNestMiningAddress() external view returns (address);\r\n\r\n    /// @dev Get INestMining implementation contract address for ntoken\r\n    /// @return INestMining implementation contract address for ntoken\r\n    function getNTokenMiningAddress() external view returns (address);\r\n\r\n    /// @dev Get INestPriceFacade implementation contract address\r\n    /// @return INestPriceFacade implementation contract address\r\n    function getNestPriceFacadeAddress() external view returns (address);\r\n\r\n    /// @dev Get INestVote implementation contract address\r\n    /// @return INestVote implementation contract address\r\n    function getNestVoteAddress() external view returns (address);\r\n\r\n    /// @dev Get INestQuery implementation contract address\r\n    /// @return INestQuery implementation contract address\r\n    function getNestQueryAddress() external view returns (address);\r\n\r\n    /// @dev Get NNIncome contract address\r\n    /// @return NNIncome contract address\r\n    function getNnIncomeAddress() external view returns (address);\r\n\r\n    /// @dev Get INTokenController implementation contract address\r\n    /// @return INTokenController implementation contract address\r\n    function getNTokenControllerAddress() external view returns (address);\r\n\r\n    /// @dev Registered address. The address registered here is the address accepted by nest system\r\n    /// @param key The key\r\n    /// @param addr Destination address. 0 means to delete the registration information\r\n    function registerAddress(string memory key, address addr) external;\r\n\r\n    /// @dev Get registered address\r\n    /// @param key The key\r\n    /// @return Destination address. 0 means empty\r\n    function checkAddress(string memory key) external view returns (address);\r\n}\r\n\r\n\r\n// File contracts/interfaces/INestGovernance.sol\r\n\r\n// GPL-3.0-or-later\r\n\r\npragma solidity ^0.8.6;\r\n/// @dev This interface defines the governance methods\r\ninterface INestGovernance is INestMapping {\r\n\r\n    /// @dev Set governance authority\r\n    /// @param addr Destination address\r\n    /// @param flag Weight. 0 means to delete the governance permission of the target address. Weight is not \r\n    ///        implemented in the current system, only the difference between authorized and unauthorized. \r\n    ///        Here, a uint96 is used to represent the weight, which is only reserved for expansion\r\n    function setGovernance(address addr, uint flag) external;\r\n\r\n    /// @dev Get governance rights\r\n    /// @param addr Destination address\r\n    /// @return Weight. 0 means to delete the governance permission of the target address. Weight is not \r\n    ///        implemented in the current system, only the difference between authorized and unauthorized. \r\n    ///        Here, a uint96 is used to represent the weight, which is only reserved for expansion\r\n    function getGovernance(address addr) external view returns (uint);\r\n\r\n    /// @dev Check whether the target address has governance rights for the given target\r\n    /// @param addr Destination address\r\n    /// @param flag Permission weight. The permission of the target address must be greater than this weight \r\n    /// to pass the check\r\n    /// @return True indicates permission\r\n    function checkGovernance(address addr, uint flag) external view returns (bool);\r\n}\r\n\r\n\r\n// File contracts/NestBase.sol\r\n\r\n// GPL-3.0-or-later\r\n\r\npragma solidity ^0.8.6;\r\n/// @dev Base contract of nest\r\ncontract NestBase {\r\n\r\n    /// @dev INestGovernance implementation contract address\r\n    address public _governance;\r\n\r\n    /// @dev To support open-zeppelin/upgrades\r\n    /// @param governance INestGovernance implementation contract address\r\n    function initialize(address governance) public virtual {\r\n        require(_governance == address(0), \"NEST:!initialize\");\r\n        _governance = governance;\r\n    }\r\n\r\n    /// @dev Rewritten in the implementation contract, for load other contract addresses. Call \r\n    ///      super.update(newGovernance) when overriding, and override method without onlyGovernance\r\n    /// @param newGovernance INestGovernance implementation contract address\r\n    function update(address newGovernance) public virtual {\r\n\r\n        address governance = _governance;\r\n        require(governance == msg.sender || INestGovernance(governance).checkGovernance(msg.sender, 0), \"NEST:!gov\");\r\n        _governance = newGovernance;\r\n    }\r\n\r\n    //---------modifier------------\r\n\r\n    modifier onlyGovernance() {\r\n        require(INestGovernance(_governance).checkGovernance(msg.sender, 0), \"NEST:!gov\");\r\n        _;\r\n    }\r\n\r\n    modifier noContract() {\r\n        require(msg.sender == tx.origin, \"NEST:!contract\");\r\n        _;\r\n    }\r\n}\r\n\r\n\r\n// File contracts/custom/NestFrequentlyUsed.sol\r\n\r\n// GPL-3.0-or-later\r\n\r\npragma solidity ^0.8.6;\r\n/// @dev This contract include frequently used data\r\ncontract NestFrequentlyUsed is NestBase {\r\n\r\n    // ETH:\r\n    // Address of nest token\r\n    address constant NEST_TOKEN_ADDRESS = 0x04abEdA201850aC0124161F037Efd70c74ddC74C;\r\n    // Address of NestOpenPrice contract\r\n    address constant NEST_OPEN_PRICE = 0xE544cF993C7d477C7ef8E91D28aCA250D135aa03;\r\n    // Address of nest vault\r\n    address constant NEST_VAULT_ADDRESS = 0x12858F7f24AA830EeAdab2437480277E92B0723a;\r\n\r\n    // // BSC:\r\n    // // Address of nest token\r\n    // address constant NEST_TOKEN_ADDRESS = 0x98f8669F6481EbB341B522fCD3663f79A3d1A6A7;\r\n    // // Address of NestOpenPrice contract\r\n    // address constant NEST_OPEN_PRICE = 0x09CE0e021195BA2c1CDE62A8B187abf810951540;\r\n    // // Address of nest vault\r\n    // address constant NEST_VAULT_ADDRESS = 0x65e7506244CDdeFc56cD43dC711470F8B0C43beE;\r\n\r\n    // // Polygon:\r\n    // // Address of nest token\r\n    // address constant NEST_TOKEN_ADDRESS = 0x98f8669F6481EbB341B522fCD3663f79A3d1A6A7;\r\n    // // Address of NestOpenPrice contract\r\n    // address constant NEST_OPEN_PRICE = 0x09CE0e021195BA2c1CDE62A8B187abf810951540;\r\n    // // Address of nest vault\r\n    // address constant NEST_VAULT_ADDRESS;\r\n\r\n    // // KCC:\r\n    // // Address of nest token\r\n    // address constant NEST_TOKEN_ADDRESS = 0x98f8669F6481EbB341B522fCD3663f79A3d1A6A7;\r\n    // // Address of NestOpenPrice contract\r\n    // address constant NEST_OPEN_PRICE = 0x7DBe94A4D6530F411A1E7337c7eb84185c4396e6;\r\n    // // Address of nest vault\r\n    // address constant NEST_VAULT_ADDRESS;\r\n\r\n    // USDT base\r\n    uint constant USDT_BASE = 1 ether;\r\n}\r\n\r\n\r\n// File contracts/interfaces/INestBatchPrice2.sol\r\n\r\n// GPL-3.0-or-later\r\n\r\npragma solidity ^0.8.6;\r\n\r\n/// @dev This contract implemented the mining logic of nest\r\ninterface INestBatchPrice2 {\r\n\r\n    /// @dev Get the latest trigger price\r\n    /// @param channelId Target channelId\r\n    /// @param pairIndices Array of pair indices\r\n    /// @param payback Address to receive refund\r\n    /// @return prices Price array, i * 2 is the block where the ith price is located, and i * 2 + 1 is the ith price\r\n    function triggeredPrice(\r\n        uint channelId,\r\n        uint[] calldata pairIndices, \r\n        address payback\r\n    ) external payable returns (uint[] memory prices);\r\n\r\n    /// @dev Get the full information of latest trigger price\r\n    /// @param channelId Target channelId\r\n    /// @param pairIndices Array of pair indices\r\n    /// @param payback Address to receive refund\r\n    /// @return prices Price array, i * 4 is the block where the ith price is located, i * 4 + 1 is the ith price,\r\n    /// i * 4 + 2 is the ith average price and i * 4 + 3 is the ith volatility\r\n    function triggeredPriceInfo(\r\n        uint channelId, \r\n        uint[] calldata pairIndices,\r\n        address payback\r\n    ) external payable returns (uint[] memory prices);\r\n\r\n    /// @dev Find the price at block number\r\n    /// @param channelId Target channelId\r\n    /// @param pairIndices Array of pair indices\r\n    /// @param height Destination block number\r\n    /// @param payback Address to receive refund\r\n    /// @return prices Price array, i * 2 is the block where the ith price is located, and i * 2 + 1 is the ith price\r\n    function findPrice(\r\n        uint channelId,\r\n        uint[] calldata pairIndices, \r\n        uint height, \r\n        address payback\r\n    ) external payable returns (uint[] memory prices);\r\n\r\n    /// @dev Get the last (num) effective price\r\n    /// @param channelId Target channelId\r\n    /// @param pairIndices Array of pair indices\r\n    /// @param count The number of prices that want to return\r\n    /// @param payback Address to receive refund\r\n    /// @return prices Result array, i * count * 2 to (i + 1) * count * 2 - 1 are \r\n    /// the price results of group i quotation pairs\r\n    function lastPriceList(\r\n        uint channelId, \r\n        uint[] calldata pairIndices, \r\n        uint count, \r\n        address payback\r\n    ) external payable returns (uint[] memory prices);\r\n\r\n    /// @dev Returns lastPriceList and triggered price info\r\n    /// @param channelId Target channelId\r\n    /// @param pairIndices Array of pair indices\r\n    /// @param count The number of prices that want to return\r\n    /// @param payback Address to receive refund\r\n    /// @return prices result of group i quotation pair. Among them, the first two count * are the latest prices, \r\n    /// and the last four are: trigger price block number, trigger price, average price and volatility\r\n    function lastPriceListAndTriggeredPriceInfo(\r\n        uint channelId, \r\n        uint[] calldata pairIndices,\r\n        uint count, \r\n        address payback\r\n    ) external payable returns (uint[] memory prices);\r\n}\r\n\r\n\r\n// File contracts/custom/NestPriceAdapter.sol\r\n\r\n// GPL-3.0-or-later\r\n\r\npragma solidity ^0.8.6;\r\n/// @dev PriceAdapter from INestBatchPrice2\r\ncontract NestPriceAdapter is NestFrequentlyUsed {\r\n    \r\n    // Token configuration\r\n    struct TokenConfig {\r\n        // The channelId for call nest price\r\n        uint16 channelId;\r\n        // The pairIndex for call nest price\r\n        uint16 pairIndex;\r\n\r\n        // SigmaSQ for token\r\n        uint64 sigmaSQ;\r\n        // MIU_LONG for token\r\n        uint64 miuLong;\r\n        // MIU_SHORT for token\r\n        uint64 miuShort;\r\n    }\r\n\r\n    // Post unit: 2000usd\r\n    uint constant POST_UNIT = 2000 * USDT_BASE;\r\n\r\n    function _pairIndices(uint pairIndex) private pure returns (uint[] memory pairIndices) {\r\n        pairIndices = new uint[](1);\r\n        pairIndices[0] = pairIndex;\r\n    }\r\n\r\n    // Query latest 2 price\r\n    function _lastPriceList(\r\n        TokenConfig memory tokenConfig, \r\n        uint fee, \r\n        address payback\r\n    ) internal returns (uint[] memory prices) {\r\n        prices = INestBatchPrice2(NEST_OPEN_PRICE).lastPriceList {\r\n            value: fee\r\n        } (uint(tokenConfig.channelId), _pairIndices(uint(tokenConfig.pairIndex)), 2, payback);\r\n\r\n        prices[1] = _toUSDTPrice(prices[1]);\r\n        prices[3] = _toUSDTPrice(prices[3]);\r\n    }\r\n\r\n    // Query latest price\r\n    function _latestPrice(\r\n        TokenConfig memory tokenConfig, \r\n        uint fee, \r\n        address payback\r\n    ) internal returns (uint oraclePrice) {\r\n        uint[] memory prices = INestBatchPrice2(NEST_OPEN_PRICE).lastPriceList {\r\n            value: fee\r\n        } (uint(tokenConfig.channelId), _pairIndices(uint(tokenConfig.pairIndex)), 1, payback);\r\n\r\n        oraclePrice = _toUSDTPrice(prices[1]);\r\n    }\r\n\r\n    // Find price by blockNumber\r\n    function _findPrice(\r\n        TokenConfig memory tokenConfig, \r\n        uint blockNumber, \r\n        uint fee, \r\n        address payback\r\n    ) internal returns (uint oraclePrice) {\r\n        uint[] memory prices = INestBatchPrice2(NEST_OPEN_PRICE).findPrice {\r\n            value: fee\r\n        } (uint(tokenConfig.channelId), _pairIndices(uint(tokenConfig.pairIndex)), blockNumber, payback);\r\n\r\n        oraclePrice = _toUSDTPrice(prices[1]);\r\n    }\r\n\r\n    // Convert to usdt based price\r\n    function _toUSDTPrice(uint rawPrice) internal pure returns (uint) {\r\n        return POST_UNIT * 1 ether / rawPrice;\r\n    }\r\n}\r\n\r\n\r\n// File contracts/NestFutures.sol\r\n\r\n// GPL-3.0-or-later\r\n\r\npragma solidity ^0.8.6;\r\n/// @dev Futures\r\ncontract NestFutures is ChainParameter, NestFrequentlyUsed, NestPriceAdapter, INestFutures {\r\n\r\n    /// @dev Account information\r\n    struct Account {\r\n        // Amount of margin\r\n        uint128 balance;\r\n        // Base price\r\n        uint64 basePrice;\r\n        // Base block\r\n        uint32 baseBlock;\r\n    }\r\n\r\n    /// @dev Future information\r\n    struct FutureInfo {\r\n        // Target token address\r\n        address tokenAddress; \r\n        // Lever of future\r\n        uint32 lever;\r\n        // true: call, false: put\r\n        bool orientation;\r\n\r\n        // Token index in _tokenConfigs\r\n        uint16 tokenIndex;\r\n        \r\n        // Account mapping\r\n        mapping(address=>Account) accounts;\r\n    }\r\n\r\n    // Minimum balance quantity. If the balance is less than this value, it will be liquidated\r\n    uint constant MIN_VALUE = 10 ether;\r\n\r\n    // Mapping from composite key to future index\r\n    mapping(uint=>uint) _futureMapping;\r\n\r\n    // Future array, element of 0 is place holder\r\n    FutureInfo[] _futures;\r\n\r\n    // token to index mapping, address=>tokenConfigIndex + 1\r\n    mapping(address=>uint) _tokenMapping;\r\n\r\n    // Token configs\r\n    TokenConfig[] _tokenConfigs;\r\n\r\n    constructor() {\r\n    }\r\n\r\n    /// @dev To support open-zeppelin/upgrades\r\n    /// @param governance INestGovernance implementation contract address\r\n    function initialize(address governance) public override {\r\n        super.initialize(governance);\r\n        _futures.push();\r\n    }\r\n\r\n    /// @dev Register token configuration\r\n    /// @param tokenAddress Target token address, 0 means eth\r\n    /// @param tokenConfig token configuration\r\n    function register(address tokenAddress, TokenConfig calldata tokenConfig) external onlyGovernance {\r\n        // Get registered tokenIndex by tokenAddress\r\n        uint index = _tokenMapping[tokenAddress];\r\n        \r\n        // index == 0 means token not registered, add\r\n        if (index == 0) {\r\n            // Add tokenConfig to array\r\n            _tokenConfigs.push(tokenConfig);\r\n            // Record index + 1\r\n            index = _tokenConfigs.length;\r\n            require(index < 0x10000, \"NF:too much tokenConfigs\");\r\n            _tokenMapping[tokenAddress] = index;\r\n        } else {\r\n            // Update tokenConfig\r\n            _tokenConfigs[index - 1] = tokenConfig;\r\n        }\r\n    }\r\n\r\n    /// @dev Returns the current value of target address in the specified future\r\n    /// @param index Index of future\r\n    /// @param oraclePrice Current price from oracle, usd based, 18 decimals\r\n    /// @param addr Target address\r\n    function balanceOf(uint index, uint oraclePrice, address addr) external view override returns (uint) {\r\n        FutureInfo storage fi = _futures[index];\r\n        Account memory account = fi.accounts[addr];\r\n        return _balanceOf(\r\n            _tokenConfigs[fi.tokenIndex],\r\n            uint(account.balance), \r\n            _decodeFloat(account.basePrice), \r\n            uint(account.baseBlock),\r\n            oraclePrice, \r\n            fi.orientation, \r\n            uint(fi.lever)\r\n        );\r\n    }\r\n\r\n    /// @dev Find the futures of the target address (in reverse order)\r\n    /// @param start Find forward from the index corresponding to the given owner address \r\n    /// (excluding the record corresponding to start)\r\n    /// @param count Maximum number of records returned\r\n    /// @param maxFindCount Find records at most\r\n    /// @param owner Target address\r\n    /// @return futureArray Matched futures\r\n    function find(\r\n        uint start, \r\n        uint count, \r\n        uint maxFindCount, \r\n        address owner\r\n    ) external view override returns (FutureView[] memory futureArray) {\r\n        futureArray = new FutureView[](count);\r\n        // Calculate search region\r\n        FutureInfo[] storage futures = _futures;\r\n\r\n        // Loop from start to end\r\n        uint end = 0;\r\n        // start is 0 means Loop from the last item\r\n        if (start == 0) {\r\n            start = futures.length;\r\n        }\r\n        // start > maxFindCount, so end is not 0\r\n        if (start > maxFindCount) {\r\n            end = start - maxFindCount;\r\n        }\r\n        \r\n        // Loop lookup to write qualified records to the buffer\r\n        for (uint index = 0; index < count && start > end;) {\r\n            FutureInfo storage fi = futures[--start];\r\n            if (uint(fi.accounts[owner].balance) > 0) {\r\n                futureArray[index++] = _toFutureView(fi, start, owner);\r\n            }\r\n        }\r\n    }\r\n\r\n    /// @dev List futures\r\n    /// @param offset Skip previous (offset) records\r\n    /// @param count Return (count) records\r\n    /// @param order Order. 0 reverse order, non-0 positive order\r\n    /// @return futureArray List of futures\r\n    function list(\r\n        uint offset, \r\n        uint count, \r\n        uint order\r\n    ) external view override returns (FutureView[] memory futureArray) {\r\n        // Load futures\r\n        FutureInfo[] storage futures = _futures;\r\n        // Create result array\r\n        futureArray = new FutureView[](count);\r\n        uint length = futures.length;\r\n        uint i = 0;\r\n\r\n        // Reverse order\r\n        if (order == 0) {\r\n            uint index = length - offset;\r\n            uint end = index > count ? index - count : 0;\r\n            while (index > end) {\r\n                FutureInfo storage fi = futures[--index];\r\n                futureArray[i++] = _toFutureView(fi, index, msg.sender);\r\n            }\r\n        } \r\n        // Positive order\r\n        else {\r\n            uint index = offset;\r\n            uint end = index + count;\r\n            if (end > length) {\r\n                end = length;\r\n            }\r\n            while (index < end) {\r\n                futureArray[i++] = _toFutureView(futures[index], index, msg.sender);\r\n                ++index;\r\n            }\r\n        }\r\n    }\r\n\r\n    /// @dev Create future\r\n    /// @param tokenAddress Target token address, 0 means eth\r\n    /// @param levers Levers of future\r\n    /// @param orientation true: call, false: put\r\n    function create(address tokenAddress, uint[] calldata levers, bool orientation) external override onlyGovernance {\r\n\r\n        // Get registered tokenIndex by tokenAddress\r\n        // _tokenMapping[tokenAddress] is less than 0x10000, so it can convert to uint16\r\n        // If tokenAddress not registered, _tokenMapping[tokenAddress] is 0, subtract by 1 will failed\r\n        // This make sure tokenAddress must registered\r\n        uint16 tokenIndex = uint16(_tokenMapping[tokenAddress] - 1);\r\n\r\n        // Create futures\r\n        for (uint i = 0; i < levers.length; ++i) {\r\n            uint lever = levers[i];\r\n\r\n            // Check if the future exists\r\n            uint key = _getKey(tokenAddress, lever, orientation);\r\n            uint index = _futureMapping[key];\r\n            require(index == 0, \"NF:exists\");\r\n\r\n            // Create future\r\n            index = _futures.length;\r\n            FutureInfo storage fi = _futures.push();\r\n            fi.tokenAddress = tokenAddress;\r\n            fi.lever = uint32(lever);\r\n            fi.orientation = orientation;\r\n            fi.tokenIndex = tokenIndex;\r\n\r\n            _futureMapping[key] = index;\r\n\r\n            // emit New event\r\n            emit New(tokenAddress, lever, orientation, index);\r\n        }\r\n    }\r\n\r\n    /// @dev Obtain the number of futures that have been created\r\n    /// @return Number of futures created\r\n    function getFutureCount() external view override returns (uint) {\r\n        return _futures.length;\r\n    }\r\n\r\n    /// @dev Get information of future\r\n    /// @param tokenAddress Target token address, 0 means eth\r\n    /// @param lever Lever of future\r\n    /// @param orientation true: call, false: put\r\n    /// @return Information of future\r\n    function getFutureInfo(\r\n        address tokenAddress, \r\n        uint lever,\r\n        bool orientation\r\n    ) external view override returns (FutureView memory) {\r\n        uint index = _futureMapping[_getKey(tokenAddress, lever, orientation)];\r\n        return _toFutureView(_futures[index], index, msg.sender);\r\n    }\r\n\r\n    /// @dev Buy future\r\n    /// @param tokenAddress Target token address, 0 means eth\r\n    /// @param lever Lever of future\r\n    /// @param orientation true: call, false: put\r\n    /// @param nestAmount Amount of paid NEST\r\n    function buy(\r\n        address tokenAddress,\r\n        uint lever,\r\n        bool orientation,\r\n        uint nestAmount\r\n    ) external payable override {\r\n        return buyDirect(_futureMapping[_getKey(tokenAddress, lever, orientation)], nestAmount);\r\n    }\r\n\r\n    /// @dev Buy future direct\r\n    /// @param index Index of future\r\n    /// @param nestAmount Amount of paid NEST\r\n    function buyDirect(uint index, uint nestAmount) public payable override {\r\n\r\n        require(index != 0, \"NF:not exist\");\r\n        require(nestAmount >= 50 ether, \"NF:at least 50 NEST\");\r\n\r\n        // 1. Transfer NEST from user\r\n        //DCU(DCU_TOKEN_ADDRESS).burn(msg.sender, nestAmount);\r\n        TransferHelper.safeTransferFrom(NEST_TOKEN_ADDRESS, msg.sender, NEST_VAULT_ADDRESS, nestAmount);\r\n\r\n        FutureInfo storage fi = _futures[index];\r\n        bool orientation = fi.orientation;\r\n        \r\n        // 2. Query oracle price\r\n        // When call, the base price multiply (1 + k), and the sell price divide (1 + k)\r\n        // When put, the base price divide (1 + k), and the sell price multiply (1 + k)\r\n        // When merger, s0 use recorded price, s1 use corrected by k\r\n        TokenConfig memory tokenConfig = _tokenConfigs[uint(fi.tokenIndex)];\r\n        uint oraclePrice = _queryPrice(nestAmount, tokenConfig, orientation, msg.sender);\r\n\r\n        // 3. Merger price\r\n        Account memory account = fi.accounts[msg.sender];\r\n        uint basePrice = _decodeFloat(account.basePrice);\r\n        uint balance = uint(account.balance);\r\n        uint newPrice = oraclePrice;\r\n        if (uint(account.baseBlock) > 0) {\r\n            newPrice = (balance + nestAmount) * oraclePrice * basePrice / (\r\n                basePrice * nestAmount + (balance << 64) * oraclePrice / _expMiuT(\r\n                    uint(orientation ? tokenConfig.miuLong : tokenConfig.miuShort), \r\n                    uint(account.baseBlock)\r\n                )\r\n            );\r\n        }\r\n        \r\n        // 4. Update account\r\n        account.balance = _toUInt128(balance + nestAmount);\r\n        account.basePrice = _encodeFloat(newPrice);\r\n        account.baseBlock = uint32(block.number);\r\n        fi.accounts[msg.sender] = account;\r\n\r\n        // emit Buy event\r\n        emit Buy(index, nestAmount, msg.sender);\r\n    }\r\n\r\n    /// @dev Sell future\r\n    /// @param index Index of future\r\n    /// @param amount Amount to sell\r\n    function sell(uint index, uint amount) external payable override {\r\n\r\n        require(index != 0, \"NF:not exist\");\r\n        \r\n        // 1. Load the future\r\n        FutureInfo storage fi = _futures[index];\r\n        bool orientation = fi.orientation;\r\n\r\n        // 2. Query oracle price\r\n        // When call, the base price multiply (1 + k), and the sell price divide (1 + k)\r\n        // When put, the base price divide (1 + k), and the sell price multiply (1 + k)\r\n        // When merger, s0 use recorded price, s1 use corrected by k\r\n        TokenConfig memory tokenConfig = _tokenConfigs[uint(fi.tokenIndex)];\r\n        uint oraclePrice = _queryPrice(0, tokenConfig, !orientation, msg.sender);\r\n\r\n        // 3. Update account\r\n        Account memory account = fi.accounts[msg.sender];\r\n        account.balance -= _toUInt128(amount);\r\n        fi.accounts[msg.sender] = account;\r\n\r\n        // 4. Transfer NEST to user\r\n        uint value = _balanceOf(\r\n            tokenConfig,\r\n            amount, \r\n            _decodeFloat(account.basePrice), \r\n            uint(account.baseBlock),\r\n            oraclePrice, \r\n            orientation, \r\n            uint(fi.lever)\r\n        );\r\n        //DCU(DCU_TOKEN_ADDRESS).mint(msg.sender, value);\r\n        INestVault(NEST_VAULT_ADDRESS).transferTo(msg.sender, value);\r\n\r\n        // emit Sell event\r\n        emit Sell(index, amount, msg.sender, value);\r\n    }\r\n\r\n    /// @dev Settle future\r\n    /// @param index Index of future\r\n    /// @param addresses Target addresses\r\n    function settle(uint index, address[] calldata addresses) external payable override {\r\n\r\n        require(index != 0, \"NF:not exist\");\r\n\r\n        // 1. Load the future\r\n        FutureInfo storage fi = _futures[index];\r\n        uint lever = uint(fi.lever);\r\n        require(lever > 1, \"NF:lever must greater than 1\");\r\n\r\n        bool orientation = fi.orientation;\r\n            \r\n        // 2. Query oracle price\r\n        // When call, the base price multiply (1 + k), and the sell price divide (1 + k)\r\n        // When put, the base price divide (1 + k), and the sell price multiply (1 + k)\r\n        // When merger, s0 use recorded price, s1 use corrected by k\r\n        TokenConfig memory tokenConfig = _tokenConfigs[uint(fi.tokenIndex)];\r\n        uint oraclePrice = _queryPrice(0, tokenConfig, !orientation, msg.sender);\r\n\r\n        // 3. Loop and settle\r\n        uint reward = 0;\r\n        for (uint i = addresses.length; i > 0;) {\r\n            address acc = addresses[--i];\r\n\r\n            // 4. Update account\r\n            Account memory account = fi.accounts[acc];\r\n            uint balance = _balanceOf(\r\n                tokenConfig,\r\n                uint(account.balance), \r\n                _decodeFloat(account.basePrice), \r\n                uint(account.baseBlock),\r\n                oraclePrice, \r\n                orientation, \r\n                lever\r\n            );\r\n\r\n            // 5. Settle logic\r\n            // lever is great than 1, and balance less than a regular value, can be liquidated\r\n            // the regular value is: Max(balance * lever * 2%, MIN_VALUE)\r\n            uint minValue = uint(account.balance) * lever / 50;\r\n            if (balance < (minValue < MIN_VALUE ? MIN_VALUE : minValue)) {\r\n                fi.accounts[acc] = Account(uint128(0), uint64(0), uint32(0));\r\n                reward += balance;\r\n                emit Settle(index, acc, msg.sender, balance);\r\n            }\r\n        }\r\n\r\n        // 6. Transfer NEST to user\r\n        if (reward > 0) {\r\n            //DCU(DCU_TOKEN_ADDRESS).mint(msg.sender, reward);\r\n            INestVault(NEST_VAULT_ADDRESS).transferTo(msg.sender, reward);\r\n        }\r\n    }\r\n\r\n    // Compose key by tokenAddress, lever and orientation\r\n    function _getKey(\r\n        address tokenAddress, \r\n        uint lever,\r\n        bool orientation\r\n    ) private pure returns (uint) {\r\n        //return keccak256(abi.encodePacked(tokenAddress, lever, orientation));\r\n        require(lever < 0x100000000, \"NF:lever too large\");\r\n        return (uint(uint160(tokenAddress)) << 96) | (lever << 8) | (orientation ? 1 : 0);\r\n    }\r\n\r\n    // Query price\r\n    function _queryPrice(\r\n        uint nestAmount, \r\n        TokenConfig memory tokenConfig, \r\n        bool enlarge, \r\n        address payback\r\n    ) private returns (uint oraclePrice) {\r\n\r\n        // Query price from oracle\r\n        uint[] memory prices = _lastPriceList(tokenConfig, msg.value, payback);\r\n        \r\n        // Convert to usdt based price\r\n        oraclePrice = prices[1];\r\n        uint k = calcRevisedK(uint(tokenConfig.sigmaSQ), prices[3], prices[2], oraclePrice, prices[0]);\r\n\r\n        // When call, the base price multiply (1 + k), and the sell price divide (1 + k)\r\n        // When put, the base price divide (1 + k), and the sell price multiply (1 + k)\r\n        // When merger, s0 use recorded price, s1 use corrected by k\r\n        if (enlarge) {\r\n            oraclePrice = oraclePrice * (1 ether + k + impactCost(nestAmount)) / 1 ether;\r\n        } else {\r\n            oraclePrice = oraclePrice * 1 ether / (1 ether + k + impactCost(nestAmount));\r\n        }\r\n    }\r\n\r\n    /// @dev Calculate the impact cost\r\n    /// @param vol Trade amount in NEST\r\n    /// @return Impact cost\r\n    function impactCost(uint vol) public pure override returns (uint) {\r\n        //impactCost = vol / 10000 / 1000;\r\n        return vol / 10000000;\r\n    }\r\n\r\n    /// @dev K value is calculated by revised volatility\r\n    /// @param sigmaSQ sigmaSQ for token\r\n    /// @param p0 Last price (number of tokens equivalent to 2000 USD)\r\n    /// @param bn0 Block number of the price p0\r\n    /// @param p Latest price (number of tokens equivalent to 2000 USD)\r\n    /// @param bn The block number of the price p\r\n    function calcRevisedK(uint sigmaSQ, uint p0, uint bn0, uint p, uint bn) public view override returns (uint k) {\r\n        uint sigmaISQ = p * 1 ether / p0;\r\n        if (sigmaISQ > 1 ether) {\r\n            sigmaISQ -= 1 ether;\r\n        } else {\r\n            sigmaISQ = 1 ether - sigmaISQ;\r\n        }\r\n\r\n        // The left part change to: Max((p2 - p1) / p1, 0.002)\r\n        if (sigmaISQ > 0.002 ether) {\r\n            k = sigmaISQ;\r\n        } else {\r\n            k = 0.002 ether;\r\n        }\r\n\r\n        sigmaISQ = sigmaISQ * sigmaISQ / (bn - bn0);\r\n        // sigmaSQ = sigmaSQ * BLOCK_TIME * 1e18 / 1000;\r\n        sigmaSQ = sigmaSQ * BLOCK_TIME * 1e15;\r\n        k += _sqrt((sigmaSQ > sigmaISQ ? sigmaSQ : sigmaISQ) * (block.number - bn));\r\n    }\r\n\r\n    function _sqrt(uint256 x) private pure returns (uint256) {\r\n        unchecked {\r\n            if (x == 0) return 0;\r\n            else {\r\n                uint256 xx = x;\r\n                uint256 r = 1;\r\n                if (xx >= 0x100000000000000000000000000000000) { xx >>= 128; r <<= 64; }\r\n                if (xx >= 0x10000000000000000) { xx >>= 64; r <<= 32; }\r\n                if (xx >= 0x100000000) { xx >>= 32; r <<= 16; }\r\n                if (xx >= 0x10000) { xx >>= 16; r <<= 8; }\r\n                if (xx >= 0x100) { xx >>= 8; r <<= 4; }\r\n                if (xx >= 0x10) { xx >>= 4; r <<= 2; }\r\n                if (xx >= 0x8) { r <<= 1; }\r\n                r = (r + x / r) >> 1;\r\n                r = (r + x / r) >> 1;\r\n                r = (r + x / r) >> 1;\r\n                r = (r + x / r) >> 1;\r\n                r = (r + x / r) >> 1;\r\n                r = (r + x / r) >> 1;\r\n                r = (r + x / r) >> 1; // Seven iterations should be enough\r\n                uint256 r1 = x / r;\r\n                return (r < r1 ? r : r1);\r\n            }\r\n        }\r\n    }\r\n\r\n    /// @dev Encode the uint value as a floating-point representation in the form of fraction * 16 ^ exponent\r\n    /// @param value Destination uint value\r\n    /// @return float format\r\n    function _encodeFloat(uint value) private pure returns (uint64) {\r\n\r\n        uint exponent = 0; \r\n        while (value > 0x3FFFFFFFFFFFFFF) {\r\n            value >>= 4;\r\n            ++exponent;\r\n        }\r\n        return uint64((value << 6) | exponent);\r\n    }\r\n\r\n    /// @dev Decode the floating-point representation of fraction * 16 ^ exponent to uint\r\n    /// @param floatValue fraction value\r\n    /// @return decode format\r\n    function _decodeFloat(uint64 floatValue) private pure returns (uint) {\r\n        return (uint(floatValue) >> 6) << ((uint(floatValue) & 0x3F) << 2);\r\n    }\r\n\r\n    // Convert uint to uint128\r\n    function _toUInt128(uint value) private pure returns (uint128) {\r\n        require(value < 0x100000000000000000000000000000000, \"NF:can't convert to uint128\");\r\n        return uint128(value);\r\n    }\r\n\r\n    // Convert uint to int128\r\n    function _toInt128(uint v) private pure returns (int128) {\r\n        require(v < 0x80000000000000000000000000000000, \"NF:can't convert to int128\");\r\n        return int128(int(v));\r\n    }\r\n\r\n    // Convert int128 to uint\r\n    function _toUInt(int128 v) private pure returns (uint) {\r\n        require(v >= 0, \"NF:can't convert to uint\");\r\n        return uint(int(v));\r\n    }\r\n    \r\n    // Calculate net worth\r\n    function _balanceOf(\r\n        TokenConfig memory tokenConfig,\r\n        uint balance,\r\n        uint basePrice,\r\n        uint baseBlock,\r\n        uint oraclePrice, \r\n        bool ORIENTATION, \r\n        uint LEVER\r\n    ) private view returns (uint) {\r\n\r\n        if (balance > 0) {\r\n            uint left;\r\n            uint right;\r\n            // Call\r\n            if (ORIENTATION) {\r\n                left = balance + (LEVER << 64) * balance * oraclePrice / basePrice\r\n                        / _expMiuT(uint(tokenConfig.miuLong), baseBlock);\r\n                right = balance * LEVER;\r\n            } \r\n            // Put\r\n            else {\r\n                left = balance * (1 + LEVER);\r\n                right = (LEVER << 64) * balance * oraclePrice / basePrice \r\n                        / _expMiuT(uint(tokenConfig.miuShort), baseBlock);\r\n            }\r\n\r\n            if (left > right) {\r\n                balance = left - right;\r\n            } else {\r\n                balance = 0;\r\n            }\r\n        }\r\n\r\n        return balance;\r\n    }\r\n\r\n    // Calculate e^μT\r\n    function _expMiuT(uint miu, uint baseBlock) private view returns (uint) {\r\n        // return _toUInt(ABDKMath64x64.exp(\r\n        //     _toInt128((orientation ? MIU_LONG : MIU_SHORT) * (block.number - baseBlock) * BLOCK_TIME)\r\n        // ));\r\n\r\n        // Using approximate algorithm: x*(1+rt)\r\n        return miu * (block.number - baseBlock) * BLOCK_TIME / 1000 + 0x10000000000000000;\r\n    }\r\n\r\n    // Convert FutureInfo to FutureView\r\n    function _toFutureView(FutureInfo storage fi, uint index, address owner) private view returns (FutureView memory) {\r\n        Account memory account = fi.accounts[owner];\r\n        return FutureView(\r\n            index,\r\n            fi.tokenAddress,\r\n            uint(fi.lever),\r\n            fi.orientation,\r\n            uint(account.balance),\r\n            _decodeFloat(account.basePrice),\r\n            uint(account.baseBlock)\r\n        );\r\n    }\r\n}","ABI":"[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"nestAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"Buy\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"lever\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"orientation\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"New\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Sell\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"reward\",\"type\":\"uint256\"}],\"name\":\"Settle\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"_governance\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"oraclePrice\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"lever\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"orientation\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"nestAmount\",\"type\":\"uint256\"}],\"name\":\"buy\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"nestAmount\",\"type\":\"uint256\"}],\"name\":\"buyDirect\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"sigmaSQ\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"p0\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"bn0\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"p\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"bn\",\"type\":\"uint256\"}],\"name\":\"calcRevisedK\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"k\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"levers\",\"type\":\"uint256[]\"},{\"internalType\":\"bool\",\"name\":\"orientation\",\"type\":\"bool\"}],\"name\":\"create\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"start\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"count\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxFindCount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"find\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"lever\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"orientation\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"basePrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"baseBlock\",\"type\":\"uint256\"}],\"internalType\":\"struct INestFutures.FutureView[]\",\"name\":\"futureArray\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getFutureCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"lever\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"orientation\",\"type\":\"bool\"}],\"name\":\"getFutureInfo\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"lever\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"orientation\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"basePrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"baseBlock\",\"type\":\"uint256\"}],\"internalType\":\"struct INestFutures.FutureView\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"vol\",\"type\":\"uint256\"}],\"name\":\"impactCost\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"governance\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"offset\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"count\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"order\",\"type\":\"uint256\"}],\"name\":\"list\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"lever\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"orientation\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"basePrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"baseBlock\",\"type\":\"uint256\"}],\"internalType\":\"struct INestFutures.FutureView[]\",\"name\":\"futureArray\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"uint16\",\"name\":\"channelId\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"pairIndex\",\"type\":\"uint16\"},{\"internalType\":\"uint64\",\"name\":\"sigmaSQ\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"miuLong\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"miuShort\",\"type\":\"uint64\"}],\"internalType\":\"struct NestPriceAdapter.TokenConfig\",\"name\":\"tokenConfig\",\"type\":\"tuple\"}],\"name\":\"register\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"sell\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"addresses\",\"type\":\"address[]\"}],\"name\":\"settle\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newGovernance\",\"type\":\"address\"}],\"name\":\"update\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"NestFutures","CompilerVersion":"v0.8.15+commit.e14f2714","OptimizationUsed":"1","Runs":"8888","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"GNU GPLv3","Proxy":"0","Implementation":"","SwarmSource":"ipfs://41c5267131517e1cca70ac92759d432c2c5d46ff8f456b97616464f5774736e5"}]}