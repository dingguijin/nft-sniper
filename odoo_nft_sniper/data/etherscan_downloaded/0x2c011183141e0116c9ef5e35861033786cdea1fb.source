{"status":"1","message":"OK","result":[{"SourceCode":"// Sources flattened with hardhat v2.5.0 https://hardhat.org\r\n\r\n// File contracts/libs/ABDKMath64x64.sol\r\n\r\n// SPDX-License-Identifier: BSD-4-Clause\r\n/*\r\n * ABDK Math 64.64 Smart Contract Library.  Copyright Â© 2019 by ABDK Consulting.\r\n * Author: Mikhail Vladimirov <mikhail.vladimirov@gmail.com>\r\n */\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * Smart contract library of mathematical functions operating with signed\r\n * 64.64-bit fixed point numbers.  Signed 64.64-bit fixed point number is\r\n * basically a simple fraction whose numerator is signed 128-bit integer and\r\n * denominator is 2^64.  As long as denominator is always the same, there is no\r\n * need to store it, thus in Solidity signed 64.64-bit fixed point numbers are\r\n * represented by int128 type holding only the numerator.\r\n */\r\nlibrary ABDKMath64x64 {\r\n  /*\r\n   * Minimum value signed 64.64-bit fixed point number may have. \r\n   */\r\n  int128 private constant MIN_64x64 = -0x80000000000000000000000000000000;\r\n\r\n  /*\r\n   * Maximum value signed 64.64-bit fixed point number may have. \r\n   */\r\n  int128 private constant MAX_64x64 = 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\r\n\r\n  /**\r\n   * Convert signed 256-bit integer number into signed 64.64-bit fixed point\r\n   * number.  Revert on overflow.\r\n   *\r\n   * @param x signed 256-bit integer number\r\n   * @return signed 64.64-bit fixed point number\r\n   */\r\n  function fromInt (int256 x) internal pure returns (int128) {\r\n    unchecked {\r\n      require (x >= -0x8000000000000000 && x <= 0x7FFFFFFFFFFFFFFF);\r\n      return int128 (x << 64);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Convert signed 64.64 fixed point number into signed 64-bit integer number\r\n   * rounding down.\r\n   *\r\n   * @param x signed 64.64-bit fixed point number\r\n   * @return signed 64-bit integer number\r\n   */\r\n  function toInt (int128 x) internal pure returns (int64) {\r\n    unchecked {\r\n      return int64 (x >> 64);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Convert unsigned 256-bit integer number into signed 64.64-bit fixed point\r\n   * number.  Revert on overflow.\r\n   *\r\n   * @param x unsigned 256-bit integer number\r\n   * @return signed 64.64-bit fixed point number\r\n   */\r\n  function fromUInt (uint256 x) internal pure returns (int128) {\r\n    unchecked {\r\n      require (x <= 0x7FFFFFFFFFFFFFFF);\r\n      return int128 (int256 (x << 64));\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Convert signed 64.64 fixed point number into unsigned 64-bit integer\r\n   * number rounding down.  Revert on underflow.\r\n   *\r\n   * @param x signed 64.64-bit fixed point number\r\n   * @return unsigned 64-bit integer number\r\n   */\r\n  function toUInt (int128 x) internal pure returns (uint64) {\r\n    unchecked {\r\n      require (x >= 0);\r\n      return uint64 (uint128 (x >> 64));\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Convert signed 128.128 fixed point number into signed 64.64-bit fixed point\r\n   * number rounding down.  Revert on overflow.\r\n   *\r\n   * @param x signed 128.128-bin fixed point number\r\n   * @return signed 64.64-bit fixed point number\r\n   */\r\n  function from128x128 (int256 x) internal pure returns (int128) {\r\n    unchecked {\r\n      int256 result = x >> 64;\r\n      require (result >= MIN_64x64 && result <= MAX_64x64);\r\n      return int128 (result);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Convert signed 64.64 fixed point number into signed 128.128 fixed point\r\n   * number.\r\n   *\r\n   * @param x signed 64.64-bit fixed point number\r\n   * @return signed 128.128 fixed point number\r\n   */\r\n  function to128x128 (int128 x) internal pure returns (int256) {\r\n    unchecked {\r\n      return int256 (x) << 64;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Calculate x + y.  Revert on overflow.\r\n   *\r\n   * @param x signed 64.64-bit fixed point number\r\n   * @param y signed 64.64-bit fixed point number\r\n   * @return signed 64.64-bit fixed point number\r\n   */\r\n  function add (int128 x, int128 y) internal pure returns (int128) {\r\n    unchecked {\r\n      int256 result = int256(x) + y;\r\n      require (result >= MIN_64x64 && result <= MAX_64x64);\r\n      return int128 (result);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Calculate x - y.  Revert on overflow.\r\n   *\r\n   * @param x signed 64.64-bit fixed point number\r\n   * @param y signed 64.64-bit fixed point number\r\n   * @return signed 64.64-bit fixed point number\r\n   */\r\n  function sub (int128 x, int128 y) internal pure returns (int128) {\r\n    unchecked {\r\n      int256 result = int256(x) - y;\r\n      require (result >= MIN_64x64 && result <= MAX_64x64);\r\n      return int128 (result);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Calculate x * y rounding down.  Revert on overflow.\r\n   *\r\n   * @param x signed 64.64-bit fixed point number\r\n   * @param y signed 64.64-bit fixed point number\r\n   * @return signed 64.64-bit fixed point number\r\n   */\r\n  function mul (int128 x, int128 y) internal pure returns (int128) {\r\n    unchecked {\r\n      int256 result = int256(x) * y >> 64;\r\n      require (result >= MIN_64x64 && result <= MAX_64x64);\r\n      return int128 (result);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Calculate x * y rounding towards zero, where x is signed 64.64 fixed point\r\n   * number and y is signed 256-bit integer number.  Revert on overflow.\r\n   *\r\n   * @param x signed 64.64 fixed point number\r\n   * @param y signed 256-bit integer number\r\n   * @return signed 256-bit integer number\r\n   */\r\n  function muli (int128 x, int256 y) internal pure returns (int256) {\r\n    unchecked {\r\n      if (x == MIN_64x64) {\r\n        require (y >= -0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF &&\r\n          y <= 0x1000000000000000000000000000000000000000000000000);\r\n        return -y << 63;\r\n      } else {\r\n        bool negativeResult = false;\r\n        if (x < 0) {\r\n          x = -x;\r\n          negativeResult = true;\r\n        }\r\n        if (y < 0) {\r\n          y = -y; // We rely on overflow behavior here\r\n          negativeResult = !negativeResult;\r\n        }\r\n        uint256 absoluteResult = mulu (x, uint256 (y));\r\n        if (negativeResult) {\r\n          require (absoluteResult <=\r\n            0x8000000000000000000000000000000000000000000000000000000000000000);\r\n          return -int256 (absoluteResult); // We rely on overflow behavior here\r\n        } else {\r\n          require (absoluteResult <=\r\n            0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\r\n          return int256 (absoluteResult);\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Calculate x * y rounding down, where x is signed 64.64 fixed point number\r\n   * and y is unsigned 256-bit integer number.  Revert on overflow.\r\n   *\r\n   * @param x signed 64.64 fixed point number\r\n   * @param y unsigned 256-bit integer number\r\n   * @return unsigned 256-bit integer number\r\n   */\r\n  function mulu (int128 x, uint256 y) internal pure returns (uint256) {\r\n    unchecked {\r\n      if (y == 0) return 0;\r\n\r\n      require (x >= 0);\r\n\r\n      uint256 lo = (uint256 (int256 (x)) * (y & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)) >> 64;\r\n      uint256 hi = uint256 (int256 (x)) * (y >> 128);\r\n\r\n      require (hi <= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\r\n      hi <<= 64;\r\n\r\n      require (hi <=\r\n        0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF - lo);\r\n      return hi + lo;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Calculate x / y rounding towards zero.  Revert on overflow or when y is\r\n   * zero.\r\n   *\r\n   * @param x signed 64.64-bit fixed point number\r\n   * @param y signed 64.64-bit fixed point number\r\n   * @return signed 64.64-bit fixed point number\r\n   */\r\n  function div (int128 x, int128 y) internal pure returns (int128) {\r\n    unchecked {\r\n      require (y != 0);\r\n      int256 result = (int256 (x) << 64) / y;\r\n      require (result >= MIN_64x64 && result <= MAX_64x64);\r\n      return int128 (result);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Calculate x / y rounding towards zero, where x and y are signed 256-bit\r\n   * integer numbers.  Revert on overflow or when y is zero.\r\n   *\r\n   * @param x signed 256-bit integer number\r\n   * @param y signed 256-bit integer number\r\n   * @return signed 64.64-bit fixed point number\r\n   */\r\n  function divi (int256 x, int256 y) internal pure returns (int128) {\r\n    unchecked {\r\n      require (y != 0);\r\n\r\n      bool negativeResult = false;\r\n      if (x < 0) {\r\n        x = -x; // We rely on overflow behavior here\r\n        negativeResult = true;\r\n      }\r\n      if (y < 0) {\r\n        y = -y; // We rely on overflow behavior here\r\n        negativeResult = !negativeResult;\r\n      }\r\n      uint128 absoluteResult = divuu (uint256 (x), uint256 (y));\r\n      if (negativeResult) {\r\n        require (absoluteResult <= 0x80000000000000000000000000000000);\r\n        return -int128 (absoluteResult); // We rely on overflow behavior here\r\n      } else {\r\n        require (absoluteResult <= 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\r\n        return int128 (absoluteResult); // We rely on overflow behavior here\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Calculate x / y rounding towards zero, where x and y are unsigned 256-bit\r\n   * integer numbers.  Revert on overflow or when y is zero.\r\n   *\r\n   * @param x unsigned 256-bit integer number\r\n   * @param y unsigned 256-bit integer number\r\n   * @return signed 64.64-bit fixed point number\r\n   */\r\n  function divu (uint256 x, uint256 y) internal pure returns (int128) {\r\n    unchecked {\r\n      require (y != 0);\r\n      uint128 result = divuu (x, y);\r\n      require (result <= uint128 (MAX_64x64));\r\n      return int128 (result);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Calculate -x.  Revert on overflow.\r\n   *\r\n   * @param x signed 64.64-bit fixed point number\r\n   * @return signed 64.64-bit fixed point number\r\n   */\r\n  function neg (int128 x) internal pure returns (int128) {\r\n    unchecked {\r\n      require (x != MIN_64x64);\r\n      return -x;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Calculate |x|.  Revert on overflow.\r\n   *\r\n   * @param x signed 64.64-bit fixed point number\r\n   * @return signed 64.64-bit fixed point number\r\n   */\r\n  function abs (int128 x) internal pure returns (int128) {\r\n    unchecked {\r\n      require (x != MIN_64x64);\r\n      return x < 0 ? -x : x;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Calculate 1 / x rounding towards zero.  Revert on overflow or when x is\r\n   * zero.\r\n   *\r\n   * @param x signed 64.64-bit fixed point number\r\n   * @return signed 64.64-bit fixed point number\r\n   */\r\n  function inv (int128 x) internal pure returns (int128) {\r\n    unchecked {\r\n      require (x != 0);\r\n      int256 result = int256 (0x100000000000000000000000000000000) / x;\r\n      require (result >= MIN_64x64 && result <= MAX_64x64);\r\n      return int128 (result);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Calculate arithmetics average of x and y, i.e. (x + y) / 2 rounding down.\r\n   *\r\n   * @param x signed 64.64-bit fixed point number\r\n   * @param y signed 64.64-bit fixed point number\r\n   * @return signed 64.64-bit fixed point number\r\n   */\r\n  function avg (int128 x, int128 y) internal pure returns (int128) {\r\n    unchecked {\r\n      return int128 ((int256 (x) + int256 (y)) >> 1);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Calculate geometric average of x and y, i.e. sqrt (x * y) rounding down.\r\n   * Revert on overflow or in case x * y is negative.\r\n   *\r\n   * @param x signed 64.64-bit fixed point number\r\n   * @param y signed 64.64-bit fixed point number\r\n   * @return signed 64.64-bit fixed point number\r\n   */\r\n  function gavg (int128 x, int128 y) internal pure returns (int128) {\r\n    unchecked {\r\n      int256 m = int256 (x) * int256 (y);\r\n      require (m >= 0);\r\n      require (m <\r\n          0x4000000000000000000000000000000000000000000000000000000000000000);\r\n      return int128 (sqrtu (uint256 (m)));\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Calculate x^y assuming 0^0 is 1, where x is signed 64.64 fixed point number\r\n   * and y is unsigned 256-bit integer number.  Revert on overflow.\r\n   *\r\n   * @param x signed 64.64-bit fixed point number\r\n   * @param y uint256 value\r\n   * @return signed 64.64-bit fixed point number\r\n   */\r\n  function pow (int128 x, uint256 y) internal pure returns (int128) {\r\n    unchecked {\r\n      bool negative = x < 0 && y & 1 == 1;\r\n\r\n      uint256 absX = uint128 (x < 0 ? -x : x);\r\n      uint256 absResult;\r\n      absResult = 0x100000000000000000000000000000000;\r\n\r\n      if (absX <= 0x10000000000000000) {\r\n        absX <<= 63;\r\n        while (y != 0) {\r\n          if (y & 0x1 != 0) {\r\n            absResult = absResult * absX >> 127;\r\n          }\r\n          absX = absX * absX >> 127;\r\n\r\n          if (y & 0x2 != 0) {\r\n            absResult = absResult * absX >> 127;\r\n          }\r\n          absX = absX * absX >> 127;\r\n\r\n          if (y & 0x4 != 0) {\r\n            absResult = absResult * absX >> 127;\r\n          }\r\n          absX = absX * absX >> 127;\r\n\r\n          if (y & 0x8 != 0) {\r\n            absResult = absResult * absX >> 127;\r\n          }\r\n          absX = absX * absX >> 127;\r\n\r\n          y >>= 4;\r\n        }\r\n\r\n        absResult >>= 64;\r\n      } else {\r\n        uint256 absXShift = 63;\r\n        if (absX < 0x1000000000000000000000000) { absX <<= 32; absXShift -= 32; }\r\n        if (absX < 0x10000000000000000000000000000) { absX <<= 16; absXShift -= 16; }\r\n        if (absX < 0x1000000000000000000000000000000) { absX <<= 8; absXShift -= 8; }\r\n        if (absX < 0x10000000000000000000000000000000) { absX <<= 4; absXShift -= 4; }\r\n        if (absX < 0x40000000000000000000000000000000) { absX <<= 2; absXShift -= 2; }\r\n        if (absX < 0x80000000000000000000000000000000) { absX <<= 1; absXShift -= 1; }\r\n\r\n        uint256 resultShift = 0;\r\n        while (y != 0) {\r\n          require (absXShift < 64);\r\n\r\n          if (y & 0x1 != 0) {\r\n            absResult = absResult * absX >> 127;\r\n            resultShift += absXShift;\r\n            if (absResult > 0x100000000000000000000000000000000) {\r\n              absResult >>= 1;\r\n              resultShift += 1;\r\n            }\r\n          }\r\n          absX = absX * absX >> 127;\r\n          absXShift <<= 1;\r\n          if (absX >= 0x100000000000000000000000000000000) {\r\n              absX >>= 1;\r\n              absXShift += 1;\r\n          }\r\n\r\n          y >>= 1;\r\n        }\r\n\r\n        require (resultShift < 64);\r\n        absResult >>= 64 - resultShift;\r\n      }\r\n      int256 result = negative ? -int256 (absResult) : int256 (absResult);\r\n      require (result >= MIN_64x64 && result <= MAX_64x64);\r\n      return int128 (result);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Calculate sqrt (x) rounding down.  Revert if x < 0.\r\n   *\r\n   * @param x signed 64.64-bit fixed point number\r\n   * @return signed 64.64-bit fixed point number\r\n   */\r\n  function sqrt (int128 x) internal pure returns (int128) {\r\n    unchecked {\r\n      require (x >= 0);\r\n      return int128 (sqrtu (uint256 (int256 (x)) << 64));\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Calculate binary logarithm of x.  Revert if x <= 0.\r\n   *\r\n   * @param x signed 64.64-bit fixed point number\r\n   * @return signed 64.64-bit fixed point number\r\n   */\r\n  function log_2 (int128 x) internal pure returns (int128) {\r\n    unchecked {\r\n      require (x > 0);\r\n\r\n      int256 msb = 0;\r\n      int256 xc = x;\r\n      if (xc >= 0x10000000000000000) { xc >>= 64; msb += 64; }\r\n      if (xc >= 0x100000000) { xc >>= 32; msb += 32; }\r\n      if (xc >= 0x10000) { xc >>= 16; msb += 16; }\r\n      if (xc >= 0x100) { xc >>= 8; msb += 8; }\r\n      if (xc >= 0x10) { xc >>= 4; msb += 4; }\r\n      if (xc >= 0x4) { xc >>= 2; msb += 2; }\r\n      if (xc >= 0x2) msb += 1;  // No need to shift xc anymore\r\n\r\n      int256 result = msb - 64 << 64;\r\n      uint256 ux = uint256 (int256 (x)) << uint256 (127 - msb);\r\n      for (int256 bit = 0x8000000000000000; bit > 0; bit >>= 1) {\r\n        ux *= ux;\r\n        uint256 b = ux >> 255;\r\n        ux >>= 127 + b;\r\n        result += bit * int256 (b);\r\n      }\r\n\r\n      return int128 (result);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Calculate natural logarithm of x.  Revert if x <= 0.\r\n   *\r\n   * @param x signed 64.64-bit fixed point number\r\n   * @return signed 64.64-bit fixed point number\r\n   */\r\n  function ln (int128 x) internal pure returns (int128) {\r\n    unchecked {\r\n      require (x > 0);\r\n\r\n      return int128 (int256 (\r\n          uint256 (int256 (log_2 (x))) * 0xB17217F7D1CF79ABC9E3B39803F2F6AF >> 128));\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Calculate binary exponent of x.  Revert on overflow.\r\n   *\r\n   * @param x signed 64.64-bit fixed point number\r\n   * @return signed 64.64-bit fixed point number\r\n   */\r\n  function exp_2 (int128 x) internal pure returns (int128) {\r\n    unchecked {\r\n      require (x < 0x400000000000000000); // Overflow\r\n\r\n      if (x < -0x400000000000000000) return 0; // Underflow\r\n\r\n      uint256 result = 0x80000000000000000000000000000000;\r\n\r\n      if (x & 0x8000000000000000 > 0)\r\n        result = result * 0x16A09E667F3BCC908B2FB1366EA957D3E >> 128;\r\n      if (x & 0x4000000000000000 > 0)\r\n        result = result * 0x1306FE0A31B7152DE8D5A46305C85EDEC >> 128;\r\n      if (x & 0x2000000000000000 > 0)\r\n        result = result * 0x1172B83C7D517ADCDF7C8C50EB14A791F >> 128;\r\n      if (x & 0x1000000000000000 > 0)\r\n        result = result * 0x10B5586CF9890F6298B92B71842A98363 >> 128;\r\n      if (x & 0x800000000000000 > 0)\r\n        result = result * 0x1059B0D31585743AE7C548EB68CA417FD >> 128;\r\n      if (x & 0x400000000000000 > 0)\r\n        result = result * 0x102C9A3E778060EE6F7CACA4F7A29BDE8 >> 128;\r\n      if (x & 0x200000000000000 > 0)\r\n        result = result * 0x10163DA9FB33356D84A66AE336DCDFA3F >> 128;\r\n      if (x & 0x100000000000000 > 0)\r\n        result = result * 0x100B1AFA5ABCBED6129AB13EC11DC9543 >> 128;\r\n      if (x & 0x80000000000000 > 0)\r\n        result = result * 0x10058C86DA1C09EA1FF19D294CF2F679B >> 128;\r\n      if (x & 0x40000000000000 > 0)\r\n        result = result * 0x1002C605E2E8CEC506D21BFC89A23A00F >> 128;\r\n      if (x & 0x20000000000000 > 0)\r\n        result = result * 0x100162F3904051FA128BCA9C55C31E5DF >> 128;\r\n      if (x & 0x10000000000000 > 0)\r\n        result = result * 0x1000B175EFFDC76BA38E31671CA939725 >> 128;\r\n      if (x & 0x8000000000000 > 0)\r\n        result = result * 0x100058BA01FB9F96D6CACD4B180917C3D >> 128;\r\n      if (x & 0x4000000000000 > 0)\r\n        result = result * 0x10002C5CC37DA9491D0985C348C68E7B3 >> 128;\r\n      if (x & 0x2000000000000 > 0)\r\n        result = result * 0x1000162E525EE054754457D5995292026 >> 128;\r\n      if (x & 0x1000000000000 > 0)\r\n        result = result * 0x10000B17255775C040618BF4A4ADE83FC >> 128;\r\n      if (x & 0x800000000000 > 0)\r\n        result = result * 0x1000058B91B5BC9AE2EED81E9B7D4CFAB >> 128;\r\n      if (x & 0x400000000000 > 0)\r\n        result = result * 0x100002C5C89D5EC6CA4D7C8ACC017B7C9 >> 128;\r\n      if (x & 0x200000000000 > 0)\r\n        result = result * 0x10000162E43F4F831060E02D839A9D16D >> 128;\r\n      if (x & 0x100000000000 > 0)\r\n        result = result * 0x100000B1721BCFC99D9F890EA06911763 >> 128;\r\n      if (x & 0x80000000000 > 0)\r\n        result = result * 0x10000058B90CF1E6D97F9CA14DBCC1628 >> 128;\r\n      if (x & 0x40000000000 > 0)\r\n        result = result * 0x1000002C5C863B73F016468F6BAC5CA2B >> 128;\r\n      if (x & 0x20000000000 > 0)\r\n        result = result * 0x100000162E430E5A18F6119E3C02282A5 >> 128;\r\n      if (x & 0x10000000000 > 0)\r\n        result = result * 0x1000000B1721835514B86E6D96EFD1BFE >> 128;\r\n      if (x & 0x8000000000 > 0)\r\n        result = result * 0x100000058B90C0B48C6BE5DF846C5B2EF >> 128;\r\n      if (x & 0x4000000000 > 0)\r\n        result = result * 0x10000002C5C8601CC6B9E94213C72737A >> 128;\r\n      if (x & 0x2000000000 > 0)\r\n        result = result * 0x1000000162E42FFF037DF38AA2B219F06 >> 128;\r\n      if (x & 0x1000000000 > 0)\r\n        result = result * 0x10000000B17217FBA9C739AA5819F44F9 >> 128;\r\n      if (x & 0x800000000 > 0)\r\n        result = result * 0x1000000058B90BFCDEE5ACD3C1CEDC823 >> 128;\r\n      if (x & 0x400000000 > 0)\r\n        result = result * 0x100000002C5C85FE31F35A6A30DA1BE50 >> 128;\r\n      if (x & 0x200000000 > 0)\r\n        result = result * 0x10000000162E42FF0999CE3541B9FFFCF >> 128;\r\n      if (x & 0x100000000 > 0)\r\n        result = result * 0x100000000B17217F80F4EF5AADDA45554 >> 128;\r\n      if (x & 0x80000000 > 0)\r\n        result = result * 0x10000000058B90BFBF8479BD5A81B51AD >> 128;\r\n      if (x & 0x40000000 > 0)\r\n        result = result * 0x1000000002C5C85FDF84BD62AE30A74CC >> 128;\r\n      if (x & 0x20000000 > 0)\r\n        result = result * 0x100000000162E42FEFB2FED257559BDAA >> 128;\r\n      if (x & 0x10000000 > 0)\r\n        result = result * 0x1000000000B17217F7D5A7716BBA4A9AE >> 128;\r\n      if (x & 0x8000000 > 0)\r\n        result = result * 0x100000000058B90BFBE9DDBAC5E109CCE >> 128;\r\n      if (x & 0x4000000 > 0)\r\n        result = result * 0x10000000002C5C85FDF4B15DE6F17EB0D >> 128;\r\n      if (x & 0x2000000 > 0)\r\n        result = result * 0x1000000000162E42FEFA494F1478FDE05 >> 128;\r\n      if (x & 0x1000000 > 0)\r\n        result = result * 0x10000000000B17217F7D20CF927C8E94C >> 128;\r\n      if (x & 0x800000 > 0)\r\n        result = result * 0x1000000000058B90BFBE8F71CB4E4B33D >> 128;\r\n      if (x & 0x400000 > 0)\r\n        result = result * 0x100000000002C5C85FDF477B662B26945 >> 128;\r\n      if (x & 0x200000 > 0)\r\n        result = result * 0x10000000000162E42FEFA3AE53369388C >> 128;\r\n      if (x & 0x100000 > 0)\r\n        result = result * 0x100000000000B17217F7D1D351A389D40 >> 128;\r\n      if (x & 0x80000 > 0)\r\n        result = result * 0x10000000000058B90BFBE8E8B2D3D4EDE >> 128;\r\n      if (x & 0x40000 > 0)\r\n        result = result * 0x1000000000002C5C85FDF4741BEA6E77E >> 128;\r\n      if (x & 0x20000 > 0)\r\n        result = result * 0x100000000000162E42FEFA39FE95583C2 >> 128;\r\n      if (x & 0x10000 > 0)\r\n        result = result * 0x1000000000000B17217F7D1CFB72B45E1 >> 128;\r\n      if (x & 0x8000 > 0)\r\n        result = result * 0x100000000000058B90BFBE8E7CC35C3F0 >> 128;\r\n      if (x & 0x4000 > 0)\r\n        result = result * 0x10000000000002C5C85FDF473E242EA38 >> 128;\r\n      if (x & 0x2000 > 0)\r\n        result = result * 0x1000000000000162E42FEFA39F02B772C >> 128;\r\n      if (x & 0x1000 > 0)\r\n        result = result * 0x10000000000000B17217F7D1CF7D83C1A >> 128;\r\n      if (x & 0x800 > 0)\r\n        result = result * 0x1000000000000058B90BFBE8E7BDCBE2E >> 128;\r\n      if (x & 0x400 > 0)\r\n        result = result * 0x100000000000002C5C85FDF473DEA871F >> 128;\r\n      if (x & 0x200 > 0)\r\n        result = result * 0x10000000000000162E42FEFA39EF44D91 >> 128;\r\n      if (x & 0x100 > 0)\r\n        result = result * 0x100000000000000B17217F7D1CF79E949 >> 128;\r\n      if (x & 0x80 > 0)\r\n        result = result * 0x10000000000000058B90BFBE8E7BCE544 >> 128;\r\n      if (x & 0x40 > 0)\r\n        result = result * 0x1000000000000002C5C85FDF473DE6ECA >> 128;\r\n      if (x & 0x20 > 0)\r\n        result = result * 0x100000000000000162E42FEFA39EF366F >> 128;\r\n      if (x & 0x10 > 0)\r\n        result = result * 0x1000000000000000B17217F7D1CF79AFA >> 128;\r\n      if (x & 0x8 > 0)\r\n        result = result * 0x100000000000000058B90BFBE8E7BCD6D >> 128;\r\n      if (x & 0x4 > 0)\r\n        result = result * 0x10000000000000002C5C85FDF473DE6B2 >> 128;\r\n      if (x & 0x2 > 0)\r\n        result = result * 0x1000000000000000162E42FEFA39EF358 >> 128;\r\n      if (x & 0x1 > 0)\r\n        result = result * 0x10000000000000000B17217F7D1CF79AB >> 128;\r\n\r\n      result >>= uint256 (int256 (63 - (x >> 64)));\r\n      require (result <= uint256 (int256 (MAX_64x64)));\r\n\r\n      return int128 (int256 (result));\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Calculate natural exponent of x.  Revert on overflow.\r\n   *\r\n   * @param x signed 64.64-bit fixed point number\r\n   * @return signed 64.64-bit fixed point number\r\n   */\r\n  function exp (int128 x) internal pure returns (int128) {\r\n    unchecked {\r\n      require (x < 0x400000000000000000); // Overflow\r\n\r\n      if (x < -0x400000000000000000) return 0; // Underflow\r\n\r\n      return exp_2 (\r\n          int128 (int256 (x) * 0x171547652B82FE1777D0FFDA0D23A7D12 >> 128));\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Calculate x / y rounding towards zero, where x and y are unsigned 256-bit\r\n   * integer numbers.  Revert on overflow or when y is zero.\r\n   *\r\n   * @param x unsigned 256-bit integer number\r\n   * @param y unsigned 256-bit integer number\r\n   * @return unsigned 64.64-bit fixed point number\r\n   */\r\n  function divuu (uint256 x, uint256 y) private pure returns (uint128) {\r\n    unchecked {\r\n      require (y != 0);\r\n\r\n      uint256 result;\r\n\r\n      if (x <= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)\r\n        result = (x << 64) / y;\r\n      else {\r\n        uint256 msb = 192;\r\n        uint256 xc = x >> 192;\r\n        if (xc >= 0x100000000) { xc >>= 32; msb += 32; }\r\n        if (xc >= 0x10000) { xc >>= 16; msb += 16; }\r\n        if (xc >= 0x100) { xc >>= 8; msb += 8; }\r\n        if (xc >= 0x10) { xc >>= 4; msb += 4; }\r\n        if (xc >= 0x4) { xc >>= 2; msb += 2; }\r\n        if (xc >= 0x2) msb += 1;  // No need to shift xc anymore\r\n\r\n        result = (x << 255 - msb) / ((y - 1 >> msb - 191) + 1);\r\n        require (result <= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\r\n\r\n        uint256 hi = result * (y >> 128);\r\n        uint256 lo = result * (y & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\r\n\r\n        uint256 xh = x >> 192;\r\n        uint256 xl = x << 64;\r\n\r\n        if (xl < lo) xh -= 1;\r\n        xl -= lo; // We rely on overflow behavior here\r\n        lo = hi << 128;\r\n        if (xl < lo) xh -= 1;\r\n        xl -= lo; // We rely on overflow behavior here\r\n\r\n        assert (xh == hi >> 128);\r\n\r\n        result += xl / y;\r\n      }\r\n\r\n      require (result <= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\r\n      return uint128 (result);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Calculate sqrt (x) rounding down, where x is unsigned 256-bit integer\r\n   * number.\r\n   *\r\n   * @param x unsigned 256-bit integer number\r\n   * @return unsigned 128-bit integer number\r\n   */\r\n  function sqrtu (uint256 x) private pure returns (uint128) {\r\n    unchecked {\r\n      if (x == 0) return 0;\r\n      else {\r\n        uint256 xx = x;\r\n        uint256 r = 1;\r\n        if (xx >= 0x100000000000000000000000000000000) { xx >>= 128; r <<= 64; }\r\n        if (xx >= 0x10000000000000000) { xx >>= 64; r <<= 32; }\r\n        if (xx >= 0x100000000) { xx >>= 32; r <<= 16; }\r\n        if (xx >= 0x10000) { xx >>= 16; r <<= 8; }\r\n        if (xx >= 0x100) { xx >>= 8; r <<= 4; }\r\n        if (xx >= 0x10) { xx >>= 4; r <<= 2; }\r\n        if (xx >= 0x8) { r <<= 1; }\r\n        r = (r + x / r) >> 1;\r\n        r = (r + x / r) >> 1;\r\n        r = (r + x / r) >> 1;\r\n        r = (r + x / r) >> 1;\r\n        r = (r + x / r) >> 1;\r\n        r = (r + x / r) >> 1;\r\n        r = (r + x / r) >> 1; // Seven iterations should be enough\r\n        uint256 r1 = x / r;\r\n        return uint128 (r < r1 ? r : r1);\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\n\r\n// File contracts/libs/TransferHelper.sol\r\n\r\n// GPL-3.0-or-later\r\n\r\npragma solidity ^0.8.6;\r\n\r\n// helper methods for interacting with ERC20 tokens and sending ETH that do not consistently return true/false\r\nlibrary TransferHelper {\r\n    function safeApprove(address token, address to, uint value) internal {\r\n        // bytes4(keccak256(bytes('approve(address,uint)')));\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: APPROVE_FAILED');\r\n    }\r\n\r\n    function safeTransfer(address token, address to, uint value) internal {\r\n        // bytes4(keccak256(bytes('transfer(address,uint)')));\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FAILED');\r\n    }\r\n\r\n    function safeTransferFrom(address token, address from, address to, uint value) internal {\r\n        // bytes4(keccak256(bytes('transferFrom(address,address,uint)')));\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FROM_FAILED');\r\n    }\r\n\r\n    function safeTransferETH(address to, uint value) internal {\r\n        (bool success,) = to.call{value:value,gas:5000}(new bytes(0));\r\n        require(success, 'TransferHelper: ETH_TRANSFER_FAILED');\r\n    }\r\n}\r\n\r\n\r\n// File contracts/interfaces/INestOptions.sol\r\n\r\n// GPL-3.0-or-later\r\n\r\npragma solidity ^0.8.6;\r\n\r\n/// @dev Define methods for european option\r\ninterface INestOptions {\r\n    \r\n    /// @dev Option structure for view methods\r\n    struct OptionView {\r\n        uint index;\r\n        address tokenAddress;\r\n        uint strikePrice;\r\n        bool orientation;\r\n        uint exerciseBlock;\r\n        uint balance;\r\n        address owner;\r\n    }\r\n    \r\n    /// @dev Option open event\r\n    /// @param index Index of option\r\n    /// @param nestAmount Amount of paid NEST\r\n    /// @param owner Owner of this option\r\n    /// @param amount Amount of option\r\n    event Open(\r\n        uint index,\r\n        uint nestAmount,\r\n        address owner,\r\n        uint amount\r\n    );\r\n\r\n    /// @dev Option exercise event\r\n    /// @param index Index of option\r\n    /// @param amount Amount of option to exercise\r\n    /// @param owner Owner of this option\r\n    /// @param gain Amount of NEST gained\r\n    event Exercise(uint index, uint amount, address owner, uint gain);\r\n    \r\n    /// @dev Option sell event\r\n    /// @param index Index of option\r\n    /// @param amount Amount of option to sell\r\n    /// @param owner Owner of this option\r\n    /// @param nestAmount Amount of NEST acquired\r\n    event Sell(uint index, uint amount, address owner, uint nestAmount);\r\n\r\n    /// @dev Returns the share of the specified option for target address\r\n    /// @param index Index of the option\r\n    /// @param addr Target address (This argument is useless, consider to remove)\r\n    function balanceOf(uint index, address addr) external view returns (uint);\r\n\r\n    /// @dev Find the options of the owner (in reverse order)\r\n    /// @param start Find forward from the index corresponding to the given owner address \r\n    /// (excluding the record corresponding to start)\r\n    /// @param count Maximum number of records returned\r\n    /// @param maxFindCount Find records at most\r\n    /// @param owner Target address\r\n    /// @return optionArray Matched options\r\n    function find(\r\n        uint start, \r\n        uint count, \r\n        uint maxFindCount, \r\n        address owner\r\n    ) external view returns (OptionView[] memory optionArray);\r\n\r\n    /// @dev List options\r\n    /// @param offset Skip previous (offset) records\r\n    /// @param count Return (count) records\r\n    /// @param order Order. 0 reverse order, non-0 positive order\r\n    /// @return optionArray Matched option array\r\n    function list(uint offset, uint count, uint order) external view returns (OptionView[] memory optionArray);\r\n    \r\n    /// @dev Obtain the number of European options that have been opened\r\n    /// @return Number of European options opened\r\n    function getOptionCount() external view returns (uint);\r\n\r\n    /// @dev Estimate the amount of option\r\n    /// @param tokenAddress Target token address, 0 means eth\r\n    /// @param oraclePrice Current price from oracle\r\n    /// @param strikePrice The exercise price set by the user. During settlement, the system will compare the \r\n    /// current price of the subject matter with the exercise price to calculate the user's profit and loss\r\n    /// @param orientation true: call, false: put\r\n    /// @param exerciseBlock After reaching this block, the user will exercise manually, and the block will be\r\n    /// recorded in the system using the block number\r\n    /// @param nestAmount Amount of paid NEST\r\n    /// @return amount Amount of option\r\n    function estimate(\r\n        address tokenAddress,\r\n        uint oraclePrice,\r\n        uint strikePrice,\r\n        bool orientation,\r\n        uint exerciseBlock,\r\n        uint nestAmount\r\n    ) external view returns (uint amount);\r\n\r\n    /// @dev Open option\r\n    /// @param tokenAddress Target token address, 0 means eth\r\n    /// @param strikePrice The exercise price set by the user. During settlement, the system will compare the \r\n    /// current price of the subject matter with the exercise price to calculate the user's profit and loss\r\n    /// @param orientation true: call, false: put\r\n    /// @param exerciseBlock After reaching this block, the user will exercise manually, and the block will be\r\n    /// recorded in the system using the block number\r\n    /// @param nestAmount Amount of paid NEST\r\n    function open(\r\n        address tokenAddress,\r\n        uint strikePrice,\r\n        bool orientation,\r\n        uint exerciseBlock,\r\n        uint nestAmount\r\n    ) external payable;\r\n\r\n    /// @dev Exercise option\r\n    /// @param index Index of option\r\n    /// @param amount Amount of option to exercise\r\n    function exercise(uint index, uint amount) external payable;\r\n\r\n    /// @dev Sell option\r\n    /// @param index Index of option\r\n    /// @param amount Amount of option to sell\r\n    function sell(uint index, uint amount) external payable;\r\n\r\n    /// @dev Calculate option price\r\n    /// @param oraclePrice Current price from oracle\r\n    /// @param strikePrice The exercise price set by the user. During settlement, the system will compare the \r\n    /// current price of the subject matter with the exercise price to calculate the user's profit and loss\r\n    /// @param orientation true: call, false: put\r\n    /// @param exerciseBlock After reaching this block, the user will exercise manually, and the block will be\r\n    /// recorded in the system using the block number\r\n    /// @return v Option price. Need to divide (USDT_BASE << 64)\r\n    function calcV(\r\n        address tokenAddress,\r\n        uint oraclePrice,\r\n        uint strikePrice,\r\n        bool orientation,\r\n        uint exerciseBlock\r\n    ) external view returns (uint v);\r\n}\r\n\r\n\r\n// File contracts/interfaces/INestVault.sol\r\n\r\n// GPL-3.0-or-later\r\n\r\npragma solidity ^0.8.6;\r\n\r\n/// @dev Defines methods for Nest Vault\r\ninterface INestVault {\r\n\r\n    /// @dev Approve allowance amount to target contract address\r\n    /// @dev target Target contract address\r\n    /// @dev limit Amount limit can transferred once\r\n    function approve(address target, uint limit) external;\r\n\r\n    /// @dev Transfer to by allowance\r\n    /// @param to Target receive address\r\n    /// @param amount Transfer amount\r\n    function transferTo(address to, uint amount) external;\r\n}\r\n\r\n\r\n// File contracts/custom/ChainParameter.sol\r\n\r\n// GPL-3.0-or-later\r\n\r\npragma solidity ^0.8.6;\r\n\r\n/// @dev Specific parameters for target chain\r\ncontract ChainParameter {\r\n    \r\n    // ETH:\r\n    // Block average time in milliseconds. ethereum 14 seconds, BSC 3 seconds, polygon 2.2 seconds, KCC 3 seconds\r\n    uint constant BLOCK_TIME = 14000;\r\n    // Minimal exercise block period. 180000\r\n    uint constant MIN_PERIOD = 180000;\r\n    // Minimal exercise block period for NestLPGuarantee. 180000\r\n    uint constant MIN_EXERCISE_BLOCK = 180000;\r\n\r\n    // // BSC:\r\n    // // Block average time in milliseconds. ethereum 14 seconds, BSC 3 seconds, polygon 2.2 seconds, KCC 3 seconds\r\n    // uint constant BLOCK_TIME = 3000;\r\n    // // Minimal exercise block period. 840000\r\n    // uint constant MIN_PERIOD = 840000;\r\n    // // Minimal exercise block period for NestLPGuarantee. 840000\r\n    // uint constant MIN_EXERCISE_BLOCK = 840000;\r\n\r\n    // // Polygon:\r\n    // // Block average time in milliseconds. ethereum 14 seconds, BSC 3 seconds, polygon 2.2 seconds, KCC 3 seconds\r\n    // uint constant BLOCK_TIME = 2200;\r\n    // // Minimal exercise block period. 1200000\r\n    // uint constant MIN_PERIOD = 1200000;\r\n    // // Minimal exercise block period for NestLPGuarantee. 1200000\r\n    // uint constant MIN_EXERCISE_BLOCK = 1200000;\r\n\r\n    // // KCC:\r\n    // // Block average time in milliseconds. ethereum 14 seconds, BSC 3 seconds, polygon 2.2 seconds, KCC 3 seconds\r\n    // uint constant BLOCK_TIME = 3000;\r\n    // // Minimal exercise block period. 840000\r\n    // uint constant MIN_PERIOD = 840000;\r\n    // // Minimal exercise block period for NestLPGuarantee. 840000\r\n    // uint constant MIN_EXERCISE_BLOCK = 840000;\r\n}\r\n\r\n\r\n// File contracts/interfaces/INestMapping.sol\r\n\r\n// GPL-3.0-or-later\r\n\r\npragma solidity ^0.8.6;\r\n\r\n/// @dev The interface defines methods for nest builtin contract address mapping\r\ninterface INestMapping {\r\n\r\n    /// @dev Set the built-in contract address of the system\r\n    /// @param nestTokenAddress Address of nest token contract\r\n    /// @param nestNodeAddress Address of nest node contract\r\n    /// @param nestLedgerAddress INestLedger implementation contract address\r\n    /// @param nestMiningAddress INestMining implementation contract address for nest\r\n    /// @param ntokenMiningAddress INestMining implementation contract address for ntoken\r\n    /// @param nestPriceFacadeAddress INestPriceFacade implementation contract address\r\n    /// @param nestVoteAddress INestVote implementation contract address\r\n    /// @param nestQueryAddress INestQuery implementation contract address\r\n    /// @param nnIncomeAddress NNIncome contract address\r\n    /// @param nTokenControllerAddress INTokenController implementation contract address\r\n    function setBuiltinAddress(\r\n        address nestTokenAddress,\r\n        address nestNodeAddress,\r\n        address nestLedgerAddress,\r\n        address nestMiningAddress,\r\n        address ntokenMiningAddress,\r\n        address nestPriceFacadeAddress,\r\n        address nestVoteAddress,\r\n        address nestQueryAddress,\r\n        address nnIncomeAddress,\r\n        address nTokenControllerAddress\r\n    ) external;\r\n\r\n    /// @dev Get the built-in contract address of the system\r\n    /// @return nestTokenAddress Address of nest token contract\r\n    /// @return nestNodeAddress Address of nest node contract\r\n    /// @return nestLedgerAddress INestLedger implementation contract address\r\n    /// @return nestMiningAddress INestMining implementation contract address for nest\r\n    /// @return ntokenMiningAddress INestMining implementation contract address for ntoken\r\n    /// @return nestPriceFacadeAddress INestPriceFacade implementation contract address\r\n    /// @return nestVoteAddress INestVote implementation contract address\r\n    /// @return nestQueryAddress INestQuery implementation contract address\r\n    /// @return nnIncomeAddress NNIncome contract address\r\n    /// @return nTokenControllerAddress INTokenController implementation contract address\r\n    function getBuiltinAddress() external view returns (\r\n        address nestTokenAddress,\r\n        address nestNodeAddress,\r\n        address nestLedgerAddress,\r\n        address nestMiningAddress,\r\n        address ntokenMiningAddress,\r\n        address nestPriceFacadeAddress,\r\n        address nestVoteAddress,\r\n        address nestQueryAddress,\r\n        address nnIncomeAddress,\r\n        address nTokenControllerAddress\r\n    );\r\n\r\n    /// @dev Get address of nest token contract\r\n    /// @return Address of nest token contract\r\n    function getNestTokenAddress() external view returns (address);\r\n\r\n    /// @dev Get address of nest node contract\r\n    /// @return Address of nest node contract\r\n    function getNestNodeAddress() external view returns (address);\r\n\r\n    /// @dev Get INestLedger implementation contract address\r\n    /// @return INestLedger implementation contract address\r\n    function getNestLedgerAddress() external view returns (address);\r\n\r\n    /// @dev Get INestMining implementation contract address for nest\r\n    /// @return INestMining implementation contract address for nest\r\n    function getNestMiningAddress() external view returns (address);\r\n\r\n    /// @dev Get INestMining implementation contract address for ntoken\r\n    /// @return INestMining implementation contract address for ntoken\r\n    function getNTokenMiningAddress() external view returns (address);\r\n\r\n    /// @dev Get INestPriceFacade implementation contract address\r\n    /// @return INestPriceFacade implementation contract address\r\n    function getNestPriceFacadeAddress() external view returns (address);\r\n\r\n    /// @dev Get INestVote implementation contract address\r\n    /// @return INestVote implementation contract address\r\n    function getNestVoteAddress() external view returns (address);\r\n\r\n    /// @dev Get INestQuery implementation contract address\r\n    /// @return INestQuery implementation contract address\r\n    function getNestQueryAddress() external view returns (address);\r\n\r\n    /// @dev Get NNIncome contract address\r\n    /// @return NNIncome contract address\r\n    function getNnIncomeAddress() external view returns (address);\r\n\r\n    /// @dev Get INTokenController implementation contract address\r\n    /// @return INTokenController implementation contract address\r\n    function getNTokenControllerAddress() external view returns (address);\r\n\r\n    /// @dev Registered address. The address registered here is the address accepted by nest system\r\n    /// @param key The key\r\n    /// @param addr Destination address. 0 means to delete the registration information\r\n    function registerAddress(string memory key, address addr) external;\r\n\r\n    /// @dev Get registered address\r\n    /// @param key The key\r\n    /// @return Destination address. 0 means empty\r\n    function checkAddress(string memory key) external view returns (address);\r\n}\r\n\r\n\r\n// File contracts/interfaces/INestGovernance.sol\r\n\r\n// GPL-3.0-or-later\r\n\r\npragma solidity ^0.8.6;\r\n/// @dev This interface defines the governance methods\r\ninterface INestGovernance is INestMapping {\r\n\r\n    /// @dev Set governance authority\r\n    /// @param addr Destination address\r\n    /// @param flag Weight. 0 means to delete the governance permission of the target address. Weight is not \r\n    ///        implemented in the current system, only the difference between authorized and unauthorized. \r\n    ///        Here, a uint96 is used to represent the weight, which is only reserved for expansion\r\n    function setGovernance(address addr, uint flag) external;\r\n\r\n    /// @dev Get governance rights\r\n    /// @param addr Destination address\r\n    /// @return Weight. 0 means to delete the governance permission of the target address. Weight is not \r\n    ///        implemented in the current system, only the difference between authorized and unauthorized. \r\n    ///        Here, a uint96 is used to represent the weight, which is only reserved for expansion\r\n    function getGovernance(address addr) external view returns (uint);\r\n\r\n    /// @dev Check whether the target address has governance rights for the given target\r\n    /// @param addr Destination address\r\n    /// @param flag Permission weight. The permission of the target address must be greater than this weight \r\n    /// to pass the check\r\n    /// @return True indicates permission\r\n    function checkGovernance(address addr, uint flag) external view returns (bool);\r\n}\r\n\r\n\r\n// File contracts/NestBase.sol\r\n\r\n// GPL-3.0-or-later\r\n\r\npragma solidity ^0.8.6;\r\n/// @dev Base contract of nest\r\ncontract NestBase {\r\n\r\n    /// @dev INestGovernance implementation contract address\r\n    address public _governance;\r\n\r\n    /// @dev To support open-zeppelin/upgrades\r\n    /// @param governance INestGovernance implementation contract address\r\n    function initialize(address governance) public virtual {\r\n        require(_governance == address(0), \"NEST:!initialize\");\r\n        _governance = governance;\r\n    }\r\n\r\n    /// @dev Rewritten in the implementation contract, for load other contract addresses. Call \r\n    ///      super.update(newGovernance) when overriding, and override method without onlyGovernance\r\n    /// @param newGovernance INestGovernance implementation contract address\r\n    function update(address newGovernance) public virtual {\r\n\r\n        address governance = _governance;\r\n        require(governance == msg.sender || INestGovernance(governance).checkGovernance(msg.sender, 0), \"NEST:!gov\");\r\n        _governance = newGovernance;\r\n    }\r\n\r\n    //---------modifier------------\r\n\r\n    modifier onlyGovernance() {\r\n        require(INestGovernance(_governance).checkGovernance(msg.sender, 0), \"NEST:!gov\");\r\n        _;\r\n    }\r\n\r\n    modifier noContract() {\r\n        require(msg.sender == tx.origin, \"NEST:!contract\");\r\n        _;\r\n    }\r\n}\r\n\r\n\r\n// File contracts/custom/NestFrequentlyUsed.sol\r\n\r\n// GPL-3.0-or-later\r\n\r\npragma solidity ^0.8.6;\r\n/// @dev This contract include frequently used data\r\ncontract NestFrequentlyUsed is NestBase {\r\n\r\n    // ETH:\r\n    // Address of nest token\r\n    address constant NEST_TOKEN_ADDRESS = 0x04abEdA201850aC0124161F037Efd70c74ddC74C;\r\n    // Address of NestOpenPrice contract\r\n    address constant NEST_OPEN_PRICE = 0xE544cF993C7d477C7ef8E91D28aCA250D135aa03;\r\n    // Address of nest vault\r\n    address constant NEST_VAULT_ADDRESS = 0x12858F7f24AA830EeAdab2437480277E92B0723a;\r\n\r\n    // // BSC:\r\n    // // Address of nest token\r\n    // address constant NEST_TOKEN_ADDRESS = 0x98f8669F6481EbB341B522fCD3663f79A3d1A6A7;\r\n    // // Address of NestOpenPrice contract\r\n    // address constant NEST_OPEN_PRICE = 0x09CE0e021195BA2c1CDE62A8B187abf810951540;\r\n    // // Address of nest vault\r\n    // address constant NEST_VAULT_ADDRESS = 0x65e7506244CDdeFc56cD43dC711470F8B0C43beE;\r\n\r\n    // // Polygon:\r\n    // // Address of nest token\r\n    // address constant NEST_TOKEN_ADDRESS = 0x98f8669F6481EbB341B522fCD3663f79A3d1A6A7;\r\n    // // Address of NestOpenPrice contract\r\n    // address constant NEST_OPEN_PRICE = 0x09CE0e021195BA2c1CDE62A8B187abf810951540;\r\n    // // Address of nest vault\r\n    // address constant NEST_VAULT_ADDRESS;\r\n\r\n    // // KCC:\r\n    // // Address of nest token\r\n    // address constant NEST_TOKEN_ADDRESS = 0x98f8669F6481EbB341B522fCD3663f79A3d1A6A7;\r\n    // // Address of NestOpenPrice contract\r\n    // address constant NEST_OPEN_PRICE = 0x7DBe94A4D6530F411A1E7337c7eb84185c4396e6;\r\n    // // Address of nest vault\r\n    // address constant NEST_VAULT_ADDRESS;\r\n\r\n    // USDT base\r\n    uint constant USDT_BASE = 1 ether;\r\n}\r\n\r\n\r\n// File contracts/interfaces/INestBatchPrice2.sol\r\n\r\n// GPL-3.0-or-later\r\n\r\npragma solidity ^0.8.6;\r\n\r\n/// @dev This contract implemented the mining logic of nest\r\ninterface INestBatchPrice2 {\r\n\r\n    /// @dev Get the latest trigger price\r\n    /// @param channelId Target channelId\r\n    /// @param pairIndices Array of pair indices\r\n    /// @param payback Address to receive refund\r\n    /// @return prices Price array, i * 2 is the block where the ith price is located, and i * 2 + 1 is the ith price\r\n    function triggeredPrice(\r\n        uint channelId,\r\n        uint[] calldata pairIndices, \r\n        address payback\r\n    ) external payable returns (uint[] memory prices);\r\n\r\n    /// @dev Get the full information of latest trigger price\r\n    /// @param channelId Target channelId\r\n    /// @param pairIndices Array of pair indices\r\n    /// @param payback Address to receive refund\r\n    /// @return prices Price array, i * 4 is the block where the ith price is located, i * 4 + 1 is the ith price,\r\n    /// i * 4 + 2 is the ith average price and i * 4 + 3 is the ith volatility\r\n    function triggeredPriceInfo(\r\n        uint channelId, \r\n        uint[] calldata pairIndices,\r\n        address payback\r\n    ) external payable returns (uint[] memory prices);\r\n\r\n    /// @dev Find the price at block number\r\n    /// @param channelId Target channelId\r\n    /// @param pairIndices Array of pair indices\r\n    /// @param height Destination block number\r\n    /// @param payback Address to receive refund\r\n    /// @return prices Price array, i * 2 is the block where the ith price is located, and i * 2 + 1 is the ith price\r\n    function findPrice(\r\n        uint channelId,\r\n        uint[] calldata pairIndices, \r\n        uint height, \r\n        address payback\r\n    ) external payable returns (uint[] memory prices);\r\n\r\n    /// @dev Get the last (num) effective price\r\n    /// @param channelId Target channelId\r\n    /// @param pairIndices Array of pair indices\r\n    /// @param count The number of prices that want to return\r\n    /// @param payback Address to receive refund\r\n    /// @return prices Result array, i * count * 2 to (i + 1) * count * 2 - 1 are \r\n    /// the price results of group i quotation pairs\r\n    function lastPriceList(\r\n        uint channelId, \r\n        uint[] calldata pairIndices, \r\n        uint count, \r\n        address payback\r\n    ) external payable returns (uint[] memory prices);\r\n\r\n    /// @dev Returns lastPriceList and triggered price info\r\n    /// @param channelId Target channelId\r\n    /// @param pairIndices Array of pair indices\r\n    /// @param count The number of prices that want to return\r\n    /// @param payback Address to receive refund\r\n    /// @return prices result of group i quotation pair. Among them, the first two count * are the latest prices, \r\n    /// and the last four are: trigger price block number, trigger price, average price and volatility\r\n    function lastPriceListAndTriggeredPriceInfo(\r\n        uint channelId, \r\n        uint[] calldata pairIndices,\r\n        uint count, \r\n        address payback\r\n    ) external payable returns (uint[] memory prices);\r\n}\r\n\r\n\r\n// File contracts/custom/NestPriceAdapter.sol\r\n\r\n// GPL-3.0-or-later\r\n\r\npragma solidity ^0.8.6;\r\n/// @dev PriceAdapter from INestBatchPrice2\r\ncontract NestPriceAdapter is NestFrequentlyUsed {\r\n    \r\n    // Token configuration\r\n    struct TokenConfig {\r\n        // The channelId for call nest price\r\n        uint16 channelId;\r\n        // The pairIndex for call nest price\r\n        uint16 pairIndex;\r\n\r\n        // SigmaSQ for token\r\n        uint64 sigmaSQ;\r\n        // MIU_LONG for token\r\n        uint64 miuLong;\r\n        // MIU_SHORT for token\r\n        uint64 miuShort;\r\n    }\r\n\r\n    // Post unit: 2000usd\r\n    uint constant POST_UNIT = 2000 * USDT_BASE;\r\n\r\n    function _pairIndices(uint pairIndex) private pure returns (uint[] memory pairIndices) {\r\n        pairIndices = new uint[](1);\r\n        pairIndices[0] = pairIndex;\r\n    }\r\n\r\n    // Query latest 2 price\r\n    function _lastPriceList(\r\n        TokenConfig memory tokenConfig, \r\n        uint fee, \r\n        address payback\r\n    ) internal returns (uint[] memory prices) {\r\n        prices = INestBatchPrice2(NEST_OPEN_PRICE).lastPriceList {\r\n            value: fee\r\n        } (uint(tokenConfig.channelId), _pairIndices(uint(tokenConfig.pairIndex)), 2, payback);\r\n\r\n        prices[1] = _toUSDTPrice(prices[1]);\r\n        prices[3] = _toUSDTPrice(prices[3]);\r\n    }\r\n\r\n    // Query latest price\r\n    function _latestPrice(\r\n        TokenConfig memory tokenConfig, \r\n        uint fee, \r\n        address payback\r\n    ) internal returns (uint oraclePrice) {\r\n        uint[] memory prices = INestBatchPrice2(NEST_OPEN_PRICE).lastPriceList {\r\n            value: fee\r\n        } (uint(tokenConfig.channelId), _pairIndices(uint(tokenConfig.pairIndex)), 1, payback);\r\n\r\n        oraclePrice = _toUSDTPrice(prices[1]);\r\n    }\r\n\r\n    // Find price by blockNumber\r\n    function _findPrice(\r\n        TokenConfig memory tokenConfig, \r\n        uint blockNumber, \r\n        uint fee, \r\n        address payback\r\n    ) internal returns (uint oraclePrice) {\r\n        uint[] memory prices = INestBatchPrice2(NEST_OPEN_PRICE).findPrice {\r\n            value: fee\r\n        } (uint(tokenConfig.channelId), _pairIndices(uint(tokenConfig.pairIndex)), blockNumber, payback);\r\n\r\n        oraclePrice = _toUSDTPrice(prices[1]);\r\n    }\r\n\r\n    // Convert to usdt based price\r\n    function _toUSDTPrice(uint rawPrice) internal pure returns (uint) {\r\n        return POST_UNIT * 1 ether / rawPrice;\r\n    }\r\n}\r\n\r\n\r\n// File contracts/NestOptions.sol\r\n\r\n// GPL-3.0-or-later\r\n\r\npragma solidity ^0.8.6;\r\n/// @dev Options\r\ncontract NestOptions is ChainParameter, NestFrequentlyUsed, NestPriceAdapter, INestOptions {\r\n\r\n    /// @dev Option structure\r\n    struct Option {\r\n        uint32 owner;\r\n        uint112 balance;\r\n        uint16 tokenIndex;\r\n        uint56 strikePrice;\r\n        bool orientation;\r\n        uint32 exerciseBlock;\r\n    }\r\n\r\n    // token registration information\r\n    struct TokenRegistration {\r\n        TokenConfig tokenConfig;\r\n        address tokenAddress;\r\n    }\r\n\r\n    // 64bits 1\r\n    int128 constant ONE = 0x10000000000000000;\r\n\r\n    // 64bits 50000\r\n    uint constant V50000 = 0x0C3500000000000000000;\r\n\r\n    // Proportion of option selling value, 10000 basis. 9500\r\n    uint constant SELL_RATE = 9500;\r\n\r\n    // Option array\r\n    Option[] _options;\r\n\r\n    // Registered account address mapping\r\n    mapping(address=>uint) _accountMapping;\r\n\r\n    // Registered accounts\r\n    address[] _accounts;\r\n\r\n    // token to index mapping\r\n    mapping(address=>uint) _tokenMapping;\r\n\r\n    // token registration information array\r\n    TokenRegistration[] _tokenRegistrations;\r\n\r\n    constructor() {\r\n    }\r\n\r\n    /// @dev To support open-zeppelin/upgrades\r\n    /// @param governance INestGovernance implementation contract address\r\n    function initialize(address governance) public override {\r\n        super.initialize(governance);\r\n        _accounts.push();\r\n    }\r\n\r\n    /// @dev Register token information\r\n    /// @param tokenAddress Target token address, 0 means eth\r\n    /// @param tokenConfig token configuration\r\n    function register(address tokenAddress, TokenConfig calldata tokenConfig) external onlyGovernance {\r\n        // Get registered tokenIndex by tokenAddress\r\n        uint index = _tokenMapping[tokenAddress];\r\n        \r\n        // index == 0 means token not registered, add\r\n        if (index == 0) {\r\n            // Add TokenRegistration to array\r\n            _tokenRegistrations.push(TokenRegistration(tokenConfig, tokenAddress));\r\n            // Record index + 1\r\n            index = _tokenRegistrations.length;\r\n            require(index < 0x10000, \"NO:too much tokenRegistrations\");\r\n            _tokenMapping[tokenAddress] = index;\r\n        } else {\r\n            // Update tokenConfig\r\n            _tokenRegistrations[index - 1].tokenConfig = tokenConfig;\r\n        }\r\n    }\r\n\r\n    /// @dev Returns the share of the specified option for target address\r\n    /// @param index Index of the option\r\n    /// @param addr Target address (This argument is useless, consider to remove)\r\n    function balanceOf(uint index, address addr) external view override returns (uint) {\r\n        Option memory option = _options[index];\r\n        if (uint(option.owner) == getAccountIndex(addr)) {\r\n            return uint(option.balance);\r\n        }\r\n        return 0;\r\n    }\r\n\r\n    /// @dev Find the options of the owner (in reverse order)\r\n    /// @param start Find forward from the index corresponding to the given owner address \r\n    /// (excluding the record corresponding to start)\r\n    /// @param count Maximum number of records returned\r\n    /// @param maxFindCount Find records at most\r\n    /// @param owner Target address\r\n    /// @return optionArray Matched options\r\n    function find(\r\n        uint start, \r\n        uint count, \r\n        uint maxFindCount, \r\n        address owner\r\n    ) external view override returns (OptionView[] memory optionArray) {\r\n        optionArray = new OptionView[](count);\r\n        // Calculate search region\r\n        Option[] storage options = _options;\r\n        // Loop from start to end\r\n        uint end = 0;\r\n        // start is 0 means Loop from the last item\r\n        if (start == 0) {\r\n            start = options.length;\r\n        }\r\n        // start > maxFindCount, so end is not 0\r\n        if (start > maxFindCount) {\r\n            end = start - maxFindCount;\r\n        }\r\n\r\n        uint ownerIndex = getAccountIndex(owner);\r\n        // Loop lookup to write qualified records to the buffer\r\n        for (uint index = 0; index < count && start > end;) {\r\n            Option storage option = options[--start];\r\n            if (uint(option.owner) == ownerIndex) {\r\n                optionArray[index++] = _toOptionView(option, start);\r\n            }\r\n        }\r\n    }\r\n\r\n    /// @dev List options\r\n    /// @param offset Skip previous (offset) records\r\n    /// @param count Return (count) records\r\n    /// @param order Order. 0 reverse order, non-0 positive order\r\n    /// @return optionArray Matched options\r\n    function list(\r\n        uint offset, \r\n        uint count, \r\n        uint order\r\n    ) external view override returns (OptionView[] memory optionArray) {\r\n        // Load options\r\n        Option[] storage options = _options;\r\n        // Create result array\r\n        optionArray = new OptionView[](count);\r\n        uint length = options.length;\r\n        uint i = 0;\r\n\r\n        // Reverse order\r\n        if (order == 0) {\r\n            uint index = length - offset;\r\n            uint end = index > count ? index - count : 0;\r\n            while (index > end) {\r\n                Option storage option = options[--index];\r\n                optionArray[i++] = _toOptionView(option, index);\r\n            }\r\n        } \r\n        // Positive order\r\n        else {\r\n            uint index = offset;\r\n            uint end = index + count;\r\n            if (end > length) {\r\n                end = length;\r\n            }\r\n            while (index < end) {\r\n                optionArray[i++] = _toOptionView(options[index], index);\r\n                ++index;\r\n            }\r\n        }\r\n    }\r\n\r\n    /// @dev Obtain the number of European options that have been opened\r\n    /// @return Number of European options opened\r\n    function getOptionCount() external view override returns (uint) {\r\n        return _options.length;\r\n    }\r\n\r\n    /// @dev Open option\r\n    /// @param tokenAddress Target token address, 0 means eth\r\n    /// @param strikePrice The exercise price set by the user. During settlement, the system will compare the \r\n    /// current price of the subject matter with the exercise price to calculate the user's profit and loss\r\n    /// @param orientation true: call, false: put\r\n    /// @param exerciseBlock After reaching this block, the user will exercise manually, and the block will be\r\n    /// recorded in the system using the block number\r\n    /// @param nestAmount Amount of paid NEST\r\n    function open(\r\n        address tokenAddress,\r\n        uint strikePrice,\r\n        bool orientation,\r\n        uint exerciseBlock,\r\n        uint nestAmount\r\n    ) external payable override {\r\n\r\n        // Get registered tokenIndex by tokenAddress\r\n        // _tokenMapping[tokenAddress] is less than 0x10000, so it can convert to uint16\r\n        // If tokenAddress not registered, _tokenMapping[tokenAddress] is 0, subtract by 1 will failed\r\n        // This make sure tokenAddress must registered\r\n        uint tokenIndex = _tokenMapping[tokenAddress] - 1;\r\n        TokenConfig memory tokenConfig = _tokenRegistrations[tokenIndex].tokenConfig;\r\n\r\n        // 1. Query price from oracle\r\n        uint oraclePrice = _latestPrice(tokenConfig, msg.value, msg.sender);\r\n\r\n        // 2. Calculate the amount of option\r\n        uint amount = _estimate(tokenConfig, oraclePrice, strikePrice, orientation, exerciseBlock, nestAmount);\r\n\r\n        // 3. Open\r\n        // Emit open event\r\n        emit Open(_options.length, nestAmount, msg.sender, amount);\r\n        // Add option to array\r\n        _options.push(Option(\r\n            //uint32 owner;\r\n            uint32(_addressIndex(msg.sender)),\r\n            //uint112 balance;\r\n            _toUInt112(amount),\r\n            uint16(tokenIndex),\r\n            //uint56 strikePrice;\r\n            _encodeFloat(strikePrice),\r\n            //bool orientation;\r\n            orientation,\r\n            //uint32 exerciseBlock;\r\n            uint32(exerciseBlock)\r\n        ));\r\n\r\n        // 4. Transfer NEST from user\r\n        //DCU(DCU_TOKEN_ADDRESS).burn(msg.sender, dcuAmount);\r\n        TransferHelper.safeTransferFrom(NEST_TOKEN_ADDRESS, msg.sender, NEST_VAULT_ADDRESS, nestAmount);\r\n    }\r\n\r\n    /// @dev Estimate the amount of option\r\n    /// @param tokenAddress Target token address, 0 means eth\r\n    /// @param oraclePrice Current price from oracle\r\n    /// @param strikePrice The exercise price set by the user. During settlement, the system will compare the \r\n    /// current price of the subject matter with the exercise price to calculate the user's profit and loss\r\n    /// @param orientation true: call, false: put\r\n    /// @param exerciseBlock After reaching this block, the user will exercise manually, and the block will be\r\n    /// recorded in the system using the block number\r\n    /// @param nestAmount Amount of paid NEST\r\n    /// @return amount Amount of option\r\n    function estimate(\r\n        address tokenAddress,\r\n        uint oraclePrice,\r\n        uint strikePrice,\r\n        bool orientation,\r\n        uint exerciseBlock,\r\n        uint nestAmount\r\n    ) external view override returns (uint amount) {\r\n        return _estimate(\r\n            _tokenRegistrations[_tokenMapping[tokenAddress] - 1].tokenConfig,\r\n            oraclePrice,\r\n            strikePrice,\r\n            orientation,\r\n            exerciseBlock,\r\n            nestAmount\r\n        );\r\n    }\r\n    \r\n    /// @dev Exercise option\r\n    /// @param index Index of option\r\n    /// @param amount Amount of option to exercise\r\n    function exercise(uint index, uint amount) external payable override {\r\n\r\n        // 1. Load the option\r\n        Option storage option = _options[index];\r\n        address owner = _accounts[uint(option.owner)];\r\n        uint strikePrice = _decodeFloat(option.strikePrice);\r\n        bool orientation = option.orientation;\r\n        uint exerciseBlock = uint(option.exerciseBlock);\r\n\r\n        TokenConfig memory tokenConfig = _tokenRegistrations[option.tokenIndex].tokenConfig;\r\n\r\n        require(block.number >= exerciseBlock, \"NO:at maturity\");\r\n\r\n        // 2. Deduct the specified amount\r\n        option.balance = _toUInt112(uint(option.balance) - amount);\r\n\r\n        // 3. Find the price by specified block from oracle\r\n        uint oraclePrice = _findPrice(tokenConfig, exerciseBlock, msg.value, msg.sender);\r\n\r\n        // 4. Calculate the number of NEST that can be obtained\r\n        uint gain = 0;\r\n        // Call option\r\n        if (orientation) {\r\n            // Win\r\n            if (oraclePrice > strikePrice) {\r\n                gain = amount * (oraclePrice - strikePrice) / USDT_BASE;\r\n            }\r\n        } \r\n        // Put option\r\n        else {\r\n            // Win\r\n            if (oraclePrice < strikePrice) {\r\n                gain = amount * (strikePrice - oraclePrice) / USDT_BASE;\r\n            }\r\n        }\r\n\r\n        // 5. If win, Transfer NEST to user\r\n        if (gain > 0) {\r\n            //DCU(DCU_TOKEN_ADDRESS).mint(owner, gain);\r\n            INestVault(NEST_VAULT_ADDRESS).transferTo(owner, gain);\r\n        }\r\n\r\n        // emit Exercise event\r\n        emit Exercise(index, amount, owner, gain);\r\n    }\r\n\r\n    /// @dev Sell option\r\n    /// @param index Index of option\r\n    /// @param amount Amount of option to sell\r\n    function sell(uint index, uint amount) external payable override {\r\n        // Sell formula: vt=Max(ct(T,K)*0.95, 0). \r\n        // ct(K,T) Is the price of option present\r\n        // Note: No less than 1% condition\r\n\r\n        // 1. Load the option\r\n        Option storage option = _options[index];\r\n        address owner = _accounts[uint(option.owner)];\r\n        require(owner == msg.sender, \"NO:not owner\");\r\n\r\n        TokenConfig memory tokenConfig = _tokenRegistrations[option.tokenIndex].tokenConfig;\r\n\r\n        // 2. Deduct the specified amount\r\n        option.balance = _toUInt112(uint(option.balance) - amount);\r\n\r\n        // 3. Query price from oracle\r\n        uint oraclePrice = _latestPrice(tokenConfig, msg.value, msg.sender);\r\n\r\n        // 4. Calculate option price and sell amount\r\n        uint nestAmount = amount * _calcV(\r\n            tokenConfig, \r\n            oraclePrice,\r\n            _decodeFloat(option.strikePrice),\r\n            option.orientation,\r\n            uint(option.exerciseBlock)\r\n        ) * SELL_RATE / (USDT_BASE * 0x27100000000000000000); \r\n        // 0x27100000000000000000 = 10000 << 64\r\n\r\n        if (nestAmount > 0) {\r\n            //DCU(DCU_TOKEN_ADDRESS).mint(msg.sender, nestAmount);\r\n            INestVault(NEST_VAULT_ADDRESS).transferTo(msg.sender, nestAmount);\r\n        }\r\n\r\n        // emit Sell event\r\n        emit Sell(index, amount, msg.sender, nestAmount);\r\n    }\r\n\r\n    /// @dev Calculate option price\r\n    /// @param oraclePrice Current price from oracle\r\n    /// @param strikePrice The exercise price set by the user. During settlement, the system will compare the \r\n    /// current price of the subject matter with the exercise price to calculate the user's profit and loss\r\n    /// @param orientation true: call, false: put\r\n    /// @param exerciseBlock After reaching this block, the user will exercise manually, and the block will be\r\n    /// recorded in the system using the block number\r\n    /// @return v Option price. Need to divide (USDT_BASE << 64)\r\n    function calcV(\r\n        address tokenAddress,\r\n        uint oraclePrice,\r\n        uint strikePrice,\r\n        bool orientation,\r\n        uint exerciseBlock\r\n    ) public view override returns (uint v) {\r\n        return _calcV(\r\n            _tokenRegistrations[_tokenMapping[tokenAddress] - 1].tokenConfig,\r\n            oraclePrice,\r\n            strikePrice,\r\n            orientation,\r\n            exerciseBlock\r\n        );\r\n    }\r\n\r\n    /// @dev Gets the address corresponding to the given index number\r\n    /// @param index The index number of the specified address\r\n    /// @return The address corresponding to the given index number\r\n    function indexAddress(uint index) public view returns (address) {\r\n        return _accounts[index];\r\n    }\r\n\r\n    /// @dev Gets the registration index number of the specified address\r\n    /// @param addr Destination address\r\n    /// @return 0 means nonexistent, non-0 means index number\r\n    function getAccountIndex(address addr) public view returns (uint) {\r\n        return _accountMapping[addr];\r\n    }\r\n\r\n    /// @dev Get the length of registered account array\r\n    /// @return The length of registered account array\r\n    function getAccountCount() external view returns (uint) {\r\n        return _accounts.length;\r\n    }\r\n\r\n    // Convert to OptionView\r\n    function _toOptionView(\r\n        Option storage option, \r\n        uint index\r\n    ) private view returns (OptionView memory) {\r\n        return OptionView(\r\n            index,\r\n            _tokenRegistrations[option.tokenIndex].tokenAddress,\r\n            _decodeFloat(option.strikePrice),\r\n            option.orientation,\r\n            uint(option.exerciseBlock),\r\n            option.balance,\r\n            _accounts[uint(option.owner)]\r\n        );\r\n    }\r\n\r\n    // Convert 18 decimal points to 64 binary points\r\n    function _d18TOb64(uint v) private pure returns (int128) {\r\n        require(v < 0x6F05B59D3B200000000000000000000, \"NO:can't convert to 64bits\");\r\n        return int128(int((v << 64) / 1 ether));\r\n    }\r\n\r\n    // Convert uint to int128\r\n    function _toInt128(uint v) private pure returns (int128) {\r\n        require(v < 0x80000000000000000000000000000000, \"NO:can't convert to int128\");\r\n        return int128(int(v));\r\n    }\r\n\r\n    // Convert int128 to uint\r\n    function _toUInt(int128 v) private pure returns (uint) {\r\n        require(v >= 0, \"NO:can't convert to uint\");\r\n        return uint(int(v));\r\n    }\r\n\r\n    // Convert uint to uint112\r\n    function _toUInt112(uint v) private pure returns (uint112) {\r\n        require(v <= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF,\"NO:can't convert to uint112\");\r\n        return uint112(v);\r\n    }\r\n\r\n    // Calculate standard normal distribution by table\r\n    function _snd(int128 x) private pure returns (int128) {\r\n        uint[28] memory table = [\r\n            /* */ ///////////////////// STANDARD NORMAL TABLE //////////////////////////\r\n            /* */ 0x174A15BF143412A8111C0F8F0E020C740AE6095807CA063B04AD031E018F0000, //\r\n            ///// 0x2F8C2E0F2C912B1229922811268F250B23872202207D1EF61D6F1BE61A5D18D8, //\r\n            /* */ 0x2F8C2E0F2C912B1229922811268F250B23872202207D1EF61D6F1BE61A5D18D4, //\r\n            /* */ 0x46A2453C43D4426B41003F943E263CB63B4539D3385F36EA357333FB32823108, //\r\n            /* */ 0x5C0D5AC5597B582F56E05590543E52EA5194503C4EE24D874C294ACA49694807, //\r\n            /* */ 0x6F6C6E466D1F6BF56AC9699B686A6738660364CC6392625761195FD95E975D53, //\r\n            /* */ 0x807E7F7F7E7D7D797C737B6A7A5F79517841772F761A750373E972CD71AF708E, //\r\n            /* */ 0x8F2A8E518D768C998BB98AD789F2890B88218736864785568463836E8276817B, //\r\n            /* */ 0x9B749AC19A0B9953989997DD971E965D959A94D4940C9342927591A690D49000, //\r\n            ///// 0xA57CA4ECA459A3C4A32EA295A1FAA15CA0BDA01C9F789ED29E2A9D809CD39C25, //\r\n            /* */ 0xA57CA4ECA459A3C4A32EA295A1FAA15DA0BDA01C9F789ED29E2A9D809CD39C25, //\r\n            /* */ 0xAD78AD07AC93AC1EABA7AB2EAAB3AA36A9B8A937A8B5A830A7AAA721A697A60B, //\r\n            /* */ 0xB3AAB353B2FAB2A0B245B1E7B189B128B0C6B062AFFDAF96AF2DAEC2AE56ADE8, //\r\n            /* */ 0xB859B818B7D6B793B74EB708B6C0B678B62EB5E2B595B547B4F7B4A6B454B400, //\r\n            /* */ 0xBBCDBB9EBB6EBB3CBB0ABAD7BAA2BA6DBA36B9FFB9C6B98CB951B915B8D8B899, //\r\n            /* */ 0xBE49BE27BE05BDE2BDBEBD99BD74BD4DBD26BCFEBCD5BCACBC81BC56BC29BBFC, //\r\n            /* */ 0xC006BFEEBFD7BFBEBFA5BF8CBF72BF57BF3CBF20BF03BEE6BEC8BEA9BE8ABE69, //\r\n            /* */ 0xC135C126C116C105C0F4C0E3C0D1C0BFC0ACC099C086C072C05DC048C032C01C, //\r\n            /* */ 0xC200C1F5C1EBC1E0C1D5C1C9C1BEC1B1C1A5C198C18BC17EC170C162C154C145, //\r\n            /* */ 0xC283C27CC275C26EC267C260C258C250C248C240C238C22FC226C21DC213C20A, //\r\n            /* */ 0xC2D6C2D2C2CDC2C9C2C5C2C0C2BBC2B6C2B1C2ACC2A7C2A1C29BC295C28FC289, //\r\n            /* */ 0xC309C306C304C301C2FEC2FCC2F9C2F6C2F2C2EFC2ECC2E8C2E5C2E1C2DEC2DA, //\r\n            /* */ 0xC328C326C325C323C321C320C31EC31CC31AC318C316C314C312C310C30EC30B, //\r\n            /* */ 0xC33AC339C338C337C336C335C334C333C332C331C330C32EC32DC32CC32AC329, //\r\n            /* */ 0xC344C343C343C342C342C341C341C340C33FC33FC33EC33DC33DC33CC33BC33A, //\r\n            /* */ 0xC34AC349C349C349C348C348C348C348C347C347C346C346C346C345C345C344, //\r\n            /* */ 0xC34DC34DC34CC34CC34CC34CC34CC34CC34BC34BC34BC34BC34BC34AC34AC34A, //\r\n            /* */ 0xC34EC34EC34EC34EC34EC34EC34EC34EC34EC34EC34DC34DC34DC34DC34DC34D, //\r\n            /* */ 0xC34FC34FC34FC34FC34FC34FC34FC34FC34FC34FC34FC34FC34FC34FC34EC34E, //\r\n            /* */ 0xC350C350C350C350C350C350C34FC34FC34FC34FC34FC34FC34FC34FC34FC34F  //\r\n            /* */ //////////////////// MADE IN CHINA 2021-08-24 ////////////////////////\r\n        ];\r\n\r\n        uint ux = uint(int(x < 0 ? -x : x)) * 100;\r\n        uint i = ux >> 64;\r\n        uint v = V50000;\r\n\r\n        if (i < 447) {\r\n            v = uint((table[i >> 4] >> ((i & 0xF) << 4)) & 0xFFFF) << 64;\r\n            v = (\r\n                    (\r\n                        (\r\n                            (uint((table[(i + 1) >> 4] >> (((i + 1) & 0xF) << 4)) & 0xFFFF) << 64)\r\n                            - v\r\n                        ) * (ux & 0xFFFFFFFFFFFFFFFF) //(ux - (i << 64))\r\n                    ) >> 64\r\n                ) + v;\r\n        }\r\n\r\n        if (x > 0) {\r\n            v = V50000 + v;\r\n        } else {\r\n            v = V50000 - v;\r\n        }\r\n\r\n        return int128(int(v / 100000));\r\n    }\r\n\r\n    /// @dev Estimate the amount of option\r\n    /// @param oraclePrice Current price from oracle\r\n    /// @param strikePrice The exercise price set by the user. During settlement, the system will compare the \r\n    /// current price of the subject matter with the exercise price to calculate the user's profit and loss\r\n    /// @param orientation true: call, false: put\r\n    /// @param exerciseBlock After reaching this block, the user will exercise manually, and the block will be\r\n    /// recorded in the system using the block number\r\n    /// @param nestAmount Amount of paid NEST\r\n    /// @return amount Amount of option\r\n    function _estimate(\r\n        TokenConfig memory tokenConfig,\r\n        uint oraclePrice,\r\n        uint strikePrice,\r\n        bool orientation,\r\n        uint exerciseBlock,\r\n        uint nestAmount\r\n    ) private view returns (uint amount) {\r\n\r\n        require(exerciseBlock > block.number + MIN_PERIOD, \"NO:exerciseBlock too small\");\r\n\r\n        // 1. Calculate option price\r\n        uint v = _calcV(\r\n            tokenConfig, \r\n            oraclePrice,\r\n            strikePrice,\r\n            orientation,\r\n            exerciseBlock\r\n        );\r\n\r\n        // 2. Correct option price\r\n        if (orientation) {\r\n            //v = _calcVc(config, oraclePrice, T, strikePrice);\r\n            // Vc>=S0*1%; Vp>=K*1%\r\n            // require(v * 100 >> 64 >= oraclePrice, \"NO:vc must greater than S0*1%\");\r\n            if (v * 100 >> 64 < oraclePrice) {\r\n                v = oraclePrice * 0x10000000000000000 / 100;\r\n            }\r\n        } else {\r\n            //v = _calcVp(config, oraclePrice, T, strikePrice);\r\n            // Vc>=S0*1%; Vp>=K*1%\r\n            // require(v * 100 >> 64 >= strikePrice, \"NO:vp must greater than K*1%\");\r\n            if (v * 100 >> 64 < strikePrice) {\r\n                v = strikePrice * 0x10000000000000000 / 100;\r\n            }\r\n        }\r\n\r\n        // 3. Calculate the amount of option\r\n        amount = (USDT_BASE << 64) * nestAmount / v;\r\n    }\r\n\r\n    /// @dev Calculate option price\r\n    /// @param oraclePrice Current price from oracle\r\n    /// @param strikePrice The exercise price set by the user. During settlement, the system will compare the \r\n    /// current price of the subject matter with the exercise price to calculate the user's profit and loss\r\n    /// @param orientation true: call, false: put\r\n    /// @param exerciseBlock After reaching this block, the user will exercise manually, and the block will be\r\n    /// recorded in the system using the block number\r\n    /// @return v Option price. Need to divide (USDT_BASE << 64)\r\n    function _calcV(\r\n        TokenConfig memory tokenConfig,\r\n        uint oraclePrice,\r\n        uint strikePrice,\r\n        bool orientation,\r\n        uint exerciseBlock\r\n    ) private view returns (uint v) {\r\n\r\n        // Convert the total time according to the average block out time\r\n        uint T = (exerciseBlock - block.number) * BLOCK_TIME / 1000;\r\n        v = orientation \r\n            ? _calcVc(tokenConfig, oraclePrice, T, strikePrice) \r\n            : _calcVp(tokenConfig, oraclePrice, T, strikePrice);\r\n    }\r\n\r\n    // Calculate option price for call\r\n    function _calcVc(TokenConfig memory tokenConfig, uint S0, uint T, uint K) private pure returns (uint vc) {\r\n\r\n        int128 sigmaSQ_T = _d18TOb64(uint(tokenConfig.sigmaSQ) * T);\r\n        int128 miu_T = _toInt128(uint(tokenConfig.miuLong) * T);\r\n        int128 sigma_t = ABDKMath64x64.sqrt(sigmaSQ_T);\r\n        int128 D1 = _D1(S0, K, sigmaSQ_T, miu_T);\r\n        int128 d = ABDKMath64x64.div(D1, sigma_t);\r\n\r\n        uint left = _toUInt(ABDKMath64x64.mul(\r\n            //ABDKMath64x64.exp(miu_T), \r\n            // Use approximate calculation method: x*(1+rt)\r\n            // by chenf 2021-12-28 15:27\r\n            miu_T + ONE,\r\n            ABDKMath64x64.sub(\r\n                ONE,\r\n                _snd(ABDKMath64x64.sub(d, sigma_t))\r\n            )\r\n        )) * S0;\r\n        uint right = _toUInt(ABDKMath64x64.sub(ONE, _snd(d))) * K;\r\n        \r\n        vc = left > right ? left - right : 0;\r\n    }\r\n\r\n    // Calculate option price for put\r\n    function _calcVp(TokenConfig memory tokenConfig, uint S0, uint T, uint K) private pure returns (uint vp) {\r\n\r\n        int128 sigmaSQ_T = _d18TOb64(uint(tokenConfig.sigmaSQ) * T);\r\n        int128 miu_T = _toInt128(uint(tokenConfig.miuShort) * T);\r\n        int128 sigma_t = ABDKMath64x64.sqrt(sigmaSQ_T);\r\n        int128 D1 = _D1(S0, K, sigmaSQ_T, miu_T);\r\n        int128 d = ABDKMath64x64.div(D1, sigma_t);\r\n\r\n        uint left = _toUInt(_snd(d)) * K;\r\n        uint right = _toUInt(ABDKMath64x64.mul(\r\n            //ABDKMath64x64.exp(miu_T), \r\n            // Use approximate calculation method: x*(1+rt)\r\n            // by chenf 2021-12-28 15:27\r\n            miu_T + ONE,\r\n            _snd(ABDKMath64x64.sub(d, sigma_t))\r\n        )) * S0;\r\n\r\n        vp = left > right ? left - right : 0;\r\n    }\r\n\r\n    // d1 in formula, Because didn't divide by Ï, So it's named D1\r\n    function _D1(uint S0, uint K, int128 sigmaSQ_T, int128 miu_T) private pure returns (int128) {\r\n        return\r\n        ABDKMath64x64.sub(\r\n            ABDKMath64x64.add(\r\n                ABDKMath64x64.ln(_toInt128(K * 0x10000000000000000 / S0)),\r\n                sigmaSQ_T >> 1\r\n            ),\r\n            miu_T\r\n        );\r\n    }\r\n    \r\n    /// @dev Encode the uint value as a floating-point representation in the form of fraction * 16 ^ exponent\r\n    /// @param value Destination uint value\r\n    /// @return float format\r\n    function _encodeFloat(uint value) private pure returns (uint56) {\r\n        uint exponent = 0; \r\n        while (value > 0x3FFFFFFFFFFFF) {\r\n            value >>= 4;\r\n            ++exponent;\r\n        }\r\n        return uint56((value << 6) | exponent);\r\n    }\r\n\r\n    /// @dev Decode the floating-point representation of fraction * 16 ^ exponent to uint\r\n    /// @param floatValue fraction value\r\n    /// @return decode format\r\n    function _decodeFloat(uint56 floatValue) private pure returns (uint) {\r\n        return (uint(floatValue) >> 6) << ((uint(floatValue) & 0x3F) << 2);\r\n    }\r\n    \r\n    /// @dev Gets the index number of the specified address. If it does not exist, register\r\n    /// @param addr Destination address\r\n    /// @return The index number of the specified address\r\n    function _addressIndex(address addr) private returns (uint) {\r\n\r\n        uint index = _accountMapping[addr];\r\n        if (index == 0) {\r\n            // If it exceeds the maximum number that 32 bits can store, you can't continue to register a new account.\r\n            // If you need to support a new account, you need to update the contract\r\n            require((_accountMapping[addr] = index = _accounts.length) < 0x100000000, \"NO:!accounts\");\r\n            _accounts.push(addr);\r\n        }\r\n\r\n        return index;\r\n    }\r\n}","ABI":"[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"gain\",\"type\":\"uint256\"}],\"name\":\"Exercise\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"nestAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Open\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"nestAmount\",\"type\":\"uint256\"}],\"name\":\"Sell\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"_governance\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"oraclePrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"strikePrice\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"orientation\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"exerciseBlock\",\"type\":\"uint256\"}],\"name\":\"calcV\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"v\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"oraclePrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"strikePrice\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"orientation\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"exerciseBlock\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"nestAmount\",\"type\":\"uint256\"}],\"name\":\"estimate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"exercise\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"start\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"count\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxFindCount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"find\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"strikePrice\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"orientation\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"exerciseBlock\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"internalType\":\"struct INestOptions.OptionView[]\",\"name\":\"optionArray\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getAccountCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"getAccountIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getOptionCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"indexAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"governance\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"offset\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"count\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"order\",\"type\":\"uint256\"}],\"name\":\"list\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"strikePrice\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"orientation\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"exerciseBlock\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"internalType\":\"struct INestOptions.OptionView[]\",\"name\":\"optionArray\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"strikePrice\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"orientation\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"exerciseBlock\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"nestAmount\",\"type\":\"uint256\"}],\"name\":\"open\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"uint16\",\"name\":\"channelId\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"pairIndex\",\"type\":\"uint16\"},{\"internalType\":\"uint64\",\"name\":\"sigmaSQ\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"miuLong\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"miuShort\",\"type\":\"uint64\"}],\"internalType\":\"struct NestPriceAdapter.TokenConfig\",\"name\":\"tokenConfig\",\"type\":\"tuple\"}],\"name\":\"register\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"sell\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newGovernance\",\"type\":\"address\"}],\"name\":\"update\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"NestOptions","CompilerVersion":"v0.8.15+commit.e14f2714","OptimizationUsed":"1","Runs":"8888","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"GNU GPLv3","Proxy":"0","Implementation":"","SwarmSource":"ipfs://78f72f0c6e02669359ca2656d6d7e567c2b7319054f58d8df4cbcf616eb74083"}]}