{"status":"1","message":"OK","result":[{"SourceCode":"// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n */\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes calldata) {\r\n        return msg.data;\r\n    }\r\n}\r\n\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * By default, the owner account will be the one that deploys the contract. This\r\n * can later be changed with {transferOwnership}.\r\n *\r\n * This module is used through inheritance. It will make available the modifier\r\n * `onlyOwner`, which can be applied to your functions to restrict their use to\r\n * the owner.\r\n */\r\nabstract contract Ownable is Context {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    constructor() {\r\n        _setOwner(_msgSender());\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view virtual returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Leaves the contract without owner. It will not be possible to call\r\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\r\n     *\r\n     * NOTE: Renouncing ownership will leave the contract without an owner,\r\n     * thereby removing any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        _setOwner(address(0));\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        _setOwner(newOwner);\r\n    }\r\n\r\n    function _setOwner(address newOwner) private {\r\n        address oldOwner = _owner;\r\n        _owner = newOwner;\r\n        emit OwnershipTransferred(oldOwner, newOwner);\r\n    }\r\n}\r\n\r\ninterface MP {\r\n    function balanceOf(address wallet) external view returns(uint256);\r\n    function transferFrom(address from, address to, uint256 tokenId) external;\r\n    function isApprovedForAll(address wallet, address stakingAddress) external view returns(bool);\r\n}\r\n\r\ninterface Shard {\r\n    function determineYield(uint256 timestamp) external view returns(uint256);\r\n    function mintShards(address wallet, uint256 amount) external;\r\n}\r\n\r\n/*\r\n⠀*⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣀⣀⣀⣀⣀⣀⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\r\n⠀*⠀⠀⠀⠀⢀⣀⣀⣠⣴⣾⣿⣿⣿⣿⣿⣿⣿⣿⣷⣦⣄⣀⣀⡀⠀⠀⠀⠀⠀\r\n⠀*⠀⠀⠀⠀⢸⣿⠛⠛⠛⠛⠛⠛⠛⠛⠛⠛⠛⠛⠛⠛⠛⠛⣿⡇⠀⠀⠀⠀⠀\r\n⠀*⠀⠀⠀⠀⢸⣿⠀⢸⣿⣿⣿⣿⡿⠟⠁⠀⠀⣀⣾⣿⣿⠀⣿⡇⠀⠀⠀⠀⠀\r\n⠀*⠀⠀⠀⠀⢸⣿⠀⢸⣿⣿⡿⠋⠀⠀⠀⣠⣾⣿⡿⠋⠁⠀⣿⡇⠀⠀⠀⠀⠀\r\n⠀*⠀⠀⠀⠀⢸⣿⠀⢸⠟⠉⠀⠀⢀⣴⣾⣿⠿⠋⠀⠀⠀⠀⣿⡇⠀⠀⠀⠀⠀\r\n⠀*⠀⠀⠀⠀⢸⣿⠀⠀⠀⠀⣠⣴⣿⣿⠟⠁⠀⠀⠀⠀⠀⠀⣿⡇⠀⠀⠀⠀⠀\r\n⠀*⠀⠀⠀⠀⢸⣿⠀⠀⣠⣾⣿⡿⠋⠁⠀⠀⠀⠀⠀⣠⣶⠀⣿⡇⠀⠀⠀⠀⠀\r\n⠀*⠀⠀⠀⠀⢸⣿⠀⢸⣿⠿⠋⠀⠀⠀⠀⠀⢀⣠⣾⡿⠟⠀⣿⡇⠀⠀⠀⠀⠀\r\n⠀*⠀⠀⠀⠀⢸⣿⠀⠘⠁⠀⠀⠀⠀⠀⢀⣴⣿⡿⠋⣠⣴⠀⣿⡇⠀⠀⠀⠀⠀\r\n⠀*⠀⠀⠀⠀⢸⣿⠀⠀⠀⠀⠀⠀⣠⣾⣿⠟⢁⣠⣾⣿⣿⠀⣿⡇⠀⠀⠀⠀⠀\r\n⠀*⠀⠀⠀⠀⢸⣿⠀⠀⠀⢀⣠⣾⡿⠋⢁⣴⣿⣿⣿⣿⣿⠀⣿⡇⠀⠀⠀⠀⠀\r\n⠀*⠀⠀⠀⠀⢸⣿⣀⣀⣀⣈⣉⣉⣀⣀⣉⣉⣉⣉⣉⣉⣉⣀⣿⡇⠀⠀⠀⠀⠀\r\n⠀*⠀⠀⠀⠀⠘⠛⠛⠛⠿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠿⠛⠛⠛⠃⠀⠀⠀⠀⠀\r\n⠀*⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠉⠉⠛⠛⠛⠛⠋⠉⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\r\n *          MIRRORPASS.XYZ\r\n */\r\ncontract Frame is Ownable {\r\n    MP private mp;\r\n    Shard private shards;\r\n\r\n    struct LockedUp {\r\n        address owner;\r\n        uint256 until;\r\n        uint256 token;\r\n        bool hasToken;\r\n    }\r\n\r\n    bool public stakingAvailable = false;\r\n    bool public lockupAvailable = false;\r\n    bool public claimingAvailable = false;\r\n    uint256 public totalStaked = 0;\r\n\r\n    mapping(address => uint256[]) private tokensHeld;\r\n    mapping(address => LockedUp) private lockedup;\r\n    mapping(uint256 => uint256) private tokenYield;\r\n    mapping(uint256 => address) private tokenToOwner;\r\n\r\n    event StakedToken(address wallet, uint256[] tokens, uint256 timestamp);\r\n    event WithdrewToken(address wallet, uint256 tokenId, uint256 timestamp);\r\n    event LockedToken(address wallet, uint256 tokenId, uint256 timestamp);\r\n    event FreeToken(address wallet, uint256 tokenId);\r\n\r\n    modifier isNotContract() {\r\n        require(tx.origin == msg.sender, \"No contracts allowed\");\r\n        _;\r\n    }\r\n\r\n    modifier isStakingAvailable() {\r\n        require(stakingAvailable, \"Staking is currently disabled\");\r\n        _;\r\n    }\r\n\r\n    modifier isLockupAvailable() {\r\n        require(lockupAvailable, \"Lock Up is currently disabled\");\r\n        _;\r\n    }\r\n\r\n    // this returns the index of the token we're looking for in the deposited wallets\r\n    function findToken(uint256 token, uint256[] memory tokens) private pure returns(uint256) {\r\n        uint256 index = 0;\r\n\r\n        while (tokens[index] != token) {\r\n            index++;\r\n        }\r\n        \r\n        return index;\r\n    }\r\n\r\n    // this allows the user to start staking their tokens and it keeps track of the\r\n    // tokens that are staked, as well as the timestamp that they were deposited with\r\n    function stake(uint256[] memory tokens) public isStakingAvailable isNotContract {\r\n        require(tokens.length >= 1 && tokens.length <= 5, \"Invalid token amount\");\r\n\r\n        uint256[] storage _deposits = tokensHeld[msg.sender];\r\n\r\n        for (uint256 x = 0;x < tokens.length;x++) {\r\n            uint256 _token = tokens[x];\r\n\r\n            mp.transferFrom(msg.sender, address(this), _token);\r\n\r\n            _deposits.push(_token); \r\n            tokenYield[_token] = block.timestamp;\r\n            tokenToOwner[_token] = msg.sender;\r\n        }\r\n\r\n        totalStaked += tokens.length;\r\n        emit StakedToken(msg.sender, tokens, block.timestamp);\r\n    }\r\n\r\n    // this withdraws the staked tokens and claims any shards that weren't claimed\r\n    function withdraw(uint256[] memory tokens) public isNotContract {\r\n        require(tokens.length >= 1 && tokens.length <= 5, \"Invalid token amount\");\r\n\r\n        uint256 shardsGained = 0;\r\n        uint256[] storage _deposits = tokensHeld[msg.sender];\r\n\r\n        for (uint256 x = 0;x < tokens.length;x++) {\r\n            uint256 _token = tokens[x];\r\n            address _owner = tokenToOwner[_token];\r\n\r\n            require(_owner == msg.sender, \"You didn't deposit these\");\r\n            mp.transferFrom(address(this), _owner, _token);\r\n            \r\n            uint256 index = findToken(_token, _deposits);\r\n            delete _deposits[index];\r\n\r\n            // this accumulates the shards the wallet gained from all the tokens\r\n            if (claimingAvailable) {\r\n                shardsGained += shards.determineYield(tokenYield[_token]);\r\n            }\r\n\r\n            emit WithdrewToken(_owner, _token, tokenYield[_token]);\r\n\r\n            tokenYield[_token] = 0;\r\n            delete _owner;\r\n        }\r\n\r\n        if (claimingAvailable) {\r\n            shards.mintShards(msg.sender, shardsGained);\r\n        }\r\n\r\n        totalStaked -= tokens.length;\r\n        delete shardsGained;\r\n    }\r\n\r\n    // this allows you to \"withdraw\" your erc20 tokens from the staked tokens\r\n    function claimShardsFromTokens(uint256[] memory tokens) public isNotContract {\r\n        require(claimingAvailable, \"You're not able to withdraw your shards right now\");\r\n\r\n        uint256 shardsGained = 0;\r\n\r\n        for (uint256 x = 0;x < tokens.length;x++) {\r\n            uint256 _token = tokens[x];\r\n            require(tokenToOwner[_token] == msg.sender, \"You didn't deposit these\");\r\n\r\n            shardsGained += shards.determineYield(tokenYield[_token]);\r\n            tokenYield[_token] = block.timestamp;\r\n            delete _token;\r\n        }\r\n\r\n        shards.mintShards(msg.sender, shardsGained);\r\n        delete shardsGained;\r\n    }\r\n\r\n    // this returns the timestamp of when the token was staked, used for determining\r\n    // the yield each token gives\r\n    function getTimeFromToken(uint256 token) public view returns (uint256) {\r\n        return tokenYield[token];\r\n    }\r\n\r\n    // returns the total amount of tokens that are staked, used on the UI & for calculating yield\r\n    function getTokensStaked(address wallet) public view returns (uint256[] memory) {\r\n        return tokensHeld[wallet];\r\n    }\r\n\r\n    // this locks in the pass into the staking contract for X amount of time, this will give access\r\n    // to the application until the lock up period is over\r\n    function lockIn(uint256 tokenId, uint256 period) public isLockupAvailable isNotContract {\r\n        LockedUp storage _lockedup = lockedup[msg.sender];\r\n\r\n        require(!_lockedup.hasToken, \"You need to withdraw your current token first\");\r\n        require(period > 0 && period <= 3, \"You can only lock in your token for 30 to 90 days!\");\r\n\r\n        mp.transferFrom(msg.sender, address(this), tokenId);\r\n\r\n        _lockedup.owner = msg.sender;\r\n        _lockedup.until = block.timestamp + (30 days * period);\r\n        _lockedup.token = tokenId;\r\n        _lockedup.hasToken = true;\r\n        totalStaked += 1;\r\n\r\n        emit LockedToken(msg.sender, tokenId, _lockedup.until);        \r\n    }\r\n\r\n    // once the users lock in period is over, they are able to withdraw the token using this\r\n    function withdrawLockedUp() public isNotContract {\r\n        LockedUp storage _lockedup = lockedup[msg.sender];\r\n\r\n        require(block.timestamp >= _lockedup.until, \"Your lock in period is not over yet\");\r\n\r\n        mp.transferFrom(address(this), _lockedup.owner, _lockedup.token);\r\n\r\n        _lockedup.hasToken = false;\r\n        _lockedup.until = 0;\r\n        totalStaked -= 1;\r\n\r\n        emit FreeToken(_lockedup.owner, _lockedup.token);\r\n    }\r\n\r\n    // this returns the timestamp of when the locked up period ends\r\n    function getLockedInTime(address wallet) public view returns (uint256) {\r\n        LockedUp storage _lockedup = lockedup[wallet];\r\n\r\n        return _lockedup.until;\r\n    }\r\n\r\n    // this is more of a emergency case incase anything happens that requires\r\n    // people to withdraw their tokens\r\n    function clearLockedupUntil(address[] memory addresses) public onlyOwner {\r\n        for (uint x = 0;x < addresses.length;x++) {\r\n            LockedUp storage _lockedup = lockedup[addresses[x]];\r\n\r\n            _lockedup.until = 0;\r\n        }\r\n    }\r\n\r\n    // this is a emergency withdraw for locked in tokens if we need to do this any reason\r\n    function emergencyWithdrawLockedup(address[] memory addresses) public onlyOwner {\r\n        for (uint x = 0;x < addresses.length;x++) {\r\n            LockedUp storage _lockedup = lockedup[addresses[x]];\r\n\r\n            if (_lockedup.hasToken) {\r\n                mp.transferFrom(address(this), _lockedup.owner, _lockedup.token);\r\n                \r\n                _lockedup.until = 0;\r\n                _lockedup.hasToken = false;\r\n                totalStaked -= 1;\r\n            }\r\n        }\r\n    }\r\n\r\n    // this is used on the dashboard to calculate the pending shards \r\n    function calculateTotalPendingShards(uint256[] memory tokens) public view returns(uint256) {\r\n        uint256 possibleShards = 0;\r\n\r\n        for (uint256 x = 0;x < tokens.length;x++) {\r\n            uint256 _token = tokens[x];\r\n            possibleShards += shards.determineYield(tokenYield[_token]);\r\n            delete _token;\r\n        }\r\n\r\n        return possibleShards;\r\n    }\r\n\r\n    // this is the erc721 contract that holds the OG  mirror pass\r\n    function setTokenContract(address tokenContract) public onlyOwner {\r\n        mp = MP(tokenContract);\r\n    }\r\n    \r\n    // this is the erc20 token that interacts with the ECOSYSTEM\r\n    function setShardsContract(address shardsContract) public onlyOwner {\r\n        shards = Shard(shardsContract);\r\n    }\r\n\r\n    // this enables / dsiables stake\r\n    function setStakingState(bool available) public onlyOwner {\r\n        stakingAvailable = available;\r\n    }\r\n\r\n    // this enables / disables lockIn\r\n    function setLockupState(bool available) public onlyOwner {\r\n        lockupAvailable = available;\r\n    }\r\n\r\n    // this enables / disable erc20 token minting incase something occurs\r\n    // where we need to disable this\r\n    function setShardMinting(bool available) public onlyOwner {\r\n        claimingAvailable = available;\r\n    }\r\n}","ABI":"[{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"FreeToken\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"LockedToken\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"tokens\",\"type\":\"uint256[]\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"StakedToken\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"WithdrewToken\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"tokens\",\"type\":\"uint256[]\"}],\"name\":\"calculateTotalPendingShards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"tokens\",\"type\":\"uint256[]\"}],\"name\":\"claimShardsFromTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimingAvailable\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"addresses\",\"type\":\"address[]\"}],\"name\":\"clearLockedupUntil\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"addresses\",\"type\":\"address[]\"}],\"name\":\"emergencyWithdrawLockedup\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"}],\"name\":\"getLockedInTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"token\",\"type\":\"uint256\"}],\"name\":\"getTimeFromToken\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"}],\"name\":\"getTokensStaked\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"period\",\"type\":\"uint256\"}],\"name\":\"lockIn\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lockupAvailable\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"available\",\"type\":\"bool\"}],\"name\":\"setLockupState\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"available\",\"type\":\"bool\"}],\"name\":\"setShardMinting\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"shardsContract\",\"type\":\"address\"}],\"name\":\"setShardsContract\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"available\",\"type\":\"bool\"}],\"name\":\"setStakingState\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenContract\",\"type\":\"address\"}],\"name\":\"setTokenContract\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"tokens\",\"type\":\"uint256[]\"}],\"name\":\"stake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stakingAvailable\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalStaked\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"tokens\",\"type\":\"uint256[]\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawLockedUp\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"Frame","CompilerVersion":"v0.8.7+commit.e28d00a7","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"ipfs://260debbe9b4a780ef1d504d1c658d0c975144b7a8b0a7d1f80a372d6b2a4360a"}]}