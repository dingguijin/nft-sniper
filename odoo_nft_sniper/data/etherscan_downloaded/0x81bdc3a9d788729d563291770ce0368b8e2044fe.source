{"status":"1","message":"OK","result":[{"SourceCode":"# @version 0.3.3\r\n\r\nfrom vyper.interfaces import ERC165\r\nfrom vyper.interfaces import ERC721\r\n\r\nimplements: ERC165\r\nimplements: ERC721\r\n\r\n############ ERC-165 #############\r\n# @dev Static list of supported ERC165 interface ids\r\nSUPPORTED_INTERFACES: constant(bytes4[4]) = [\r\n    0x01ffc9a7,  # ERC165 interface ID of ERC165\r\n    0x80ac58cd,  # ERC165 interface ID of ERC721\r\n    0x5b5e139f,  # ERC165 interface ID of ERC721 Metadata Extension\r\n    0x5604e225,  # ERC165 interface ID of ERC4494\r\n]\r\n\r\n############ ERC-721 #############\r\n\r\n# Interface for the contract called by safeTransferFrom()\r\ninterface ERC721Receiver:\r\n    def onERC721Received(\r\n            operator: address,\r\n            owner: address,\r\n            tokenId: uint256,\r\n            data: Bytes[1024]\r\n        ) -> bytes32: view\r\n\r\n# Interface for ERC721Metadata\r\n\r\ninterface ERC721Metadata:\r\n\tdef name() -> String[64]: view\r\n\r\n\tdef symbol() -> String[32]: view\r\n\r\n\tdef tokenURI(\r\n\t\t_tokenId: uint256\r\n\t) -> String[128]: view\r\n\r\ninterface ERC721Enumerable:\r\n\r\n\tdef totalSupply() -> uint256: view\r\n\r\n\tdef tokenByIndex(\r\n\t\t_index: uint256\r\n\t) -> uint256: view\r\n\r\n\tdef tokenOfOwnerByIndex(\r\n\t\t_address: address,\r\n\t\t_index: uint256\r\n\t) -> uint256: view\r\n\r\n\r\n# @dev Emits when ownership of any NFT changes by any mechanism. This event emits when NFTs are\r\n#      created (`from` == 0) and destroyed (`to` == 0). Exception: during contract creation, any\r\n#      number of NFTs may be created and assigned without emitting Transfer. At the time of any\r\n#      transfer, the approved address for that NFT (if any) is reset to none.\r\n# @param owner Sender of NFT (if address is zero address it indicates token creation).\r\n# @param receiver Receiver of NFT (if address is zero address it indicates token destruction).\r\n# @param tokenId The NFT that got transfered.\r\nevent Transfer:\r\n    sender: indexed(address)\r\n    receiver: indexed(address)\r\n    tokenId: indexed(uint256)\r\n\r\n# @dev This emits when the approved address for an NFT is changed or reaffirmed. The zero\r\n#      address indicates there is no approved address. When a Transfer event emits, this also\r\n#      indicates that the approved address for that NFT (if any) is reset to none.\r\n# @param owner Owner of NFT.\r\n# @param approved Address that we are approving.\r\n# @param tokenId NFT which we are approving.\r\nevent Approval:\r\n    owner: indexed(address)\r\n    approved: indexed(address)\r\n    tokenId: indexed(uint256)\r\n\r\n# @dev This emits when an operator is enabled or disabled for an owner. The operator can manage\r\n#      all NFTs of the owner.\r\n# @param owner Owner of NFT.\r\n# @param operator Address to which we are setting operator rights.\r\n# @param approved Status of operator rights(true if operator rights are given and false if\r\n# revoked).\r\nevent ApprovalForAll:\r\n    owner: indexed(address)\r\n    operator: indexed(address)\r\n    approved: bool\r\n\r\nowner: public(address)\r\nisMinter: public(HashMap[address, bool])\r\n\r\n# @dev TokenID => owner\r\nidToOwner: public(HashMap[uint256, address])\r\n\r\n# @dev Mapping from owner address to count of their tokens.\r\nbalanceOf: public(HashMap[address, uint256])\r\n\r\n# @dev Mapping from owner address to mapping of operator addresses.\r\nisApprovedForAll: public(HashMap[address, HashMap[address, bool]])\r\n\r\n# @dev Mapping from NFT ID to approved address.\r\nidToApprovals: public(HashMap[uint256, address])\r\n############ ERC-4494 ############\r\n\r\n# @dev Mapping of TokenID to nonce values used for ERC4494 signature verification\r\nnonces: public(HashMap[uint256, uint256])\r\n\r\nDOMAIN_SEPARATOR: public(bytes32)\r\n\r\nEIP712_DOMAIN_TYPEHASH: constant(bytes32) = keccak256(\r\n    \"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"\r\n)\r\nEIP712_DOMAIN_NAMEHASH: constant(bytes32) = keccak256(\"Owner NFT\")\r\nEIP712_DOMAIN_VERSIONHASH: constant(bytes32) = keccak256(\"1\")\r\n\r\n\r\n# ERC20 Token Metadata\r\nNAME: constant(String[20]) = \"SongADayFann\"\r\nSYMBOL: constant(String[5]) = \"SADF\"\r\nIDENTITY_PRECOMPILE: constant(address) = 0x0000000000000000000000000000000000000004\r\nbaseURI: String[100]\r\n\r\nsadContract: ERC721\r\n\r\n@external\r\ndef __init__(baseURI: String[100]):\r\n    \"\"\"\r\n    @dev Contract constructor.\r\n    \"\"\"\r\n    self.owner = msg.sender\r\n    self.sadContract = ERC721(0x19b703f65aA7E1E775BD06c2aa0D0d08c80f1C45)\r\n    # change URI would be owner only\r\n    self.baseURI = baseURI\r\n    # ERC712 domain separator for ERC4494\r\n    self.DOMAIN_SEPARATOR = keccak256(\r\n        _abi_encode(\r\n            EIP712_DOMAIN_TYPEHASH,\r\n            EIP712_DOMAIN_NAMEHASH,\r\n            EIP712_DOMAIN_VERSIONHASH,\r\n            chain.id,\r\n            self,\r\n        )\r\n    )\r\n    self.idToOwner[0] = msg.sender\r\n    self.balanceOf[msg.sender] += 1\r\n    log Transfer(ZERO_ADDRESS, msg.sender, 0)\r\n\r\n# ERC721 Metadata Extension\r\n@pure\r\n@external\r\ndef name() -> String[40]:\r\n    return NAME\r\n\r\n@pure\r\n@external\r\ndef symbol() -> String[5]:\r\n    return SYMBOL\r\n\r\n@view\r\n@external\r\ndef tokenURI(tokenId: uint256) -> String[179]:\r\n    return self.baseURI\r\n\r\n@external\r\ndef setDomainSeparator():\r\n    \"\"\"\r\n    @dev Update the domain separator in case of a hardfork where chain ID changes\r\n    \"\"\"\r\n    self.DOMAIN_SEPARATOR = keccak256(\r\n        _abi_encode(\r\n            EIP712_DOMAIN_TYPEHASH,\r\n            EIP712_DOMAIN_NAMEHASH,\r\n            EIP712_DOMAIN_VERSIONHASH,\r\n            chain.id,\r\n            self,\r\n        )\r\n    )\r\n\r\n############ ERC-165 #############\r\n\r\n@pure\r\n@external\r\ndef supportsInterface(interface_id: bytes4) -> bool:\r\n    \"\"\"\r\n    @dev Interface identification is specified in ERC-165.\r\n    @param interface_id Id of the interface\r\n    \"\"\"\r\n    return interface_id in SUPPORTED_INTERFACES\r\n\r\n\r\n##### ERC-721 VIEW FUNCTIONS #####\r\n\r\n@view\r\n@external\r\ndef ownerOf(tokenId: uint256) -> address:\r\n    \"\"\"\r\n    @dev Returns the address of the owner of the NFT.\r\n         Throws if `tokenId` is not a valid NFT.\r\n    @param tokenId The identifier for an NFT.\r\n    \"\"\"\r\n    owner: address = self.idToOwner[tokenId]\r\n    # Throws if `tokenId` is not a valid NFT\r\n    assert owner != ZERO_ADDRESS\r\n    return owner\r\n\r\n\r\n@view\r\n@external\r\ndef getApproved(tokenId: uint256) -> address:\r\n    \"\"\"\r\n    @dev Get the approved address for a single NFT.\r\n         Throws if `tokenId` is not a valid NFT.\r\n    @param tokenId ID of the NFT to query the approval of.\r\n    \"\"\"\r\n    # Throws if `tokenId` is not a valid NFT\r\n    assert self.idToOwner[tokenId] != ZERO_ADDRESS\r\n    return self.idToApprovals[tokenId]\r\n\r\n\r\n### TRANSFER FUNCTION HELPERS ###\r\n\r\n@view\r\n@internal\r\ndef _isApprovedOrOwner(spender: address, tokenId: uint256) -> bool:\r\n    \"\"\"\r\n    @dev Returns whether the given spender can transfer a given token ID\r\n    @param spender address of the spender to query\r\n    @param tokenId uint256 ID of the token to be transferred\r\n    @return bool whether the msg.sender is approved for the given token ID,\r\n        is an operator of the owner, or is the owner of the token\r\n    \"\"\"\r\n    owner: address = self.idToOwner[tokenId]\r\n    if self.sadContract.balanceOf(spender) > 0:\r\n        return True\r\n    \r\n    if owner == spender:\r\n        return True\r\n\r\n    if spender == self.idToApprovals[tokenId]:\r\n        return True\r\n\r\n    if (self.isApprovedForAll[owner])[spender]:\r\n        return True\r\n\r\n    return False\r\n\r\n\r\n@internal\r\ndef _transferFrom(owner: address, receiver: address, tokenId: uint256, sender: address):\r\n    \"\"\"\r\n    @dev Execute transfer of a NFT.\r\n         Throws unless `msg.sender` is the current owner, an authorized operator, or the approved\r\n         address for this NFT. (NOTE: `msg.sender` not allowed in private function so pass `_sender`.)\r\n         address for thisassert self.idToOwner[tokenId] == owner NFT. (NOTE: `msg.sender` not allowed in private function so pass `_sender`.)\r\n         Throws if `receiver` is the zero address.\r\n         Throws if `owner` is not the current owner.\r\n         Throws if `tokenId` is not a valid NFT.\r\n    \"\"\"\r\n    # Check requirements\r\n    assert self._isApprovedOrOwner(sender, tokenId)\r\n    assert receiver != ZERO_ADDRESS\r\n    assert owner != ZERO_ADDRESS\r\n    assert self.idToOwner[tokenId] == owner\r\n\r\n    # Reset approvals, if any\r\n    if self.idToApprovals[tokenId] != ZERO_ADDRESS:\r\n        self.idToApprovals[tokenId] = ZERO_ADDRESS\r\n    # EIP-4494: increment nonce on transfer for safety\r\n    self.nonces[tokenId] += 1\r\n\r\n    # Change the owner\r\n    self.idToOwner[tokenId] = receiver\r\n\r\n    # Change count tracking\r\n    self.balanceOf[owner] -= 1\r\n    self.balanceOf[receiver] += 1\r\n\r\n    # Log the transfer\r\n    log Transfer(owner, receiver, tokenId)\r\n\r\n\r\n@external\r\ndef transferFrom(owner: address, receiver: address, tokenId: uint256):\r\n    \"\"\"\r\n    @dev Throws unless `msg.sender` is the current owner, an authorized operator, or the approved\r\n         address for this NFT.\r\n         Throws if `owner` is not the current owner.\r\n         Throws if `receiver` is the zero address.\r\n         Throws if `tokenId` is not a valid NFT.\r\n    @notice The caller is responsible to confirm that `receiver` is capable of receiving NFTs or else\r\n            they maybe be permanently lost.\r\n    @param owner The current owner of the NFT.\r\n    @param receiver The new owner.\r\n    @param tokenId The NFT to transfer.\r\n    \"\"\"\r\n    self._transferFrom(owner, receiver, tokenId, msg.sender)\r\n\r\n\r\n@external\r\ndef safeTransferFrom(\r\n        owner: address,\r\n        receiver: address,\r\n        tokenId: uint256,\r\n        data: Bytes[1024]=b\"\"\r\n    ):\r\n    \"\"\"\r\n    @dev Transfers the ownership of an NFT from one address to another address.\r\n         Throws unless `msg.sender` is the current owner, an authorized operator, or the\r\n         approved address for this NFT.\r\n         Throws if `owner` is not the current owner.\r\n         Throws if `receiver` is the zero address.\r\n         Throws if `tokenId` is not a valid NFT.\r\n         If `receiver` is a smart contract, it calls `onERC721Received` on `receiver` and throws if\r\n         the return value is not `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`.\r\n         NOTE: bytes4 is represented by bytes32 with padding\r\n    @param owner The current owner of the NFT.\r\n    @param receiver The new owner.\r\n    @param tokenId The NFT to transfer.\r\n    @param data Additional data with no specified format, sent in call to `receiver`.\r\n    \"\"\"\r\n    self._transferFrom(owner, receiver, tokenId, msg.sender)\r\n    if receiver.is_contract: # check if `receiver` is a contract address\r\n        returnValue: bytes32 = ERC721Receiver(receiver).onERC721Received(msg.sender, owner, tokenId, data)\r\n        # Throws if transfer destination is a contract which does not implement 'onERC721Received'\r\n        assert returnValue == method_id(\"onERC721Received(address,address,uint256,bytes)\", output_type=bytes32)\r\n\r\n\r\n@external\r\ndef approve(operator: address, tokenId: uint256):\r\n    \"\"\"\r\n    @dev Set or reaffirm the approved address for an NFT. The zero address indicates there is no approved address.\r\n         Throws unless `msg.sender` is the current NFT owner, or an authorized operator of the current owner.\r\n         Throws if `tokenId` is not a valid NFT. (NOTE: This is not written the EIP)\r\n         Throws if `operator` is the current owner. (NOTE: This is not written the EIP)\r\n    @param operator Address to be approved for the given NFT ID.\r\n    @param tokenId ID of the token to be approved.\r\n    \"\"\"\r\n    # Throws if `tokenId` is not a valid NFT\r\n    owner: address = self.idToOwner[tokenId]\r\n    assert owner != ZERO_ADDRESS\r\n\r\n    # Throws if `operator` is the current owner\r\n    assert operator != owner\r\n\r\n    # Throws if `msg.sender` is not the current owner, or is approved for all actions\r\n    assert owner == msg.sender or (self.isApprovedForAll[owner])[msg.sender]\r\n\r\n    self.idToApprovals[tokenId] = operator\r\n    log Approval(owner, operator, tokenId)\r\n\r\n@external\r\ndef permit(spender: address, tokenId: uint256, deadline: uint256, sig: Bytes[65]) -> bool:\r\n    \"\"\"\r\n    @dev Allow a 3rd party to approve a transfer via EIP-721 message\r\n        Raises if permit has expired\r\n        Raises if `tokenId` is unowned\r\n        Raises if permit is not signed by token owner\r\n        Raises if `nonce` is not the current expected value\r\n        Raises if `sig` is not a supported signature type\r\n    @param spender The approved spender of `tokenId` for the permit\r\n    @param tokenId The token that is being approved\r\n        NOTE: signer is checked against this token's owner\r\n    @param deadline The time limit for which the message is valid for\r\n    @param sig The signature for the message, either in vrs or EIP-2098 form\r\n    @return bool If the operation is successful\r\n    \"\"\"\r\n    # Permit is still valid\r\n    assert block.timestamp <= deadline\r\n\r\n    # Ensure the token is owned by someone\r\n    owner: address = self.idToOwner[tokenId]\r\n    assert owner != ZERO_ADDRESS\r\n\r\n    # Nonce for given token (signer must ensure they use latest)\r\n    nonce: uint256 = self.nonces[tokenId]\r\n\r\n    # Compose EIP-712 message\r\n    message: bytes32 = keccak256(\r\n        _abi_encode(\r\n            0x1901,\r\n            self.DOMAIN_SEPARATOR,\r\n            keccak256(\r\n                _abi_encode(\r\n                    keccak256(\r\n                        \"Permit(address spender,uint256 tokenId,uint256 nonce,uint256 deadline)\"\r\n                    ),\r\n                    spender,\r\n                    tokenId,\r\n                    nonce,\r\n                    deadline,\r\n                )\r\n            )\r\n        )\r\n    )\r\n\r\n    # Validate signature\r\n    v: uint256 = 0\r\n    r: uint256 = 0\r\n    s: uint256 = 0\r\n\r\n    if len(sig) == 65:\r\n        # Normal encoded VRS signatures\r\n        v = convert(slice(sig, 0, 1), uint256)\r\n        r = convert(slice(sig, 1, 32), uint256)\r\n        s = convert(slice(sig, 33, 32), uint256)\r\n\r\n    elif len(sig) == 64:\r\n        # EIP-2098 compact signatures\r\n        r = convert(slice(sig, 0, 32), uint256)\r\n        v = convert(slice(sig, 33, 1), uint256)\r\n        s = convert(slice(sig, 34, 31), uint256)\r\n\r\n    else:\r\n        raise  # Other schemes not supported\r\n\r\n    # Ensure owner signed permit\r\n    assert ecrecover(message, v, r, s) == owner\r\n\r\n    self.nonces[tokenId] = nonce + 1\r\n    self.idToApprovals[tokenId] = spender\r\n\r\n    return True\r\n\r\n@external\r\ndef setApprovalForAll(operator: address, approved: bool):\r\n    \"\"\"\r\n    @dev Enables or disables approval for a third party (\"operator\") to manage all of\r\n         `msg.sender`'s assets. It also emits the ApprovalForAll event.\r\n    @notice This works even if sender doesn't own any tokens at the time.\r\n    @param operator Address to add to the set of authorized operators.\r\n    @param approved True if the operators is approved, false to revoke approval.\r\n    \"\"\"\r\n    self.isApprovedForAll[msg.sender][operator] = approved\r\n    log ApprovalForAll(msg.sender, operator, approved)","ABI":"[{\"name\":\"Transfer\",\"inputs\":[{\"name\":\"sender\",\"type\":\"address\",\"indexed\":true},{\"name\":\"receiver\",\"type\":\"address\",\"indexed\":true},{\"name\":\"tokenId\",\"type\":\"uint256\",\"indexed\":true}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"Approval\",\"inputs\":[{\"name\":\"owner\",\"type\":\"address\",\"indexed\":true},{\"name\":\"approved\",\"type\":\"address\",\"indexed\":true},{\"name\":\"tokenId\",\"type\":\"uint256\",\"indexed\":true}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"ApprovalForAll\",\"inputs\":[{\"name\":\"owner\",\"type\":\"address\",\"indexed\":true},{\"name\":\"operator\",\"type\":\"address\",\"indexed\":true},{\"name\":\"approved\",\"type\":\"bool\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"stateMutability\":\"nonpayable\",\"type\":\"constructor\",\"inputs\":[{\"name\":\"baseURI\",\"type\":\"string\"}],\"outputs\":[]},{\"stateMutability\":\"pure\",\"type\":\"function\",\"name\":\"name\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"string\"}]},{\"stateMutability\":\"pure\",\"type\":\"function\",\"name\":\"symbol\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"string\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"tokenURI\",\"inputs\":[{\"name\":\"tokenId\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"string\"}]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"setDomainSeparator\",\"inputs\":[],\"outputs\":[]},{\"stateMutability\":\"pure\",\"type\":\"function\",\"name\":\"supportsInterface\",\"inputs\":[{\"name\":\"interface_id\",\"type\":\"bytes4\"}],\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"ownerOf\",\"inputs\":[{\"name\":\"tokenId\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"getApproved\",\"inputs\":[{\"name\":\"tokenId\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"transferFrom\",\"inputs\":[{\"name\":\"owner\",\"type\":\"address\"},{\"name\":\"receiver\",\"type\":\"address\"},{\"name\":\"tokenId\",\"type\":\"uint256\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"safeTransferFrom\",\"inputs\":[{\"name\":\"owner\",\"type\":\"address\"},{\"name\":\"receiver\",\"type\":\"address\"},{\"name\":\"tokenId\",\"type\":\"uint256\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"safeTransferFrom\",\"inputs\":[{\"name\":\"owner\",\"type\":\"address\"},{\"name\":\"receiver\",\"type\":\"address\"},{\"name\":\"tokenId\",\"type\":\"uint256\"},{\"name\":\"data\",\"type\":\"bytes\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"approve\",\"inputs\":[{\"name\":\"operator\",\"type\":\"address\"},{\"name\":\"tokenId\",\"type\":\"uint256\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"permit\",\"inputs\":[{\"name\":\"spender\",\"type\":\"address\"},{\"name\":\"tokenId\",\"type\":\"uint256\"},{\"name\":\"deadline\",\"type\":\"uint256\"},{\"name\":\"sig\",\"type\":\"bytes\"}],\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"setApprovalForAll\",\"inputs\":[{\"name\":\"operator\",\"type\":\"address\"},{\"name\":\"approved\",\"type\":\"bool\"}],\"outputs\":[]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"owner\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"isMinter\",\"inputs\":[{\"name\":\"arg0\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"idToOwner\",\"inputs\":[{\"name\":\"arg0\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"balanceOf\",\"inputs\":[{\"name\":\"arg0\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"isApprovedForAll\",\"inputs\":[{\"name\":\"arg0\",\"type\":\"address\"},{\"name\":\"arg1\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"idToApprovals\",\"inputs\":[{\"name\":\"arg0\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"nonces\",\"inputs\":[{\"name\":\"arg0\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"DOMAIN_SEPARATOR\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}]}]","ContractName":"Vyper_contract","CompilerVersion":"vyper:0.3.3","OptimizationUsed":"0","Runs":"0","ConstructorArguments":"00000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000035697066733a2f2f516d5a4c61776e6341705053344353774d54697238583851626e55474d5464574d4766546354337675527a6834560000000000000000000000","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":""}]}