{"status":"1","message":"OK","result":[{"SourceCode":"//SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\n\r\n/////////////////////////////////////////////////////////////////////////\r\n//     __  ___         __  _             __  ___         __       __   //\r\n//    /  |/  /__ _____/ /_(_)__ ____    /  |/  /__ _____/ /_____ / /_  //\r\n//   / /|_/ / _ `/ __/ __/ / _ `/ _ \\  / /|_/ / _ `/ __/  '_/ -_) __/  //\r\n//  /_/  /_/\\_,_/_/  \\__/_/\\_,_/_//_/ /_/  /_/\\_,_/_/ /_/\\_\\\\__/\\__/   //\r\n//                                                by 0xInuarashi.eth   //\r\n/////////////////////////////////////////////////////////////////////////\r\n\r\n/*\r\n    Martian Market by 0xInuarashi for Message to Martians (Martians)\r\n    A Fully functioning on-chain CMS system that can be tapped into front-ends\r\n    and create a responsive website based on contract-specific databases.\r\n\r\n    ** THIS IS A DECENTRALIZED AND TRUSTLESS WHITELIST MARKETPLACE CREATION SYSTEM **\r\n\r\n    We chose not to use a proxy contract as multiple approvals have to be done\r\n    for this contract. In this case, we chose the most decentralized approach\r\n    which is to create an immutable contract with minimal owner access and \r\n    allow full control of contract owners' functions over their own database, \r\n    which is not editable or tamperable even by the Ownable owner themself.\r\n\r\n    >>>> Governance Model <<<<\r\n\r\n        Ownable Owner \r\n            - Set Super Governor Address\r\n            - Renounce Super Governor Address (1-way)\r\n            - Set Governor Address\r\n            - Set $MES Address \r\n\r\n        Super Governor\r\n            - Enable / Disable Projects\r\n            - Set Project Infos \r\n            - Unstuck Owners (On Super Governor Enabled Projects Only)\r\n\r\n        Governor\r\n            - Set Registry Price\r\n            - Set Registry Treasury Address\r\n            - Withdraw $MES from Contract\r\n\r\n        Contract Owner\r\n            - Register Their Contract with $MES\r\n            - Set Project Info\r\n            - Set Treasury Address\r\n            - Set Contract Controllers\r\n            - Add Items \r\n            - Modify Items\r\n            - Remove Items\r\n\r\n        Contract Controller\r\n            - Add Items \r\n            - Modify Items\r\n            - Remove Items\r\n\r\n    >>>> Interfacing <<<<<\r\n\r\n    To draw a front-end interface:\r\n    \r\n        getAllEnabledContracts() - Enumerate all available contracts for selection\r\n        (for contract-specific front-end interfaces, just pull data from your \r\n        contract only)\r\n    \r\n        getWLVendingItemsAll(address contract_) - Enumerate all vending items\r\n        available for the contract. Supports over 1000 items in 1 call but\r\n        if you get gas errors, use a pagination method instead.\r\n\r\n        Pagination method: \r\n        getWLVendingItemsPaginated(address contract_, uint256 start_, uint256 end_)\r\n        for the start_, generally you can use 0, and for end_, inquire from function\r\n        getWLVendingItemsLength(address contract_)\r\n\r\n    For interaction of users:\r\n\r\n        purchaseWLVendingItem(address contract_, uint256 index_) can be used\r\n        and automatically populated to the correct buttons for each WLVendingItem\r\n        for that, an ethers.js call is invoked for the user to call the function\r\n        which will transfer their ERC20 token and add them to the purchasers list\r\n\r\n    For administration:\r\n\r\n        setTreasuryAddress(address contract_, address treasury_) can only be set\r\n        by the contract owner. For this, they are able to set where the ERC20 tokens\r\n        from the whitelist marketplace sales go to. By default, this is 0x...dead\r\n        effectively burning the tokens\r\n\r\n        addWLVendingItem(address contract_, string calldata title_, \r\n        string calldata imageUri_, string calldata projectUri_,\r\n        string calldata description_, uint32 amountAvailable_, uint32 deadline_,\r\n        uint256 price_) is used to create a new WLVendingItem for your contract\r\n        with the details as the input arguments stated.\r\n\r\n        modifyWLVendingItem(address contract_, uint256 index_, \r\n        WLVendingItem memory WLVendingItem_) lets you modify a WLVendingItem.\r\n        You have to pass in a tuple instead. Only use when necessary. Not\r\n        recommended to use.\r\n\r\n        deleteMostRecentWLVendingItem(address contract_) we use a .pop() for this so\r\n        it can only delete the most recent item. For some mistakes that you made and\r\n        want to erase them.\r\n\r\n        manageController(address contract_, address operator_, bool bool_) is a special\r\n        governance function which allows you to add controllers to the contract\r\n        to do actions on your behalf. \r\n*/\r\n\r\nabstract contract Ownable {\r\n    address public owner; \r\n    constructor() { owner = msg.sender; }\r\n    modifier onlyOwner { require(owner == msg.sender, \"Not Owner!\"); _; }\r\n    function transferOwnership(address new_) external onlyOwner { owner = new_; }\r\n}\r\n\r\ninterface IERC721 {\r\n    function balanceOf(address wallet_) external view returns (uint256);\r\n}\r\n\r\ninterface IMartianMarket {\r\n    // For User H1 Access Control\r\n    function isContractOwner(address contract_, address sender_) external\r\n    view returns (bool);\r\n\r\n    // For User H2 Access Control\r\n    function isAuthorized(address contract_, address operator_) external \r\n    view returns (bool);\r\n\r\n    // For Price Controller\r\n    function getFixedPriceOfItem(address contract_, uint256 index_) external \r\n    view returns (uint256);\r\n\r\n    // For Token Controller\r\n    function getDefaultTokenOfContract(address contract_) external \r\n    view returns (address);\r\n}\r\n\r\ncontract MartianMarketOwnershipController is Ownable {\r\n\r\n    // Interface of MM\r\n    IMartianMarket public MM = \r\n        IMartianMarket(0xFD8f4aC172457FD30Df92395BC69d4eF6d92eDd4);\r\n    function setMM(address address_) external onlyOwner {\r\n        MM = IMartianMarket(address_);\r\n    }\r\n\r\n    mapping(address => address[]) public contractToOwnershipTokens;\r\n\r\n    function addContractToOwnershipAccess(address contract_, \r\n    address[] calldata ownerships_) external {\r\n        // They need to be the contract owner\r\n        require(MM.isContractOwner(contract_, msg.sender),\r\n            \"You are not the contract owner!\");\r\n        \r\n        // We replace the array directly with ownerships_ \r\n        // The rationale for this is that, this is simple logic\r\n        // Enumerable is not worth it\r\n        contractToOwnershipTokens[contract_] = ownerships_;\r\n    }\r\n\r\n    function wipeContractToOwnershipAccessData(address contract_) external {\r\n        // They need to be the contract owner\r\n        require(MM.isContractOwner(contract_, msg.sender),\r\n            \"You are not the contract owner!\");\r\n        \r\n        // We delete the entire array for simplicity\r\n        delete contractToOwnershipTokens[contract_];\r\n    }\r\n\r\n    function hasOwnershipOfToken(address contract_, address wallet_) external \r\n    view returns (bool) {\r\n\r\n        address[] memory _ownerships = contractToOwnershipTokens[contract_];\r\n        require(_ownerships.length > 0,\r\n            \"No Ownership Configuration Found!\");\r\n\r\n        for (uint256 i = 0; i < _ownerships.length; i++) {\r\n            if (IERC721(_ownerships[i]).balanceOf(wallet_) > 0) return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n}","ABI":"[{\"inputs\":[],\"name\":\"MM\",\"outputs\":[{\"internalType\":\"contract IMartianMarket\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"contract_\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"ownerships_\",\"type\":\"address[]\"}],\"name\":\"addContractToOwnershipAccess\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"contractToOwnershipTokens\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"contract_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"wallet_\",\"type\":\"address\"}],\"name\":\"hasOwnershipOfToken\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"address_\",\"type\":\"address\"}],\"name\":\"setMM\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"new_\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"contract_\",\"type\":\"address\"}],\"name\":\"wipeContractToOwnershipAccessData\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"MartianMarketOwnershipController","CompilerVersion":"v0.8.7+commit.e28d00a7","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"ipfs://45598933d733f7684e52ec138e828cbbca6aab8d2b012e5a1175746a264e9042"}]}