{"status":"1","message":"OK","result":[{"SourceCode":"{\"CloudChatWallet.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.7;\\n\\nimport \\\"./Ownable.sol\\\";\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"./ReentrancyGuard.sol\\\";\\n\\n/**\\n * CloudChat Official Wallet Contract\\n *\\n * Contract Purpose\\n *\\n * 1. Allocate control of the wallet to multiple individuals and decentralize permissions\\n * 2. The wallet funds locked in the contract, everyone can see the contract\\u0027s * financial status and financial flow\\n *\\n * Contract Process\\n *\\n * Financial wallets are only allowed to submit transfer requests\\n * Multiple bosses approve the transfer request based on\\n * If 2/3 of the bosses agree, the transfer will be executed automatically\\n * If 2/3 of the bosses reject, the transfer will be blocked and rejected\\n * The transfer address is in the contract and cannot be changed by the bosses\\n */\\ncontract CloudChatWallet is Ownable, ReentrancyGuard {\\n    // deposit order struct\\n    struct Order {\\n        // deposit order id\\n        uint256 id;\\n        // from address\\n        address from;\\n        // deposit token address\\n        address token;\\n        // deposit token amount\\n        uint256 amount;\\n        // deposit time\\n        uint256 timestamp;\\n        // is deposit exist\\n        bool exist;\\n    }\\n\\n    // finance wallet address\\n    address public financeWallet;\\n    // hot wallet address\\n    address public hotWallet;\\n    // boss address list\\n    address[] public bosses;\\n    // boss mapping\\n    mapping(address =\\u003e bool) public bossData;\\n    // order mapping buy order id\\n    mapping(uint256 =\\u003e Order) public orders;\\n    // approve apply mapping by token\\n    mapping(address =\\u003e uint256) public approveData;\\n    // boss approve mapping by token\\n    mapping(address =\\u003e address[]) public bossPassedData;\\n    // boss reject mapping by token\\n    mapping(address =\\u003e address[]) public bossRejectedData;\\n\\n    // all the events\\n    event setBossEvent(address boss, bool online);\\n    event setFinanceWalletEvent(address wallet);\\n    event setHotWalletEvent(address wallet);\\n    event DepositSuccess(uint256 id, address indexed from, uint256 value);\\n    event submitTransferApplySuccess(address indexed token, uint256 amount);\\n    event cancelTransferApplySuccess(address indexed token);\\n    event ApproveSuccess(\\n        address indexed token,\\n        address indexed boss,\\n        bool isPass\\n    );\\n    event TransferSuccess(\\n        address indexed token,\\n        address indexed to,\\n        uint256 value\\n    );\\n    event TransferApplyRejected(address indexed token, uint256 value);\\n\\n    modifier onlyFinance() {\\n        require(\\n            financeWallet == _msgSender(),\\n            \\\"Ownable: caller is not the finance\\\"\\n        );\\n        _;\\n    }\\n\\n    modifier onlyBoss() {\\n        require(bossData[_msgSender()], \\\"Ownable: caller is not the boss\\\");\\n        _;\\n    }\\n\\n    /**\\n     * User deposits into the contract\\n     * Use the order id in the centralized server for deposits\\n     */\\n    function deposit(\\n        uint256 id,\\n        address token,\\n        uint256 amount\\n    ) external nonReentrant {\\n        require(!orders[id].exist, \\\"CCError: The order already exists\\\");\\n        bool success = IERC20(token).transferFrom(\\n            msg.sender,\\n            address(this),\\n            amount\\n        );\\n        require(success, \\\"CCError: transfer failed\\\");\\n        orders[id] = Order(\\n            id,\\n            msg.sender,\\n            token,\\n            amount,\\n            block.timestamp,\\n            true\\n        );\\n        emit DepositSuccess(id, msg.sender, amount);\\n    }\\n\\n    /**\\n     * Set up the boss list\\n     * Add or remove\\n     */\\n    function setBoss(address boss, bool online) external onlyOwner {\\n        require(boss != address(0), \\\"CCError: boss can not be zero\\\");\\n        for (uint256 i = 0; i \\u003c bosses.length; i++) {\\n            if (bosses[i] == boss) {\\n                if (online) return;\\n                bosses[i] = bosses[bosses.length - 1];\\n                bosses.pop();\\n                delete bossData[boss];\\n                emit setBossEvent(boss, online);\\n                return;\\n            }\\n        }\\n        if (online) {\\n            bossData[boss] = true;\\n            bosses.push(boss);\\n            emit setBossEvent(boss, online);\\n        }\\n    }\\n\\n    /**\\n     * Set up a financial wallet\\n     */\\n    function setFinanceWallet(address wallet) external onlyOwner {\\n        require(wallet != address(0), \\\"CCError: wallet can not be zero\\\");\\n        financeWallet = wallet;\\n        emit setFinanceWalletEvent(wallet);\\n    }\\n\\n    /**\\n     * Set up a hot wallet\\n     * The contracted funds will be transferred to this address\\n     */\\n    function setHotWallet(address wallet) external onlyOwner {\\n        require(wallet != address(0), \\\"CCError: wallet can not be zero\\\");\\n        hotWallet = wallet;\\n        emit setHotWalletEvent(wallet);\\n    }\\n\\n    /**\\n     * Financial address to submit transfer request\\n     */\\n    function submitTransferApply(address token, uint256 amount)\\n        external\\n        onlyFinance\\n    {\\n        require(\\n            approveData[token] == 0,\\n            \\\"CCError: Applications for this token have been submitted\\\"\\n        );\\n        require(\\n            IERC20(token).balanceOf(address(this)) \\u003e amount,\\n            \\\"CCError: Insufficient token balance\\\"\\n        );\\n        approveData[token] = amount;\\n        bossPassedData[token] = new address[](0);\\n        bossRejectedData[token] = new address[](0);\\n        emit submitTransferApplySuccess(token, amount);\\n    }\\n\\n    /**\\n     * Reset approve data\\n     */\\n    function resetApproveData(address token) private {\\n        delete approveData[token];\\n        delete bossPassedData[token];\\n    }\\n\\n    /**\\n     * Financial address cancellation transfer request\\n     */\\n    function cancelTransferApply(address token) external onlyFinance {\\n        require(\\n            approveData[token] \\u003e 0,\\n            \\\"CCError: There are no cancellable applications at this time\\\"\\n        );\\n        resetApproveData(token);\\n        emit cancelTransferApplySuccess(token);\\n    }\\n\\n    /**\\n     * Check if the current boss has approved or rejected\\n     */\\n    function isBossApproved(address token) public view returns (bool) {\\n        for (uint256 i = 0; i \\u003c bossPassedData[token].length; i++) {\\n            if (bossPassedData[token][i] == msg.sender) {\\n                return true;\\n            }\\n        }\\n        for (uint256 i = 0; i \\u003c bossRejectedData[token].length; i++) {\\n            if (bossRejectedData[token][i] == msg.sender) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n\\n    /**\\n     * Get the final approval\\n     * 3 types of results:\\n     * approved: 1\\n     * rejected: 2\\n     * approval in progress: 0\\n     */\\n    function getApproveResult(address token) public view returns (uint256) {\\n        uint256 approvedCount = bossPassedData[token].length;\\n        uint256 rejectedCount = bossRejectedData[token].length;\\n        uint256 count = (bosses.length * 2) / 3;\\n        if (approvedCount \\u003e= count) return 1;\\n        if (rejectedCount \\u003e= count) return 2;\\n        return 0;\\n    }\\n\\n    /**\\n     * The boss performs the operation of approval\\n     * Pass or reject this apply\\n     */\\n    function transferApprove(address token, bool isPass)\\n        external\\n        onlyBoss\\n        nonReentrant\\n    {\\n        require(approveData[token] \\u003e 0, \\\"CCError: Approval cannot be made\\\");\\n        require(\\n            !isBossApproved(token),\\n            \\\"CCError: The current boss has already been approved\\\"\\n        );\\n        if (isPass) {\\n            bossPassedData[token].push(msg.sender);\\n        } else {\\n            bossRejectedData[token].push(msg.sender);\\n        }\\n        emit ApproveSuccess(token, msg.sender, isPass);\\n        // check and execute the action of approval completion\\n        uint256 approveResult = getApproveResult(token);\\n        if (approveResult == 1) {\\n            uint256 amount = approveData[token];\\n            bool success = IERC20(token).transfer(hotWallet, amount);\\n            require(success, \\\"CCError: transfer failed\\\");\\n            resetApproveData(token);\\n            emit TransferSuccess(token, hotWallet, amount);\\n        } else if (approveResult == 2) {\\n            uint256 amount = approveData[token];\\n            resetApproveData(token);\\n            emit TransferApplyRejected(token, amount);\\n        }\\n    }\\n}\\n\"},\"Context.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n}\\n\"},\"IERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\ninterface IERC20 {\\n    function totalSupply() external view returns (uint256);\\n\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    function allowance(address owner, address spender)\\n        external\\n        view\\n        returns (uint256);\\n\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    event Approval(\\n        address indexed owner,\\n        address indexed spender,\\n        uint256 value\\n    );\\n}\\n\"},\"Ownable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./Context.sol\\\";\\n\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(\\n        address indexed previousOwner,\\n        address indexed newOwner\\n    );\\n\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    function renounceOwnership() external virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    function transferOwnership(address newOwner) external virtual onlyOwner {\\n        require(\\n            newOwner != address(0),\\n            \\\"Ownable: new owner is the zero address\\\"\\n        );\\n        _transferOwnership(newOwner);\\n    }\\n\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"},\"ReentrancyGuard.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n */\\nabstract contract ReentrancyGuard {\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\n    // word because each write operation emits an extra SLOAD to first read the\\n    // slot\\u0027s contents, replace the bits taken up by the boolean, and then write\\n    // back. This is the compiler\\u0027s defense against contract upgrades and\\n    // pointer aliasing, and it cannot be disabled.\\n\\n    // The values being non-zero value makes deployment a bit more expensive,\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\n    // amount. Since refunds are capped to a percentage of the total\\n    // transaction\\u0027s gas, it is best to keep them low in cases like this one, to\\n    // increase the likelihood of the full refund coming into effect.\\n    uint256 private constant _NOT_ENTERED = 1;\\n    uint256 private constant _ENTERED = 2;\\n\\n    uint256 private _status;\\n\\n    constructor() {\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and making it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        // On the first call to nonReentrant, _notEntered will be true\\n        require(_status != _ENTERED, \\\"ReentrancyGuard: reentrant call\\\");\\n\\n        // Any calls to nonReentrant after this point will fail\\n        _status = _ENTERED;\\n\\n        _;\\n\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _status = _NOT_ENTERED;\\n    }\\n}\\n\"}}","ABI":"[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"boss\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isPass\",\"type\":\"bool\"}],\"name\":\"ApproveSuccess\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"DepositSuccess\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"TransferApplyRejected\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"TransferSuccess\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"cancelTransferApplySuccess\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"boss\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"online\",\"type\":\"bool\"}],\"name\":\"setBossEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"}],\"name\":\"setFinanceWalletEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"}],\"name\":\"setHotWalletEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"submitTransferApplySuccess\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"approveData\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"bossData\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"bossPassedData\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"bossRejectedData\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"bosses\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"cancelTransferApply\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"deposit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"financeWallet\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"getApproveResult\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"hotWallet\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"isBossApproved\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"orders\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"exist\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"boss\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"online\",\"type\":\"bool\"}],\"name\":\"setBoss\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"}],\"name\":\"setFinanceWallet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"}],\"name\":\"setHotWallet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"submitTransferApply\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"isPass\",\"type\":\"bool\"}],\"name\":\"transferApprove\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"CloudChatWallet","CompilerVersion":"v0.8.15+commit.e14f2714","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"ipfs://3d7f7d4841e36bba130f8bb73a3f6e3bd6a98907ada5c600ddc27fadfe88933b"}]}