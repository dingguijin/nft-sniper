{"status":"1","message":"OK","result":[{"SourceCode":"# @version >=0.3.3\r\n\"\"\"\r\n@title The Bit Tulip Contract\r\n@dev Implementation of ERC-1155 non-fungible token standard ownable, with approval, OPENSEA compatible (name, symbol)\r\n@author Dr. Pixel (github: @Doc-Pixel) -- modified by Josh Cincinnati (github: @acityinohio)\r\n\"\"\"\r\n############### imports ###############\r\nfrom vyper.interfaces import ERC165\r\n\r\n############### variables ###############\r\n# maximum items in a batch call. Set to 128, to be determined what the practical limits are.\r\nBATCH_SIZE: constant(uint256) = 128             \r\n\r\n# callback number of bytes\r\nCALLBACK_NUMBYTES: constant(uint256) = 4096\r\n\r\n# URI length set to 10000. (yay on-chain) \r\nMAX_URI_LENGTH: constant(uint256) = 10000       \r\n\r\n# the contract owner\r\n# not part of the core spec but a common feature for NFT projects\r\nowner: public(address)                          \r\n\r\n# pause status True / False\r\n# not part of the core spec but a common feature for NFT projects\r\npaused: public(bool)                            \r\n\r\n# the contracts URI to find the metadata\r\n_uri: String[MAX_URI_LENGTH]\r\n\r\n# NFT marketplace compatibility\r\nname: public(String[128])\r\nsymbol: public(String[16])\r\n\r\n# Interface IDs\r\nERC165_INTERFACE_ID: constant(bytes4)  = 0x01ffc9a7\r\nERC1155_INTERFACE_ID: constant(bytes4) = 0xd9b67a26\r\nERC1155_INTERFACE_ID_METADATA: constant(bytes4) = 0x0e89341c\r\n\r\n# mappings\r\n\r\n# Mapping from token ID to account balances\r\nbalanceOf: public(HashMap[address, HashMap[uint256, uint256]])\r\n\r\n# Mapping from account to operator approvals\r\nisApprovedForAll: public( HashMap[address, HashMap[address, bool]])\r\n\r\n############### events ###############\r\nevent Paused:\r\n    # Emits a pause event with the address that paused the contract\r\n    account: address\r\n\r\nevent unPaused:\r\n    # Emits an unpause event with the address that paused the contract\r\n    account: address\r\n\r\nevent OwnershipTransferred:\r\n    # Emits smart contract ownership transfer from current to new owner\r\n    previousOwner: address \r\n    newOwner: address\r\n\r\nevent TransferSingle:\r\n    # Emits on transfer of a single token\r\n    operator:   indexed(address)\r\n    fromAddress: indexed(address)\r\n    to: indexed(address)\r\n    id: uint256\r\n    value: uint256\r\n\r\nevent TransferBatch:\r\n    # Emits on batch transfer of tokens. the ids array correspond with the values array by their position\r\n    operator: indexed(address) # indexed\r\n    fromAddress: indexed(address)\r\n    to: indexed(address)\r\n    ids: DynArray[uint256, BATCH_SIZE]\r\n    values: DynArray[uint256, BATCH_SIZE]\r\n\r\nevent ApprovalForAll:\r\n    # This emits when an operator is enabled or disabled for an owner. The operator manages all tokens for an owner\r\n    account: indexed(address)\r\n    operator: indexed(address)\r\n    approved: bool\r\n\r\nevent URI:\r\n    # This emits when the URI gets changed\r\n    value: String[MAX_URI_LENGTH]\r\n    id: uint256\r\n\r\n############### interfaces ###############\r\nimplements: ERC165\r\n\r\ninterface IERC1155Receiver:\r\n    def onERC1155Received(\r\n       operator: address,\r\n       sender: address,\r\n       id: uint256,\r\n       amount: uint256,\r\n       data: Bytes[CALLBACK_NUMBYTES],\r\n   ) -> bytes32: payable\r\n    def onERC1155BatchReceived(\r\n        operator: address,\r\n        sender: address,\r\n        ids: DynArray[uint256, BATCH_SIZE],\r\n        amounts: DynArray[uint256, BATCH_SIZE],\r\n        data: Bytes[CALLBACK_NUMBYTES],\r\n    ) -> bytes4: payable\r\n\r\ninterface IERC1155MetadataURI:\r\n    def uri(id: uint256) -> String[MAX_URI_LENGTH]: view\r\n\r\n############### functions ###############\r\n\r\n@external\r\ndef __init__():\r\n    \"\"\"\r\n    @dev contract initialization on deployment\r\n    @dev will set name and symbol, interfaces, owner and URI\r\n    @dev self.paused will default to false\r\n    @dev rather than use params, setting all info here manually\r\n    @param name the smart contract name\r\n    @param symbol the smart contract symbol\r\n    @param uri the new uri for the contract\r\n    \"\"\"\r\n    self.name = \"Bit Tulip\"\r\n    self.symbol = \"BITTULIP\"\r\n    self.owner = msg.sender\r\n    # base64 encoded string for URI\r\n    self._uri = \"data:application/json;base64,ewogICJuYW1lIjoiQml0IFR1bGlwIiwKICAiZGVzY3JpcHRpb24iOiJBbiBvbi1jaGFpbiByZXByZXNlbnRhdGlvbiBvZiBhIHR1bGlwIHRoYXQgc2lnbmlmaWVzIHBhcnRpY2lwYXRpb24gaW4gdGhlIGJpdGJhbnRlciBib29rIHJhZmZsZS4gVmFsdWUgdW5jbGVhci4iLAogICJpbWFnZSI6ImRhdGE6aW1hZ2UvcG5nO2Jhc2U2NCxpVkJPUncwS0dnb0FBQUFOU1VoRVVnQUFBUUFBQUFFQUNBWUFBQUJjY3FobUFBQUFCbUpMUjBRQS93RC9BUCtndmFlVEFBQUFDWEJJV1hNQUFDNGpBQUF1SXdGNHBUOTJBQUFBQjNSSlRVVUg1Z1lLRVRnT0FmY2ZRQUFBQUJsMFJWaDBRMjl0YldWdWRBQkRjbVZoZEdWa0lIZHBkR2dnUjBsTlVGZUJEaGNBQUFseFNVUkJWSGphN2QxYmpGeDFIUWZ3bloyWjNiYmI3bTRSWVZ0NkI5bzBhckVJZ2FCQlJVbElUQXdSTldvaTFLREdpTUZJWWtpODRRdUphQ1NpeEFpbW9ieWdDVEVOSWhFRHlJTkU0d04zVWxvdXRSZlVVbWwzdXp1NzNabWQzZlhKRnhOL2Y1TS9wMmQyNXZONS9hWTc1emJmL2lmLy96bW4wdGZYdDloSDE2cFVxMkcrT0Q4ZjVuZmR0alBNZi9tcmcyRys3N1hKTUY5WWNQbVZxZDhoQUFVQUtBQkFBUUFLQUZBQWdBSUF1azJ0MXcvQXVuUGpRL0RkcjIwTDg0TkhwOFA4am5zUGxicC9xWG4rM1hkY0h1YVhYYlFxekk4ZE94SG1ieHlMajgvRVpMdlEvZi9pcDllRWVhV3ZFdWEvZnVSNG1FOU50NWYwOVc4RUFINENBQW9BVUFDQUFnQVVBS0FBZ0s1VDZldng1d0hzMkRZWTVyKzk5d05odnZIS3g0czlRWlY0bm5yOW1tVmgvdURQRS9QODF6Nlp0WDNOMlhpZS80T1hqWVg1WDE5b1pIMys5ZGVlRStiMzczMHo2KzkvODB1Yncvekh1dytIK2VKaVozKzlqQURBVHdCQUFRQUtBRkFBZ0FJQUZBRFFkVHIrZVFCYjFzZjNveDg4T3BYM0FZbHAyc1pNM3YzZXFYbjgxRHh4S3IvdmpvdkMvTktQUFZMcTltOWVINit6U0swRHVQN2FjOFA4L3IzSENyMytUazAydzN4NEtENCtweHJXQVFBS0FGQUFnQUlBRkFDZ0FBQUZBSnhScGE4RDJMeHVaWmkvZm1ReTYrOWZzWE0wekhkOWNsMllGMzA3ZCs0OCt4ZHVmYjdRN2N1OW4zMzhWTHlPWXNmV2VKMUE3anovMnJGNEhjRS9qc1hQQzdodzg0b3czM3ZQKzhQOGQzODhHdVozN2o1a0JBQW9BRUFCQUFvQVVBQ0FBZ0FVQVBCMjZ2ajNBcFQ5WFBXWEgvdG9tRy85MEVOaFhodFkyZEg3dCtRdjRNUTZpcUt2cjJQUGZEYk1ILzc5eTJIKzVlODhYK3J4TXdJQVB3RUFCUUFvQUVBQkFBb0FVQUJBMXluOWVRQkZ6NFBuM20rLy9lckhPM3IveHNiV2h2bmtWUHc4aGY3KytQK0E2Y1pVcWZ0ZjlqeC95aXNIM2dqekg5N3pzaEVBb0FBQUJRQW9BRUFCQUFvQVVBREFtVlRyOVFQUTZmUE1LZU1UNDFuYmw4b0hseTJQTDZCYWIxOUMrMTZOMTFuTXpIYjI4eDZNQU1CUEFFQUJBQW9BVUFDQUFnQVVBTkIxU3AvRXZmUGI3d3Z6VzI1L3VxTVBZTzd6QnJJYnZCSjMrUHpDZkppMzU5cnh2Mi9ILzc3VmJJWDV5T2pxTUQrVnVZNmg3UE8zL2Z6QjFDY1lBUUFLQUZBQWdBSUFGQUNnQUFBRkFKeEp5WFVBd3l2cllUN1ptTXZhZ0FjZWVqWE1iN2w5YVIvZ290Y0p6TTdPaEhtOUhzOVRwOTRMa05xKzFQNU5ucHJvNk9PZmEzNStNWEY4UFE4QVVBQ0FBZ0FVQUtBQUFBVUFLQURnakVxdUF6ZzFGZC92dldQN1dXSCs0djc0ZnUrM3htZkQvTkU5SHduemEzWTlzYVJQUU80NmdkeDUrdFE2Z2R6UEwvdjREUTdrcllOSWZqOGFDMkcrZnMxQW1JK3NUSnoveFBNRWpwL3NTM3kvbWtZQWdBSUFGQUNnQUFBRkFBb0FVQUJBYjZuMDlmV0ZFN2xGei9OdVdiOHN6SGRkdHlITXYvZVRWL0lPUUtXeXBFOWc3dmxKN2YvQVFIeCtXcTNaVXJldlZxc25ML0RJWEh1dXI4enJ2MmhEcTVZYkFRQUtBRkFBZ0FJQUZBQW9BRUFCQUwwbCtUeUFSL2Q4T015djJmVmsxZ1ljUERwYjZnSEl2WjgrWmZsZ2ZEOTZlejYrbnp3MVQxMzBld2ZxdFdxWU41dkZ6dk12VzdZODhmbng4eXFxMWY1Q3Q2OXNxZk03dW1yQUNBQlFBSUFDQUJRQW9BQkFBUUFLQU9ndHllY0JiTnN5RXY2Qi9hL252Zjg5ZDU2MTArL1hIbGs1Rk9iTnVjVDk2SlY0SHI3VnpMc2Z2K2gxQkxubnQxYUw1N0hiN1ZaWGYwRnpqLy9veUtBUkFLQUFBQVVBS0FCQUFZQUNBQlFBMEZ1UzZ3QlNidDYxTGN6dnVtOS8xZ1p1MnJBbXpFZFd4UFBFTHh3NGt2WDV1Zk93bCsvY0d1YlA3VHVVT0VOeFJ6ZWJ6VUszUDNrQkxmSDNLaFN0Nk9OLzRZYjR2UWl2SFcwYkFRQUtBRkFBZ0FJQUZBQW9BRUFCQUwwbGV4MUF5azAzdkRmTTc5N3piS0U3dUduanVqQS9mT1R2V1g4L2Q1NzN2TEYzaFBuRTVFejgrWWwxQXFuTk96MHpuWGNCWmE0REdCcGFGZWJUMDFPbGZrR0tuc2ZmODZOM2gvbWJiN1grajYvdy96YlZXRFFDQUJRQW9BQUFCUUFvQUZBQWdBSUFla3ZoNndCU05tMko1K2x2L3Z5N3d2d2IzMyswcDAvZzhLcmhNSitjbW5TVll3UUFLQUJBQVFBS0FCUUFvQUFBQlFEMGp0TFhBZFRydFRDLytvcjR2UUNYdkdkRm1HKy80T3d3Lzh6WG40b1BVTW5QdlMvN3VmNUZmMzdIZjBHNi9Qd2JBWUNmQUlBQ0FCUUFvQUFBQlFBb0FLRHIxTXJlZ0tzdUh3bnpTM2ZFOC95My91RHB1T0ZLcnJpUmtlR3NmMy9XNnRFd1B6aytFZWE1OC94bHo0T1hyZFBYUWVTZUh5TUE4Qk1BVUFDQUFnQVVBS0FBQUFVQWRKM3NkUUMxV2pYTWIvelUrakQveFFOL0szUUhMN2w0WjVnLy9leHpoWDcrZkxzZDV0VnFmUHlXMWVPT0xucWV2dGVmQjNCNlpqck1iN254Z2pCLzdLbTN3dnoxTjlwR0FJQUNBQlFBb0FBQUJRQW9BRUFCQUcrbjdQY0NiTjI4S3N6M0hmaG5tRmZyUS9FR2R2bjk2TDArejU3clcxL1pHT1lueHB0aC9zU2ZUOFQvZm1JaHpDY2FDMFlBZ0FJQUZBQ2dBQUFGQUNnQVFBRUFuU1I3SFVCLzRuNzJyOTV3YVpqL2JQZGZuSVdjRTVpNVRtTG54UmVIK2JQUFBKUDE5M1BYT2R4OTI0VmgvdE05aDhMODFTTnRGNGtSQUtBQUFBVUFLQUJRQUE0QktBQkFBUUM5SkhzZFFLNXE0cjBDdFVSRlZmdmp6VDkvdzBDWXYzRGc5TkkrZ1puckFGYVBqb1o1YXk2ZVI1K2VibVI5ZnU0NmdXMmI2bUgreW1IckFJd0FBQVVBS0FCQUFRQUtBQlFBb0FDQW5sTDZPb0N5blROMmRwaWYrODc0dlFmbmpRMkhlYTBTcnpONCtBOEg4azVnd2U5TkdCbU85Mjh1c1U1ZzV2Uk0xdWZucmhQbzl2ZEtHQUVBQ2dCUUFJQUNBQlFBb0FBQUJRRDhsNTVmQjNCR2puQmdjYUhZdzkvdDgrQ3BkUUl6TTlOaHZubkQ2akEvZm1MT0NBQlFBSUFDQUJRQW9BQUFCUUFvQUdBcHNRNmdZTlY2L042RGRxdmM1OVl2dE9QNzlSZm1Fdmw4blBmWFZtVGwyZnVYV0dmeDFHK3VDdlByYm5vcHpFK096eXpwNjlNSUFQd0VBQlFBb0FBQUJRQW9BRUFCQUYybjVoQVVhKzNhTlZuL1BuVS9mKzV6OC8vMS9PZkNmSzUxT3JHQjFjejk2MHZzWDV5M1cvSDkrc2RQTnNQOHhmMVRZVDdaYUJvQkFBb0FVQUNBQWdBVUFLQUFBQVVBTENXZUIxQ3dScU1SNWtORFEvRUp5bHdIY09VblBoN21mOXI3c0pOa0JBQW9BRUFCQUFvQVVBQ0FBZ0FVQU5BOVBBOGdVNlUvbnFmUG5lZlBkZmlsbDV3a2pBQUFCUUFvQUVBQmdBSUFGQUNnQUlEZTRYa0FtZXJMNjJIZW1tbkZKeUJ6SFVEcWVRQkZyelBBQ0FCUUFJQUNBQlFBb0FBQUJRQW9BS0NqV0FlUUtUVVBuendCbWMvOXovMzdHQUVBQ2dCUUFJQUNBQlFBb0FBQUJRQjBGZThGU0IyZ3dXSVBVZTQ4ZjMydzZpUmhCQUFvQUVBQkFBb0FVQUNBQWdBVUFQQWYvd1pVRTF1Q21vWFYxd0FBQUFCSlJVNUVya0pnZ2c9PSIKfQo=\"\r\n\r\n## contract status ##\r\n@external\r\ndef pause():\r\n    \"\"\"\r\n    @dev Pause the contract, checks if the caller is the owner and if the contract is paused already\r\n    @dev emits a pause event \r\n    @dev not part of the core spec but a common feature for NFT projects\r\n    \"\"\"\r\n    assert self.owner == msg.sender, \"Ownable: caller is not the owner\"\r\n    assert not self.paused, \"the contract is already paused\"\r\n    self.paused = True\r\n    log Paused(msg.sender)\r\n\r\n@external\r\ndef unpause():\r\n    \"\"\"\r\n    @dev Unpause the contract, checks if the caller is the owner and if the contract is paused already\r\n    @dev emits an unpause event \r\n    @dev not part of the core spec but a common feature for NFT projects\r\n    \"\"\"\r\n    assert self.owner == msg.sender, \"Ownable: caller is not the owner\"\r\n    assert self.paused, \"the contract is not paused\"\r\n    self.paused = False\r\n    log unPaused(msg.sender)\r\n\r\n## ownership ##\r\n@external\r\ndef transferOwnership(newOwner: address):\r\n    \"\"\"\r\n    @dev Transfer the ownership. Checks for contract pause status, current owner and prevent transferring to\r\n    @dev zero address\r\n    @dev emits an OwnershipTransferred event with the old and new owner addresses\r\n    @param newOwner The address of the new owner.\r\n    \"\"\"\r\n    assert not self.paused, \"The contract has been paused\"\r\n    assert self.owner == msg.sender, \"Ownable: caller is not the owner\"\r\n    assert newOwner != self.owner, \"This account already owns the contract\"\r\n    assert newOwner != ZERO_ADDRESS, \"Transfer to ZERO_ADDRESS not allowed. Use renounceOwnership() instead.\"\r\n    oldOwner: address = self.owner\r\n    self.owner = newOwner\r\n    log OwnershipTransferred(oldOwner, newOwner)\r\n\r\n@external\r\ndef renounceOwnership():\r\n    \"\"\"\r\n    @dev Transfer the ownership to ZERO_ADDRESS, this will lock the contract\r\n    @dev emits an OwnershipTransferred event with the old and new ZERO_ADDRESS owner addresses\r\n    \"\"\"\r\n    assert not self.paused, \"The contract has been paused\"\r\n    assert self.owner == msg.sender, \"Ownable: caller is not the owner\"\r\n    oldOwner: address = self.owner\r\n    self.owner = ZERO_ADDRESS\r\n    log OwnershipTransferred(oldOwner, ZERO_ADDRESS)\r\n\r\n@external\r\n@view\r\ndef balanceOfBatch(accounts: DynArray[address, BATCH_SIZE], ids: DynArray[uint256, BATCH_SIZE]) -> DynArray[uint256,BATCH_SIZE]:  # uint256[BATCH_SIZE]:\r\n    \"\"\"\r\n    @dev check the balance for an array of specific IDs and addresses\r\n    @dev will return an array of balances\r\n    @dev Can also be used to check ownership of an ID\r\n    @param accounts a dynamic array of the addresses to check the balance for\r\n    @param ids a dynamic array of the token IDs to check the balance\r\n    \"\"\"\r\n    assert len(accounts) == len(ids), \"ERC1155: accounts and ids length mismatch\"\r\n    batchBalances: DynArray[uint256, BATCH_SIZE] = []\r\n    j: uint256 = 0\r\n    for i in ids:\r\n        batchBalances.append(self.balanceOf[accounts[j]][i])\r\n        j += 1\r\n    return batchBalances\r\n\r\n## mint ##\r\n@external\r\ndef mint(receiver: address, id: uint256, amount:uint256, data:bytes32):\r\n    \"\"\"\r\n    @dev mint one new token with a certain ID\r\n    @dev this can be a new token or \"topping up\" the balance of a non-fungible token ID\r\n    @param receiver the account that will receive the minted token\r\n    @param id the ID of the token\r\n    @param amount of tokens for this ID\r\n    @param data the data associated with this mint. Usually stays empty\r\n    \"\"\"\r\n    assert not self.paused, \"The contract has been paused\"\r\n    assert self.owner == msg.sender, \"Only the contract owner can mint\"\r\n    assert receiver != ZERO_ADDRESS, \"Can not mint to ZERO ADDRESS\"\r\n    operator: address = msg.sender\r\n    self.balanceOf[receiver][id] += amount\r\n    log TransferSingle(operator, ZERO_ADDRESS, receiver, id, amount)\r\n\r\n\r\n@external\r\ndef mintBatch(receiver: address, ids: DynArray[uint256, BATCH_SIZE], amounts: DynArray[uint256, BATCH_SIZE], data: bytes32):\r\n    \"\"\"\r\n    @dev mint a batch of new tokens with the passed IDs\r\n    @dev this can be new tokens or \"topping up\" the balance of existing non-fungible token IDs in the contract\r\n    @param receiver the account that will receive the minted token\r\n    @param ids array of ids for the tokens\r\n    @param amounts amounts of tokens for each ID in the ids array\r\n    @param data the data associated with this mint. Usually stays empty\r\n    \"\"\"\r\n    assert not self.paused, \"The contract has been paused\"\r\n    assert self.owner == msg.sender, \"Only the contract owner can mint\"\r\n    assert receiver != ZERO_ADDRESS, \"Can not mint to ZERO ADDRESS\"\r\n    assert len(ids) == len(amounts), \"ERC1155: ids and amounts length mismatch\"\r\n    operator: address = msg.sender\r\n    \r\n    for i in range(BATCH_SIZE):\r\n        if i >= len(ids):\r\n            break\r\n        self.balanceOf[receiver][ids[i]] += amounts[i]\r\n    \r\n    log TransferBatch(operator, ZERO_ADDRESS, receiver, ids, amounts)\r\n\r\n## burn ##\r\n@external\r\ndef burn(id: uint256, amount: uint256):\r\n    \"\"\"\r\n    @dev burn one or more token with a certain ID\r\n    @dev the amount of tokens will be deducted from the holder's balance\r\n    @param receiver the account that will receive the minted token\r\n    @param id the ID of the token to burn\r\n    @param amount of tokens to burnfor this ID\r\n    \"\"\"\r\n    assert not self.paused, \"The contract has been paused\"\r\n    assert self.balanceOf[msg.sender][id] > 0 , \"caller does not own this ID\"\r\n    self.balanceOf[msg.sender][id] -= amount\r\n    log TransferSingle(msg.sender, msg.sender, ZERO_ADDRESS, id, amount)\r\n    \r\n@external\r\ndef burnBatch(ids: DynArray[uint256, BATCH_SIZE], amounts: DynArray[uint256, BATCH_SIZE]):\r\n    \"\"\"\r\n    @dev burn a batch of tokens with the passed IDs\r\n    @dev this can be burning non fungible tokens or reducing the balance of existing non-fungible token IDs in the contract\r\n    @dev inside the loop ownership will be checked for each token. We can not burn tokens we do not own\r\n    @param ids array of ids for the tokens to burn\r\n    @param amounts array of amounts of tokens for each ID in the ids array\r\n    \"\"\"\r\n    assert not self.paused, \"The contract has been paused\"\r\n    assert len(ids) == len(amounts), \"ERC1155: ids and amounts length mismatch\"\r\n    operator: address = msg.sender \r\n    \r\n    for i in range(BATCH_SIZE):\r\n        if i >= len(ids):\r\n            break\r\n        self.balanceOf[msg.sender][ids[i]] -= amounts[i]\r\n    \r\n    log TransferBatch(msg.sender, msg.sender, ZERO_ADDRESS, ids, amounts)\r\n\r\n## approval ##\r\n@external\r\ndef setApprovalForAll(owner: address, operator: address, approved: bool):\r\n    \"\"\"\r\n    @dev set an operator for a certain NFT owner address\r\n    @param account the NFT owner address\r\n    @param operator the operator address\r\n    \"\"\"\r\n    assert owner == msg.sender, \"You can only set operators for your own account\"\r\n    assert not self.paused, \"The contract has been paused\"\r\n    assert owner != operator, \"ERC1155: setting approval status for self\"\r\n    self.isApprovedForAll[owner][operator] = approved\r\n    log ApprovalForAll(owner, operator, approved)\r\n\r\n@external\r\ndef safeTransferFrom(sender: address, receiver: address, id: uint256, amount: uint256, bytes: bytes32):\r\n    \"\"\"\r\n    @dev transfer token from one address to another.\r\n    @param sender the sending account (current owner)\r\n    @param receiver the receiving account\r\n    @param id the token id that will be sent\r\n    @param amount the amount of tokens for the specified id\r\n    \"\"\"\r\n    assert not self.paused, \"The contract has been paused\"\r\n    assert receiver != ZERO_ADDRESS, \"ERC1155: transfer to the zero address\"\r\n    assert sender != receiver\r\n    assert sender == msg.sender or self.isApprovedForAll[sender][msg.sender], \"Caller is neither owner nor approved operator for this ID\"\r\n    assert self.balanceOf[sender][id] > 0 , \"caller does not own this ID or ZERO balance\"\r\n    operator: address = msg.sender\r\n    self.balanceOf[sender][id] -= amount\r\n    self.balanceOf[receiver][id] += amount\r\n    log TransferSingle(operator, sender, receiver, id, amount)\r\n\r\n@external\r\ndef safeBatchTransferFrom(sender: address, receiver: address, ids: DynArray[uint256, BATCH_SIZE], amounts: DynArray[uint256, BATCH_SIZE], _bytes: bytes32):\r\n    \"\"\"\r\n    @dev transfer tokens from one address to another.\r\n    @param sender the sending account\r\n    @param receiver the receiving account\r\n    @param ids a dynamic array of the token ids that will be sent\r\n    @param amounts a dynamic array of the amounts for the specified list of ids.\r\n    \"\"\"\r\n    assert not self.paused, \"The contract has been paused\"\r\n    assert receiver != ZERO_ADDRESS, \"ERC1155: transfer to the zero address\"\r\n    assert sender != receiver\r\n    assert sender == msg.sender or self.isApprovedForAll[sender][msg.sender], \"Caller is neither owner nor approved operator for this ID\"\r\n    assert len(ids) == len(amounts), \"ERC1155: ids and amounts length mismatch\"\r\n    operator: address = msg.sender\r\n    for i in range(BATCH_SIZE):\r\n        if i >= len(ids):\r\n            break\r\n        id: uint256 = ids[i]\r\n        amount: uint256 = amounts[i]\r\n        self.balanceOf[sender][id] -= amount\r\n        self.balanceOf[receiver][id] += amount\r\n    \r\n    log TransferBatch(operator, sender, receiver, ids, amounts)\r\n\r\n# URI #\r\n@external\r\ndef setURI(uri: String[MAX_URI_LENGTH]):\r\n    \"\"\"\r\n    @dev set the URI for the contract\r\n    @param uri the new uri for the contract\r\n    \"\"\"\r\n    assert not self.paused, \"The contract has been paused\"\r\n    assert self._uri != uri, \"new and current URI are identical\"\r\n    assert msg.sender == self.owner, \"Only the contract owner can update the URI\"\r\n    self._uri = uri\r\n    log URI(uri, 0)\r\n\r\n@external\r\n@view\r\ndef uri(id: uint256) -> String[MAX_URI_LENGTH]:\r\n    \"\"\"\r\n    @dev retrieve the uri, this function can optionally be extended to return dynamic uris. out of scope.\r\n    @param id NFT ID to retrieve the uri for. \r\n    \"\"\"\r\n    return self._uri\r\n\r\n@pure\r\n@external\r\ndef supportsInterface(interfaceId: bytes4) -> bool:\r\n    \"\"\"\r\n    @dev Returns True if the interface is supported\r\n    @param interfaceID bytes4 interface identifier\r\n    \"\"\"\r\n    return interfaceId in [\r\n        ERC165_INTERFACE_ID,\r\n        ERC1155_INTERFACE_ID,\r\n        ERC1155_INTERFACE_ID_METADATA, \r\n    ]","ABI":"[{\"name\":\"Paused\",\"inputs\":[{\"name\":\"account\",\"type\":\"address\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"unPaused\",\"inputs\":[{\"name\":\"account\",\"type\":\"address\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"OwnershipTransferred\",\"inputs\":[{\"name\":\"previousOwner\",\"type\":\"address\",\"indexed\":false},{\"name\":\"newOwner\",\"type\":\"address\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"TransferSingle\",\"inputs\":[{\"name\":\"operator\",\"type\":\"address\",\"indexed\":true},{\"name\":\"fromAddress\",\"type\":\"address\",\"indexed\":true},{\"name\":\"to\",\"type\":\"address\",\"indexed\":true},{\"name\":\"id\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"value\",\"type\":\"uint256\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"TransferBatch\",\"inputs\":[{\"name\":\"operator\",\"type\":\"address\",\"indexed\":true},{\"name\":\"fromAddress\",\"type\":\"address\",\"indexed\":true},{\"name\":\"to\",\"type\":\"address\",\"indexed\":true},{\"name\":\"ids\",\"type\":\"uint256[]\",\"indexed\":false},{\"name\":\"values\",\"type\":\"uint256[]\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"ApprovalForAll\",\"inputs\":[{\"name\":\"account\",\"type\":\"address\",\"indexed\":true},{\"name\":\"operator\",\"type\":\"address\",\"indexed\":true},{\"name\":\"approved\",\"type\":\"bool\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"URI\",\"inputs\":[{\"name\":\"value\",\"type\":\"string\",\"indexed\":false},{\"name\":\"id\",\"type\":\"uint256\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"stateMutability\":\"nonpayable\",\"type\":\"constructor\",\"inputs\":[],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"pause\",\"inputs\":[],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"unpause\",\"inputs\":[],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"transferOwnership\",\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"renounceOwnership\",\"inputs\":[],\"outputs\":[]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"balanceOfBatch\",\"inputs\":[{\"name\":\"accounts\",\"type\":\"address[]\"},{\"name\":\"ids\",\"type\":\"uint256[]\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256[]\"}]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"mint\",\"inputs\":[{\"name\":\"receiver\",\"type\":\"address\"},{\"name\":\"id\",\"type\":\"uint256\"},{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"data\",\"type\":\"bytes32\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"mintBatch\",\"inputs\":[{\"name\":\"receiver\",\"type\":\"address\"},{\"name\":\"ids\",\"type\":\"uint256[]\"},{\"name\":\"amounts\",\"type\":\"uint256[]\"},{\"name\":\"data\",\"type\":\"bytes32\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"burn\",\"inputs\":[{\"name\":\"id\",\"type\":\"uint256\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"burnBatch\",\"inputs\":[{\"name\":\"ids\",\"type\":\"uint256[]\"},{\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"setApprovalForAll\",\"inputs\":[{\"name\":\"owner\",\"type\":\"address\"},{\"name\":\"operator\",\"type\":\"address\"},{\"name\":\"approved\",\"type\":\"bool\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"safeTransferFrom\",\"inputs\":[{\"name\":\"sender\",\"type\":\"address\"},{\"name\":\"receiver\",\"type\":\"address\"},{\"name\":\"id\",\"type\":\"uint256\"},{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"bytes\",\"type\":\"bytes32\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"safeBatchTransferFrom\",\"inputs\":[{\"name\":\"sender\",\"type\":\"address\"},{\"name\":\"receiver\",\"type\":\"address\"},{\"name\":\"ids\",\"type\":\"uint256[]\"},{\"name\":\"amounts\",\"type\":\"uint256[]\"},{\"name\":\"_bytes\",\"type\":\"bytes32\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"setURI\",\"inputs\":[{\"name\":\"uri\",\"type\":\"string\"}],\"outputs\":[]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"uri\",\"inputs\":[{\"name\":\"id\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"string\"}]},{\"stateMutability\":\"pure\",\"type\":\"function\",\"name\":\"supportsInterface\",\"inputs\":[{\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"owner\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"paused\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"name\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"string\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"symbol\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"string\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"balanceOf\",\"inputs\":[{\"name\":\"arg0\",\"type\":\"address\"},{\"name\":\"arg1\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"isApprovedForAll\",\"inputs\":[{\"name\":\"arg0\",\"type\":\"address\"},{\"name\":\"arg1\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}]}]","ContractName":"Vyper_contract","CompilerVersion":"vyper:0.3.3","OptimizationUsed":"0","Runs":"0","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":""}]}