{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"settings\": {\r\n    \"evmVersion\": \"istanbul\",\r\n    \"libraries\": {},\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"remappings\": [],\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  },\r\n  \"sources\": {\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if the sender is not the owner.\\n     */\\n    function _checkOwner() internal view virtual {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"@rari-capital/solmate/src/tokens/ERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\n/// @notice Modern and gas efficient ERC20 + EIP-2612 implementation.\\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/tokens/ERC20.sol)\\n/// @author Modified from Uniswap (https://github.com/Uniswap/uniswap-v2-core/blob/master/contracts/UniswapV2ERC20.sol)\\n/// @dev Do not manually set balances without updating totalSupply, as the sum of all user balances must not exceed it.\\nabstract contract ERC20 {\\n    /*//////////////////////////////////////////////////////////////\\n                                 EVENTS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    event Transfer(address indexed from, address indexed to, uint256 amount);\\n\\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\\n\\n    /*//////////////////////////////////////////////////////////////\\n                            METADATA STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    string public name;\\n\\n    string public symbol;\\n\\n    uint8 public immutable decimals;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                              ERC20 STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    uint256 public totalSupply;\\n\\n    mapping(address => uint256) public balanceOf;\\n\\n    mapping(address => mapping(address => uint256)) public allowance;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                            EIP-2612 STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    uint256 internal immutable INITIAL_CHAIN_ID;\\n\\n    bytes32 internal immutable INITIAL_DOMAIN_SEPARATOR;\\n\\n    mapping(address => uint256) public nonces;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                               CONSTRUCTOR\\n    //////////////////////////////////////////////////////////////*/\\n\\n    constructor(\\n        string memory _name,\\n        string memory _symbol,\\n        uint8 _decimals\\n    ) {\\n        name = _name;\\n        symbol = _symbol;\\n        decimals = _decimals;\\n\\n        INITIAL_CHAIN_ID = block.chainid;\\n        INITIAL_DOMAIN_SEPARATOR = computeDomainSeparator();\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                               ERC20 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function approve(address spender, uint256 amount) public virtual returns (bool) {\\n        allowance[msg.sender][spender] = amount;\\n\\n        emit Approval(msg.sender, spender, amount);\\n\\n        return true;\\n    }\\n\\n    function transfer(address to, uint256 amount) public virtual returns (bool) {\\n        balanceOf[msg.sender] -= amount;\\n\\n        // Cannot overflow because the sum of all user\\n        // balances can't exceed the max uint256 value.\\n        unchecked {\\n            balanceOf[to] += amount;\\n        }\\n\\n        emit Transfer(msg.sender, to, amount);\\n\\n        return true;\\n    }\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) public virtual returns (bool) {\\n        uint256 allowed = allowance[from][msg.sender]; // Saves gas for limited approvals.\\n\\n        if (allowed != type(uint256).max) allowance[from][msg.sender] = allowed - amount;\\n\\n        balanceOf[from] -= amount;\\n\\n        // Cannot overflow because the sum of all user\\n        // balances can't exceed the max uint256 value.\\n        unchecked {\\n            balanceOf[to] += amount;\\n        }\\n\\n        emit Transfer(from, to, amount);\\n\\n        return true;\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                             EIP-2612 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual {\\n        require(deadline >= block.timestamp, \\\"PERMIT_DEADLINE_EXPIRED\\\");\\n\\n        // Unchecked because the only math done is incrementing\\n        // the owner's nonce which cannot realistically overflow.\\n        unchecked {\\n            address recoveredAddress = ecrecover(\\n                keccak256(\\n                    abi.encodePacked(\\n                        \\\"\\\\x19\\\\x01\\\",\\n                        DOMAIN_SEPARATOR(),\\n                        keccak256(\\n                            abi.encode(\\n                                keccak256(\\n                                    \\\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\\\"\\n                                ),\\n                                owner,\\n                                spender,\\n                                value,\\n                                nonces[owner]++,\\n                                deadline\\n                            )\\n                        )\\n                    )\\n                ),\\n                v,\\n                r,\\n                s\\n            );\\n\\n            require(recoveredAddress != address(0) && recoveredAddress == owner, \\\"INVALID_SIGNER\\\");\\n\\n            allowance[recoveredAddress][spender] = value;\\n        }\\n\\n        emit Approval(owner, spender, value);\\n    }\\n\\n    function DOMAIN_SEPARATOR() public view virtual returns (bytes32) {\\n        return block.chainid == INITIAL_CHAIN_ID ? INITIAL_DOMAIN_SEPARATOR : computeDomainSeparator();\\n    }\\n\\n    function computeDomainSeparator() internal view virtual returns (bytes32) {\\n        return\\n            keccak256(\\n                abi.encode(\\n                    keccak256(\\\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\\\"),\\n                    keccak256(bytes(name)),\\n                    keccak256(\\\"1\\\"),\\n                    block.chainid,\\n                    address(this)\\n                )\\n            );\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                        INTERNAL MINT/BURN LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function _mint(address to, uint256 amount) internal virtual {\\n        totalSupply += amount;\\n\\n        // Cannot overflow because the sum of all user\\n        // balances can't exceed the max uint256 value.\\n        unchecked {\\n            balanceOf[to] += amount;\\n        }\\n\\n        emit Transfer(address(0), to, amount);\\n    }\\n\\n    function _burn(address from, uint256 amount) internal virtual {\\n        balanceOf[from] -= amount;\\n\\n        // Cannot underflow because a user's balance\\n        // will never be larger than the total supply.\\n        unchecked {\\n            totalSupply -= amount;\\n        }\\n\\n        emit Transfer(from, address(0), amount);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/YourContract.sol\": {\r\n      \"content\": \"pragma solidity >=0.8.0 <0.9.0;\\n//SPDX-License-Identifier: MIT\\n\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\"; \\n// https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/access/Ownable.sol\\n\\nimport {ISplitMain} from './interfaces/ISplitMain.sol';\\n\\ncontract YourContract is Ownable {\\n  /**\\n   * CONTRACT STATE\\n   */\\n  struct Project {\\n    bool splitAdded;\\n\\n    string githubURL;\\n    address payable receiveMoneyAddress;\\n    address payable splitProxyAddress;\\n\\n    uint32 communityPoolPercentage;\\n    address payable communityPoolAddress;\\n\\n    string[] splitGithubURLs;\\n    uint32[] percentAllocations;\\n  }\\n  mapping(string => Project) public githubURLToProject;\\n  uint32 percentKeep;\\n  uint32 percentDistributorFee;\\n  string sinkGithubURL;\\n\\n  ISplitMain splitMain;\\n\\n  // @notice constant to scale uints into percentages (1e6 == 100%)\\n  // from 0xSplit contract\\n  uint32 public constant PERCENTAGE_SCALE = 1e6;\\n\\n  // inputted percents must use PERCENTAGE_SCALE\\n  constructor(\\n    uint32 _percentKeep, \\n    uint32 _percentDistributorFee, \\n    address _splitMainAddress,\\n    string memory _sinkGithubURL\\n  ) {\\n    percentKeep = _percentKeep;\\n    percentDistributorFee = _percentDistributorFee;\\n    splitMain = ISplitMain(_splitMainAddress);\\n    sinkGithubURL = _sinkGithubURL;\\n\\n    Project storage sinkProject = githubURLToProject[sinkGithubURL];\\n    sinkProject.splitAdded = true;\\n    sinkProject.githubURL = sinkGithubURL;\\n    sinkProject.receiveMoneyAddress = payable(msg.sender);\\n    sinkProject.splitProxyAddress = payable(msg.sender);\\n  }\\n\\n  /**\\n   * CONTRACT METHODS\\n   */\\n  function addProjectToSystem(\\n    string memory githubURL, \\n    address payable receiveMoneyAddress,\\n    string[] memory splitGithubURLs,\\n    uint32[] memory percentAllocations,\\n    uint32 communityPoolPercentage,\\n    address payable communityPoolAddress\\n  ) public onlyOwner {\\n\\n    // intialize the project object\\n    Project storage project = githubURLToProject[githubURL];\\n    project.githubURL = githubURL;\\n    project.receiveMoneyAddress = receiveMoneyAddress;\\n    project.splitGithubURLs = splitGithubURLs;\\n    project.percentAllocations = percentAllocations;\\n    project.communityPoolPercentage = communityPoolPercentage;\\n    project.communityPoolAddress = communityPoolAddress;\\n\\n    // stores addresses of GitHub repos, address of team, and address of community pool\\n    address[] memory splitAddresses;\\n    uint32[] memory newPercentAllocations;\\n    if (communityPoolPercentage > 0) {\\n      // need an extra entry for community pool\\n      splitAddresses = new address[](splitGithubURLs.length+2);\\n      newPercentAllocations = new uint32[](splitGithubURLs.length+2);\\n\\n      splitAddresses[splitGithubURLs.length+1] = communityPoolAddress;\\n      newPercentAllocations[splitGithubURLs.length+1] = communityPoolPercentage;\\n    } else {\\n      splitAddresses = new address[](splitGithubURLs.length+1);\\n      newPercentAllocations = new uint32[](splitGithubURLs.length+1);\\n    }\\n\\n    // convert GitHub URLs to addresses\\n    for (uint i = 0; i < splitGithubURLs.length; i++) {\\n      string memory splitGithubURL = splitGithubURLs[i];\\n      Project storage splitProject = githubURLToProject[splitGithubURL];\\n      if (!splitProject.splitAdded) {\\n        initializePlaceholderSplit(splitGithubURL);\\n      }\\n      require(splitProject.splitAdded, \\\"split not added\\\");\\n      splitAddresses[i] = splitProject.splitProxyAddress;\\n      newPercentAllocations[i] = percentAllocations[i];\\n    }\\n\\n    // add self + kept percentage\\n    splitAddresses[splitGithubURLs.length] = receiveMoneyAddress;\\n    newPercentAllocations[splitGithubURLs.length] = percentKeep;\\n\\n    // assert sum of percentAllocations is PERCENTAGE_SCALE\\n    uint32 sum = 0;\\n    for (uint i = 0; i < newPercentAllocations.length; i++) {\\n      require(newPercentAllocations[i] > 0, \\\"percentAllocations must be greater than 0\\\");\\n      sum += newPercentAllocations[i];\\n    }\\n    require(sum == PERCENTAGE_SCALE, \\\"sum of percentAllocations is not 1e6\\\");\\n\\n    // sort addresses and percent allocations\\n    for (uint i = 0; i < splitAddresses.length; i++) {\\n      for (uint j = i + 1; j < splitAddresses.length; j++) {\\n        if (splitAddresses[i] > splitAddresses[j]) {\\n          (splitAddresses[i], splitAddresses[j]) = (splitAddresses[j], splitAddresses[i]);\\n          (newPercentAllocations[i], newPercentAllocations[j]) = (newPercentAllocations[j], newPercentAllocations[i]);\\n        }\\n      }\\n    }\\n\\n    // create or update split proxy for this GitHub\\n    if (!project.splitAdded) {\\n      project.splitProxyAddress = payable(splitMain.createSplit(\\n        splitAddresses, \\n        newPercentAllocations, \\n        percentDistributorFee, \\n        address(this)\\n      ));\\n      project.splitAdded = true;\\n    } else {\\n      splitMain.updateSplit(\\n        project.splitProxyAddress, \\n        splitAddresses, \\n        newPercentAllocations, \\n        percentDistributorFee\\n      );\\n    }\\n  }\\n\\n  function initializePlaceholderSplit(string memory githubURL) internal {   \\n    Project storage project = githubURLToProject[githubURL];\\n    project.githubURL = githubURL;\\n\\n    require(!project.splitAdded, \\\"placeholder split already added\\\");\\n    \\n    // set up a dummy split to start out so we can get the address of the split\\n    // 0xSplits requires splits are between 2 or more addresses\\n    uint32[] memory placeholderPercentage = new uint32[](2);\\n    placeholderPercentage[0] = PERCENTAGE_SCALE-1;\\n    placeholderPercentage[1] = uint32(1);\\n    \\n    address[] memory placeholderAddresses = new address[](2);\\n    if (owner() > address(this)) {\\n      placeholderAddresses[0] = address(this);\\n      placeholderAddresses[1] = owner();\\n    } else {\\n      placeholderAddresses[1] = address(this);\\n      placeholderAddresses[0] = owner();\\n    }\\n    \\n    // create initial split\\n    project.splitProxyAddress = payable(splitMain.createSplit(\\n      placeholderAddresses, \\n      placeholderPercentage, \\n      percentDistributorFee, \\n      address(this)\\n    ));\\n\\n    // reroute all payments back to the split\\n    if (project.splitProxyAddress > owner()) {\\n      placeholderAddresses[0] = owner();\\n      placeholderPercentage[0] = uint32(1);\\n      placeholderAddresses[1] = project.splitProxyAddress;\\n      placeholderPercentage[1] = PERCENTAGE_SCALE-1;\\n    } else {\\n      placeholderAddresses[1] = owner();\\n      placeholderPercentage[1] = uint32(1);\\n      placeholderAddresses[0] = project.splitProxyAddress;\\n      placeholderPercentage[0] = PERCENTAGE_SCALE-1;\\n    }\\n\\n    splitMain.updateSplit(\\n      project.splitProxyAddress, \\n      placeholderAddresses, \\n      placeholderPercentage, \\n      percentDistributorFee\\n    );\\n    project.splitAdded = true;\\n  }\\n\\n  // if 0.5% is too little or too much for the system to work, owner can change it\\n  function changePercentageDistributorFee(uint32 _newPercentDistributorFee) public onlyOwner {\\n    percentDistributorFee = _newPercentDistributorFee;\\n  }\\n\\n  // transfer ownership of contract and change address of sink URL\\n  function transferOwnership(address newOwner) public override onlyOwner {\\n    super.transferOwnership(newOwner);\\n    githubURLToProject[sinkGithubURL].splitProxyAddress = payable(newOwner);\\n  }\\n\\n  /**\\n   * CONTRACT GETTERS\\n   */\\n  function getProject(string memory githubURL) external view returns (Project memory) {\\n    return githubURLToProject[githubURL];\\n  }\\n\\n  function getSinkGithubURL() external view returns (string memory) {\\n    return sinkGithubURL;\\n  }\\n  \\n  // to support receiving ETH by default\\n  receive() external payable {}\\n  fallback() external payable {}\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ISplitMain.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity 0.8.4;\\n\\nimport {ERC20} from '@rari-capital/solmate/src/tokens/ERC20.sol';\\n\\n/**\\n * @title ISplitMain\\n * @author 0xSplits <will@0xSplits.xyz>\\n */\\ninterface ISplitMain {\\n  /**\\n   * FUNCTIONS\\n   */\\n\\n  function walletImplementation() external returns (address);\\n\\n  function createSplit(\\n    address[] calldata accounts,\\n    uint32[] calldata percentAllocations,\\n    uint32 distributorFee,\\n    address controller\\n  ) external returns (address);\\n\\n  function predictImmutableSplitAddress(\\n    address[] calldata accounts,\\n    uint32[] calldata percentAllocations,\\n    uint32 distributorFee\\n  ) external view returns (address);\\n\\n  function updateSplit(\\n    address split,\\n    address[] calldata accounts,\\n    uint32[] calldata percentAllocations,\\n    uint32 distributorFee\\n  ) external;\\n\\n  function transferControl(address split, address newController) external;\\n\\n  function cancelControlTransfer(address split) external;\\n\\n  function acceptControl(address split) external;\\n\\n  function makeSplitImmutable(address split) external;\\n\\n  function distributeETH(\\n    address split,\\n    address[] calldata accounts,\\n    uint32[] calldata percentAllocations,\\n    uint32 distributorFee,\\n    address distributorAddress\\n  ) external;\\n\\n  function updateAndDistributeETH(\\n    address split,\\n    address[] calldata accounts,\\n    uint32[] calldata percentAllocations,\\n    uint32 distributorFee,\\n    address distributorAddress\\n  ) external;\\n\\n  function distributeERC20(\\n    address split,\\n    ERC20 token,\\n    address[] calldata accounts,\\n    uint32[] calldata percentAllocations,\\n    uint32 distributorFee,\\n    address distributorAddress\\n  ) external;\\n\\n  function updateAndDistributeERC20(\\n    address split,\\n    ERC20 token,\\n    address[] calldata accounts,\\n    uint32[] calldata percentAllocations,\\n    uint32 distributorFee,\\n    address distributorAddress\\n  ) external;\\n\\n  function withdraw(\\n    address account,\\n    uint256 withdrawETH,\\n    ERC20[] calldata tokens\\n  ) external;\\n\\n  /**\\n   * EVENTS\\n   */\\n\\n  /** @notice emitted after each successful split creation\\n   *  @param split Address of the created split\\n   */\\n  event CreateSplit(address indexed split);\\n\\n  /** @notice emitted after each successful split update\\n   *  @param split Address of the updated split\\n   */\\n  event UpdateSplit(address indexed split);\\n\\n  /** @notice emitted after each initiated split control transfer\\n   *  @param split Address of the split control transfer was initiated for\\n   *  @param newPotentialController Address of the split's new potential controller\\n   */\\n  event InitiateControlTransfer(\\n    address indexed split,\\n    address indexed newPotentialController\\n  );\\n\\n  /** @notice emitted after each canceled split control transfer\\n   *  @param split Address of the split control transfer was canceled for\\n   */\\n  event CancelControlTransfer(address indexed split);\\n\\n  /** @notice emitted after each successful split control transfer\\n   *  @param split Address of the split control was transferred for\\n   *  @param previousController Address of the split's previous controller\\n   *  @param newController Address of the split's new controller\\n   */\\n  event ControlTransfer(\\n    address indexed split,\\n    address indexed previousController,\\n    address indexed newController\\n  );\\n\\n  /** @notice emitted after each successful ETH balance split\\n   *  @param split Address of the split that distributed its balance\\n   *  @param amount Amount of ETH distributed\\n   *  @param distributorAddress Address to credit distributor fee to\\n   */\\n  event DistributeETH(\\n    address indexed split,\\n    uint256 amount,\\n    address indexed distributorAddress\\n  );\\n\\n  /** @notice emitted after each successful ERC20 balance split\\n   *  @param split Address of the split that distributed its balance\\n   *  @param token Address of ERC20 distributed\\n   *  @param amount Amount of ERC20 distributed\\n   *  @param distributorAddress Address to credit distributor fee to\\n   */\\n  event DistributeERC20(\\n    address indexed split,\\n    ERC20 indexed token,\\n    uint256 amount,\\n    address indexed distributorAddress\\n  );\\n\\n  /** @notice emitted after each successful withdrawal\\n   *  @param account Address that funds were withdrawn to\\n   *  @param ethAmount Amount of ETH withdrawn\\n   *  @param tokens Addresses of ERC20s withdrawn\\n   *  @param tokenAmounts Amounts of corresponding ERC20s withdrawn\\n   */\\n  event Withdrawal(\\n    address indexed account,\\n    uint256 ethAmount,\\n    ERC20[] tokens,\\n    uint256[] tokenAmounts\\n  );\\n}\"\r\n    }\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"_percentKeep\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"_percentDistributorFee\",\"type\":\"uint32\"},{\"internalType\":\"address\",\"name\":\"_splitMainAddress\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"_sinkGithubURL\",\"type\":\"string\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"inputs\":[],\"name\":\"PERCENTAGE_SCALE\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"githubURL\",\"type\":\"string\"},{\"internalType\":\"address payable\",\"name\":\"receiveMoneyAddress\",\"type\":\"address\"},{\"internalType\":\"string[]\",\"name\":\"splitGithubURLs\",\"type\":\"string[]\"},{\"internalType\":\"uint32[]\",\"name\":\"percentAllocations\",\"type\":\"uint32[]\"},{\"internalType\":\"uint32\",\"name\":\"communityPoolPercentage\",\"type\":\"uint32\"},{\"internalType\":\"address payable\",\"name\":\"communityPoolAddress\",\"type\":\"address\"}],\"name\":\"addProjectToSystem\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"_newPercentDistributorFee\",\"type\":\"uint32\"}],\"name\":\"changePercentageDistributorFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"githubURL\",\"type\":\"string\"}],\"name\":\"getProject\",\"outputs\":[{\"components\":[{\"internalType\":\"bool\",\"name\":\"splitAdded\",\"type\":\"bool\"},{\"internalType\":\"string\",\"name\":\"githubURL\",\"type\":\"string\"},{\"internalType\":\"address payable\",\"name\":\"receiveMoneyAddress\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"splitProxyAddress\",\"type\":\"address\"},{\"internalType\":\"uint32\",\"name\":\"communityPoolPercentage\",\"type\":\"uint32\"},{\"internalType\":\"address payable\",\"name\":\"communityPoolAddress\",\"type\":\"address\"},{\"internalType\":\"string[]\",\"name\":\"splitGithubURLs\",\"type\":\"string[]\"},{\"internalType\":\"uint32[]\",\"name\":\"percentAllocations\",\"type\":\"uint32[]\"}],\"internalType\":\"struct YourContract.Project\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getSinkGithubURL\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"name\":\"githubURLToProject\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"splitAdded\",\"type\":\"bool\"},{\"internalType\":\"string\",\"name\":\"githubURL\",\"type\":\"string\"},{\"internalType\":\"address payable\",\"name\":\"receiveMoneyAddress\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"splitProxyAddress\",\"type\":\"address\"},{\"internalType\":\"uint32\",\"name\":\"communityPoolPercentage\",\"type\":\"uint32\"},{\"internalType\":\"address payable\",\"name\":\"communityPoolAddress\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]","ContractName":"YourContract","CompilerVersion":"v0.8.4+commit.c7e474f2","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000000000000000000000000000000000000007a12000000000000000000000000000000000000000000000000000000000000013880000000000000000000000002ed6c4b5da6378c7897ac67ba9e43102feb694ee0000000000000000000000000000000000000000000000000000000000000080000000000000000000000000000000000000000000000000000000000000001968747470733a2f2f6769746875622e636f6d2f30785041524300000000000000","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":""}]}