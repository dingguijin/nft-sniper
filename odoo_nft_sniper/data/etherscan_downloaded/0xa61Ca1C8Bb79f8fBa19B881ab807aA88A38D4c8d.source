{"status":"1","message":"OK","result":[{"SourceCode":"// SPDX-License-Identifier: GPL-3.0-or-later\r\n// Sources flattened with hardhat v2.6.1 https://hardhat.org\r\n\r\n// File @openzeppelin/contracts/token/ERC20/IERC20.sol@v4.5.0\r\n\r\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/IERC20.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `to`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address to, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `from` to `to` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n\r\n// File libraries/UncheckedMath.sol\r\n\r\npragma solidity 0.8.10;\r\n\r\nlibrary UncheckedMath {\r\n    function uncheckedInc(uint256 a) internal pure returns (uint256) {\r\n        unchecked {\r\n            return a + 1;\r\n        }\r\n    }\r\n\r\n    function uncheckedAdd(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        unchecked {\r\n            return a + b;\r\n        }\r\n    }\r\n\r\n    function uncheckedSub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        unchecked {\r\n            return a - b;\r\n        }\r\n    }\r\n\r\n    function uncheckedDiv(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        unchecked {\r\n            return a / b;\r\n        }\r\n    }\r\n}\r\n\r\n\r\n// File libraries/ScaledMath.sol\r\n\r\npragma solidity 0.8.10;\r\n\r\n/*\r\n * @dev To use functions of this contract, at least one of the numbers must\r\n * be scaled to `DECIMAL_SCALE`. The result will scaled to `DECIMAL_SCALE`\r\n * if both numbers are scaled to `DECIMAL_SCALE`, otherwise to the scale\r\n * of the number not scaled by `DECIMAL_SCALE`\r\n */\r\nlibrary ScaledMath {\r\n    // solhint-disable-next-line private-vars-leading-underscore\r\n    uint256 internal constant DECIMAL_SCALE = 1e18;\r\n    // solhint-disable-next-line private-vars-leading-underscore\r\n    uint256 internal constant ONE = 1e18;\r\n\r\n    /**\r\n     * @notice Performs a multiplication between two scaled numbers\r\n     */\r\n    function scaledMul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return (a * b) / DECIMAL_SCALE;\r\n    }\r\n\r\n    /**\r\n     * @notice Performs a division between two scaled numbers\r\n     */\r\n    function scaledDiv(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return (a * DECIMAL_SCALE) / b;\r\n    }\r\n\r\n    /**\r\n     * @notice Performs a division between two numbers, rounding up the result\r\n     */\r\n    function scaledDivRoundUp(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return (a * DECIMAL_SCALE + b - 1) / b;\r\n    }\r\n\r\n    /**\r\n     * @notice Performs a division between two numbers, ignoring any scaling and rounding up the result\r\n     */\r\n    function divRoundUp(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return (a + b - 1) / b;\r\n    }\r\n}\r\n\r\n\r\n// File interfaces/strategies/IStrategy.sol\r\n\r\npragma solidity 0.8.10;\r\n\r\ninterface IStrategy {\r\n    function deposit() external payable returns (bool);\r\n\r\n    function withdraw(uint256 amount) external returns (bool);\r\n\r\n    function withdrawAll() external returns (uint256);\r\n\r\n    function harvest() external returns (uint256);\r\n\r\n    function shutdown() external;\r\n\r\n    function setCommunityReserve(address _communityReserve) external;\r\n\r\n    function setStrategist(address strategist_) external;\r\n\r\n    function name() external view returns (string memory);\r\n\r\n    function balance() external view returns (uint256);\r\n\r\n    function harvestable() external view returns (uint256);\r\n\r\n    function strategist() external view returns (address);\r\n\r\n    function hasPendingFunds() external view returns (bool);\r\n}\r\n\r\n\r\n// File interfaces/IVault.sol\r\n\r\npragma solidity 0.8.10;\r\n\r\n/**\r\n * @title Interface for a Vault\r\n */\r\n\r\ninterface IVault {\r\n    event StrategyActivated(address indexed strategy);\r\n\r\n    event StrategyDeactivated(address indexed strategy);\r\n\r\n    /**\r\n     * @dev 'netProfit' is the profit after all fees have been deducted\r\n     */\r\n    event Harvest(uint256 indexed netProfit, uint256 indexed loss);\r\n\r\n    function initialize(\r\n        address _pool,\r\n        uint256 _debtLimit,\r\n        uint256 _targetAllocation,\r\n        uint256 _bound\r\n    ) external;\r\n\r\n    function withdrawFromStrategyWaitingForRemoval(address strategy) external returns (uint256);\r\n\r\n    function deposit() external payable;\r\n\r\n    function withdraw(uint256 amount) external returns (bool);\r\n\r\n    function withdrawAvailableToPool() external;\r\n\r\n    function initializeStrategy(address strategy_) external;\r\n\r\n    function shutdownStrategy() external;\r\n\r\n    function withdrawFromReserve(uint256 amount) external;\r\n\r\n    function updateStrategy(address newStrategy) external;\r\n\r\n    function activateStrategy() external returns (bool);\r\n\r\n    function deactivateStrategy() external returns (bool);\r\n\r\n    function updatePerformanceFee(uint256 newPerformanceFee) external;\r\n\r\n    function updateStrategistFee(uint256 newStrategistFee) external;\r\n\r\n    function updateDebtLimit(uint256 newDebtLimit) external;\r\n\r\n    function updateTargetAllocation(uint256 newTargetAllocation) external;\r\n\r\n    function updateReserveFee(uint256 newReserveFee) external;\r\n\r\n    function updateBound(uint256 newBound) external;\r\n\r\n    function withdrawFromStrategy(uint256 amount) external returns (bool);\r\n\r\n    function withdrawAllFromStrategy() external returns (bool);\r\n\r\n    function harvest() external returns (bool);\r\n\r\n    function getStrategiesWaitingForRemoval() external view returns (address[] memory);\r\n\r\n    function getAllocatedToStrategyWaitingForRemoval(address strategy)\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    function getTotalUnderlying() external view returns (uint256);\r\n\r\n    function getUnderlying() external view returns (address);\r\n\r\n    function strategy() external view returns (IStrategy);\r\n}\r\n\r\n\r\n// File interfaces/pool/ILiquidityPool.sol\r\n\r\npragma solidity 0.8.10;\r\n\r\ninterface ILiquidityPool {\r\n    event Deposit(address indexed minter, uint256 depositAmount, uint256 mintedLpTokens);\r\n\r\n    event DepositFor(\r\n        address indexed minter,\r\n        address indexed mintee,\r\n        uint256 depositAmount,\r\n        uint256 mintedLpTokens\r\n    );\r\n\r\n    event Redeem(address indexed redeemer, uint256 redeemAmount, uint256 redeemTokens);\r\n\r\n    event LpTokenSet(address indexed lpToken);\r\n\r\n    event StakerVaultSet(address indexed stakerVault);\r\n\r\n    event Shutdown();\r\n\r\n    function redeem(uint256 redeemTokens) external returns (uint256);\r\n\r\n    function redeem(uint256 redeemTokens, uint256 minRedeemAmount) external returns (uint256);\r\n\r\n    function calcRedeem(address account, uint256 underlyingAmount) external returns (uint256);\r\n\r\n    function deposit(uint256 mintAmount) external payable returns (uint256);\r\n\r\n    function deposit(uint256 mintAmount, uint256 minTokenAmount) external payable returns (uint256);\r\n\r\n    function depositAndStake(uint256 depositAmount, uint256 minTokenAmount)\r\n        external\r\n        payable\r\n        returns (uint256);\r\n\r\n    function depositFor(address account, uint256 depositAmount) external payable returns (uint256);\r\n\r\n    function depositFor(\r\n        address account,\r\n        uint256 depositAmount,\r\n        uint256 minTokenAmount\r\n    ) external payable returns (uint256);\r\n\r\n    function unstakeAndRedeem(uint256 redeemLpTokens, uint256 minRedeemAmount)\r\n        external\r\n        returns (uint256);\r\n\r\n    function handleLpTokenTransfer(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) external;\r\n\r\n    function updateVault(address _vault) external;\r\n\r\n    function setLpToken(address _lpToken) external;\r\n\r\n    function setStaker() external;\r\n\r\n    function shutdownPool(bool shutdownStrategy) external;\r\n\r\n    function shutdownStrategy() external;\r\n\r\n    function updateRequiredReserves(uint256 _newRatio) external;\r\n\r\n    function updateReserveDeviation(uint256 newRatio) external;\r\n\r\n    function updateMinWithdrawalFee(uint256 newFee) external;\r\n\r\n    function updateMaxWithdrawalFee(uint256 newFee) external;\r\n\r\n    function updateWithdrawalFeeDecreasePeriod(uint256 newPeriod) external;\r\n\r\n    function rebalanceVault() external;\r\n\r\n    function getNewCurrentFees(\r\n        uint256 timeToWait,\r\n        uint256 lastActionTimestamp,\r\n        uint256 feeRatio\r\n    ) external view returns (uint256);\r\n\r\n    function vault() external view returns (IVault);\r\n\r\n    function getUnderlying() external view returns (address);\r\n\r\n    function getLpToken() external view returns (address);\r\n\r\n    function getWithdrawalFee(address account, uint256 amount) external view returns (uint256);\r\n\r\n    function exchangeRate() external view returns (uint256);\r\n\r\n    function totalUnderlying() external view returns (uint256);\r\n\r\n    function name() external view returns (string memory);\r\n\r\n    function isShutdown() external view returns (bool);\r\n}\r\n\r\n\r\n// File interfaces/IGasBank.sol\r\n\r\npragma solidity 0.8.10;\r\n\r\ninterface IGasBank {\r\n    event Deposit(address indexed account, uint256 value);\r\n    event Withdraw(address indexed account, address indexed receiver, uint256 value);\r\n\r\n    function depositFor(address account) external payable;\r\n\r\n    function withdrawUnused(address account) external;\r\n\r\n    function withdrawFrom(address account, uint256 amount) external;\r\n\r\n    function withdrawFrom(\r\n        address account,\r\n        address payable to,\r\n        uint256 amount\r\n    ) external;\r\n\r\n    function balanceOf(address account) external view returns (uint256);\r\n}\r\n\r\n\r\n// File interfaces/oracles/IOracleProvider.sol\r\n\r\npragma solidity 0.8.10;\r\n\r\ninterface IOracleProvider {\r\n    /// @notice Checks whether the asset is supported\r\n    /// @param baseAsset the asset of which the price is to be quoted\r\n    /// @return true if the asset is supported\r\n    function isAssetSupported(address baseAsset) external view returns (bool);\r\n\r\n    /// @notice Quotes the USD price of `baseAsset`\r\n    /// @param baseAsset the asset of which the price is to be quoted\r\n    /// @return the USD price of the asset\r\n    function getPriceUSD(address baseAsset) external view returns (uint256);\r\n\r\n    /// @notice Quotes the ETH price of `baseAsset`\r\n    /// @param baseAsset the asset of which the price is to be quoted\r\n    /// @return the ETH price of the asset\r\n    function getPriceETH(address baseAsset) external view returns (uint256);\r\n}\r\n\r\n\r\n// File libraries/AddressProviderMeta.sol\r\n\r\npragma solidity 0.8.10;\r\n\r\nlibrary AddressProviderMeta {\r\n    struct Meta {\r\n        bool freezable;\r\n        bool frozen;\r\n    }\r\n\r\n    function fromUInt(uint256 value) internal pure returns (Meta memory) {\r\n        Meta memory meta;\r\n        meta.freezable = (value & 1) == 1;\r\n        meta.frozen = ((value >> 1) & 1) == 1;\r\n        return meta;\r\n    }\r\n\r\n    function toUInt(Meta memory meta) internal pure returns (uint256) {\r\n        uint256 value;\r\n        value |= meta.freezable ? 1 : 0;\r\n        value |= meta.frozen ? 1 << 1 : 0;\r\n        return value;\r\n    }\r\n}\r\n\r\n\r\n// File interfaces/IAddressProvider.sol\r\n\r\npragma solidity 0.8.10;\r\n\r\n\r\n\r\n\r\n// solhint-disable ordering\r\n\r\ninterface IAddressProvider {\r\n    event KnownAddressKeyAdded(bytes32 indexed key);\r\n    event StakerVaultListed(address indexed stakerVault);\r\n    event StakerVaultDelisted(address indexed stakerVault);\r\n    event ActionListed(address indexed action);\r\n    event PoolListed(address indexed pool);\r\n    event VaultUpdated(address indexed previousVault, address indexed newVault);\r\n    event FeeHandlerAdded(address feeHandler);\r\n    event FeeHandlerRemoved(address feeHandler);\r\n\r\n    /** Key functions */\r\n    function getKnownAddressKeys() external view returns (bytes32[] memory);\r\n\r\n    function freezeAddress(bytes32 key) external;\r\n\r\n    /** Pool functions */\r\n\r\n    function allPools() external view returns (address[] memory);\r\n\r\n    function addPool(address pool) external;\r\n\r\n    function poolsCount() external view returns (uint256);\r\n\r\n    function getPoolAtIndex(uint256 index) external view returns (address);\r\n\r\n    function isPool(address pool) external view returns (bool);\r\n\r\n    function getPoolForToken(address token) external view returns (ILiquidityPool);\r\n\r\n    function safeGetPoolForToken(address token) external view returns (address);\r\n\r\n    /** Vault functions  */\r\n\r\n    function updateVault(address previousVault, address newVault) external;\r\n\r\n    function allVaults() external view returns (address[] memory);\r\n\r\n    function vaultsCount() external view returns (uint256);\r\n\r\n    function getVaultAtIndex(uint256 index) external view returns (address);\r\n\r\n    function isVault(address vault) external view returns (bool);\r\n\r\n    /** Action functions */\r\n\r\n    function allActions() external view returns (address[] memory);\r\n\r\n    function addAction(address action) external returns (bool);\r\n\r\n    function isAction(address action) external view returns (bool);\r\n\r\n    /** Address functions */\r\n    function initializeAddress(bytes32 key, address initialAddress) external;\r\n\r\n    function initializeAddress(\r\n        bytes32 key,\r\n        address initialAddress,\r\n        bool frezable\r\n    ) external;\r\n\r\n    function initializeAndFreezeAddress(bytes32 key, address initialAddress) external;\r\n\r\n    function getAddress(bytes32 key) external view returns (address);\r\n\r\n    function getAddress(bytes32 key, bool checkExists) external view returns (address);\r\n\r\n    function getAddressMeta(bytes32 key) external view returns (AddressProviderMeta.Meta memory);\r\n\r\n    function updateAddress(bytes32 key, address newAddress) external;\r\n\r\n    /** Staker vault functions */\r\n    function allStakerVaults() external view returns (address[] memory);\r\n\r\n    function tryGetStakerVault(address token) external view returns (bool, address);\r\n\r\n    function getStakerVault(address token) external view returns (address);\r\n\r\n    function addStakerVault(address stakerVault) external;\r\n\r\n    function isStakerVault(address stakerVault, address token) external view returns (bool);\r\n\r\n    function isStakerVaultRegistered(address stakerVault) external view returns (bool);\r\n\r\n    function isWhiteListedFeeHandler(address feeHandler) external view returns (bool);\r\n\r\n    /** Fee Handler function */\r\n    function addFeeHandler(address feeHandler) external;\r\n\r\n    function removeFeeHandler(address feeHandler) external;\r\n}\r\n\r\n\r\n// File interfaces/helpers/IApyHelper.sol\r\n\r\npragma solidity 0.8.10;\r\n\r\ninterface IApyHelper {\r\n    struct PoolExchangeRate {\r\n        address pool;\r\n        uint256 exchangeRate;\r\n    }\r\n\r\n    function exchangeRatesIncludingHarvestable() external view returns (PoolExchangeRate[] memory);\r\n\r\n    function exchangeRateIncludingHarvestable(address pool_) external view returns (uint256);\r\n}\r\n\r\n\r\n// File contracts/helpers/ApyHelper.sol\r\n\r\npragma solidity 0.8.10;\r\n\r\n\r\n\r\n\r\n\r\n\r\n// TODO Add deployment script\r\n\r\ncontract ApyHelper is IApyHelper {\r\n    using ScaledMath for uint256;\r\n    using UncheckedMath for uint256;\r\n\r\n    IAddressProvider internal _addressProvider;\r\n\r\n    constructor(address addressProvider_) {\r\n        _addressProvider = IAddressProvider(addressProvider_);\r\n    }\r\n\r\n    function exchangeRatesIncludingHarvestable()\r\n        external\r\n        view\r\n        override\r\n        returns (PoolExchangeRate[] memory)\r\n    {\r\n        address[] memory pools_ = _addressProvider.allPools();\r\n        PoolExchangeRate[] memory poolExchangeRates_ = new PoolExchangeRate[](pools_.length);\r\n        for (uint256 i; i < pools_.length; i = i.uncheckedInc()) {\r\n            address pool_ = pools_[i];\r\n            uint256 exchangeRate_ = exchangeRateIncludingHarvestable(pool_);\r\n            poolExchangeRates_[i] = PoolExchangeRate(pool_, exchangeRate_);\r\n        }\r\n        return poolExchangeRates_;\r\n    }\r\n\r\n    function exchangeRateIncludingHarvestable(address pool_)\r\n        public\r\n        view\r\n        override\r\n        returns (uint256)\r\n    {\r\n        uint256 totalUnderlying_ = ILiquidityPool(pool_).totalUnderlying();\r\n        if (totalUnderlying_ == 0) return 1e18;\r\n        address lpToken_ = ILiquidityPool(pool_).getLpToken();\r\n        uint256 lpTokenSupply_ = IERC20(lpToken_).totalSupply();\r\n        if (lpTokenSupply_ == 0) return 1e18;\r\n        IVault vault_ = ILiquidityPool(pool_).vault();\r\n        if (address(vault_) == address(0)) return totalUnderlying_.scaledDiv(lpTokenSupply_);\r\n        IStrategy strategy_ = vault_.strategy();\r\n        if (address(strategy_) == address(0)) return totalUnderlying_.scaledDiv(lpTokenSupply_);\r\n        uint256 harvestable_ = strategy_.harvestable();\r\n        return (totalUnderlying_ + harvestable_).scaledDiv(lpTokenSupply_);\r\n    }\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addressProvider_\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pool_\",\"type\":\"address\"}],\"name\":\"exchangeRateIncludingHarvestable\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"exchangeRatesIncludingHarvestable\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"exchangeRate\",\"type\":\"uint256\"}],\"internalType\":\"struct IApyHelper.PoolExchangeRate[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"ApyHelper","CompilerVersion":"v0.8.10+commit.fc410830","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000ac61fd84c5b20828c666ab1fdca0329aeaa8c8ee","EVMVersion":"Default","Library":"","LicenseType":"GNU GPLv3","Proxy":"0","Implementation":"","SwarmSource":"ipfs://3bd4b1d4a39ef69308c05b0ae4704b813c8753b792a3176d7182a1436db37bab"}]}