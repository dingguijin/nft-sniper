{"status":"1","message":"OK","result":[{"SourceCode":"// SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.8.9;\r\n\r\ninterface INFT {\r\n    function transferFrom(\r\n        address _from,\r\n        address _to,\r\n        uint256 _tokenId\r\n    ) external;\r\n}\r\n\r\ncontract ElderGateway {\r\n\r\n    /**\r\n    * @dev Details of locked NFT\r\n    * @param user owner of tokenId\r\n    * @param blockNo block.number when locked\r\n    */\r\n    struct Details {\r\n        address user;\r\n        uint256 blockNo;\r\n    }\r\n\r\n    /**\r\n    * @dev mapping holds below values:\r\n    * collectionAddress => tokenId => Details  \r\n    */\r\n    mapping(address => mapping(uint256 => Details)) public lockedData;\r\n\r\n    /** \r\n    * @dev Emits event after nft is successfully locked\r\n    * @param user address which locked nfts (owner of tokens)\r\n    * @param nft collection address\r\n    * @param tokenIds list of tokenIds from `nft` collection\r\n    */\r\n    event Locked(address indexed user, address indexed nft, uint256[] tokenIds);\r\n\r\n    /** \r\n    * @dev Emits event after nft is successfully unlocked\r\n    * @param user address which unlocked nfts (owner of tokens)\r\n    * @param nft collection address\r\n    * @param tokenIds list of tokenIds from `nft` collection\r\n    */\r\n    event Unlocked(address indexed user, address indexed nft, uint256[] tokenIds);\r\n\r\n    /**\r\n    * @dev Locks multiple tokenIds from multiple collections.\r\n    * @param nfts list of collection addresses.\r\n    * @param tokenIds list of tokenIds from collections. First dimension index has to match `nfts` index.\r\n    */\r\n    function lock(address[] calldata nfts, uint256[][] calldata tokenIds) external {\r\n        require(nfts.length == tokenIds.length, \"NFTs addresses & tokenIds length mismatch.\");\r\n\r\n        uint256 nftsLength = nfts.length;\r\n        uint256 tokenIdsLength;\r\n        for (uint8 i = 0; i < nftsLength; i++) {\r\n            tokenIdsLength = tokenIds[i].length;\r\n            if (tokenIdsLength > 0) {\r\n                emit Locked(msg.sender, nfts[i], tokenIds[i]);\r\n                for (uint8 j = 0; j < tokenIdsLength; j++) {\r\n                    lockedData[nfts[i]][tokenIds[i][j]].user = msg.sender;\r\n                    lockedData[nfts[i]][tokenIds[i][j]].blockNo = block.number;\r\n                    INFT(nfts[i]).transferFrom(msg.sender, address(this), tokenIds[i][j]);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n    * @dev Unlocks multiple tokenIds from multiple collections.\r\n    * @param nfts list of collection addresses.\r\n    * @param tokenIds list of tokenIds from collections. First dimension index has to match `nfts` index.\r\n    */\r\n    function unlock(address[] calldata nfts, uint256[][] calldata tokenIds) external {\r\n        require(nfts.length == tokenIds.length, \"NFTs addresses & tokenIds length mismatch.\");\r\n\r\n        uint256 nftsLength = nfts.length;\r\n        uint256 tokenIdsLength;\r\n        for (uint8 i = 0; i < nftsLength; i++) {\r\n            tokenIdsLength = tokenIds[i].length;\r\n            if (tokenIdsLength > 0) {\r\n                emit Unlocked(msg.sender, nfts[i], tokenIds[i]);\r\n                for (uint8 j = 0; j < tokenIdsLength; j++) {\r\n                    require(msg.sender == lockedData[nfts[i]][tokenIds[i][j]].user, \"Token does not belong to user.\");\r\n                    require(block.number > lockedData[nfts[i]][tokenIds[i][j]].blockNo, \"Unlock too fast.\");\r\n\r\n                    delete lockedData[nfts[i]][tokenIds[i][j]];\r\n                    INFT(nfts[i]).transferFrom(address(this), msg.sender, tokenIds[i][j]);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n}","ABI":"[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"nft\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"tokenIds\",\"type\":\"uint256[]\"}],\"name\":\"Locked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"nft\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"tokenIds\",\"type\":\"uint256[]\"}],\"name\":\"Unlocked\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"nfts\",\"type\":\"address[]\"},{\"internalType\":\"uint256[][]\",\"name\":\"tokenIds\",\"type\":\"uint256[][]\"}],\"name\":\"lock\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"lockedData\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"blockNo\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"nfts\",\"type\":\"address[]\"},{\"internalType\":\"uint256[][]\",\"name\":\"tokenIds\",\"type\":\"uint256[][]\"}],\"name\":\"unlock\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"ElderGateway","CompilerVersion":"v0.8.9+commit.e5eed63a","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"ipfs://0cbb59cbc7015cabf041c7f7eed0a517219c5b7309f7da027db7092345887790"}]}