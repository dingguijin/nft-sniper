{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"settings\": {\r\n    \"evmVersion\": \"london\",\r\n    \"libraries\": {},\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"remappings\": [],\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  },\r\n  \"sources\": {\r\n    \"@openzeppelin/contracts/proxy/utils/Initializable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (proxy/utils/Initializable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/Address.sol\\\";\\n\\n/**\\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\\n *\\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\\n *\\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\\n *\\n * [CAUTION]\\n * ====\\n * Avoid leaving a contract uninitialized.\\n *\\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\\n * contract, which may impact the proxy. To initialize the implementation contract, you can either invoke the\\n * initializer manually, or you can include a constructor to automatically mark it as initialized when it is deployed:\\n *\\n * [.hljs-theme-light.nopadding]\\n * ```\\n * /// @custom:oz-upgrades-unsafe-allow constructor\\n * constructor() initializer {}\\n * ```\\n * ====\\n */\\nabstract contract Initializable {\\n    /**\\n     * @dev Indicates that the contract has been initialized.\\n     */\\n    bool private _initialized;\\n\\n    /**\\n     * @dev Indicates that the contract is in the process of being initialized.\\n     */\\n    bool private _initializing;\\n\\n    /**\\n     * @dev Modifier to protect an initializer function from being invoked twice.\\n     */\\n    modifier initializer() {\\n        // If the contract is initializing we ignore whether _initialized is set in order to support multiple\\n        // inheritance patterns, but we only do this in the context of a constructor, because in other contexts the\\n        // contract may have been reentered.\\n        require(_initializing ? _isConstructor() : !_initialized, \\\"Initializable: contract is already initialized\\\");\\n\\n        bool isTopLevelCall = !_initializing;\\n        if (isTopLevelCall) {\\n            _initializing = true;\\n            _initialized = true;\\n        }\\n\\n        _;\\n\\n        if (isTopLevelCall) {\\n            _initializing = false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\\n     * {initializer} modifier, directly or indirectly.\\n     */\\n    modifier onlyInitializing() {\\n        require(_initializing, \\\"Initializable: contract is not initializing\\\");\\n        _;\\n    }\\n\\n    function _isConstructor() private view returns (bool) {\\n        return !Address.isContract(address(this));\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.1;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\\n     *\\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\n     * constructor.\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize/address.code.length, which returns 0\\n        // for contracts in construction, since the code is only stored at the end\\n        // of the constructor execution.\\n\\n        return account.code.length > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        require(isContract(target), \\\"Address: static call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(isContract(target), \\\"Address: delegate call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length > 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/structs/EnumerableSet.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Library for managing\\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\\n * types.\\n *\\n * Sets have the following properties:\\n *\\n * - Elements are added, removed, and checked for existence in constant time\\n * (O(1)).\\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\\n *\\n * ```\\n * contract Example {\\n *     // Add the library methods\\n *     using EnumerableSet for EnumerableSet.AddressSet;\\n *\\n *     // Declare a set state variable\\n *     EnumerableSet.AddressSet private mySet;\\n * }\\n * ```\\n *\\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\\n * and `uint256` (`UintSet`) are supported.\\n */\\nlibrary EnumerableSet {\\n    // To implement this library for multiple types with as little code\\n    // repetition as possible, we write it in terms of a generic Set type with\\n    // bytes32 values.\\n    // The Set implementation uses private functions, and user-facing\\n    // implementations (such as AddressSet) are just wrappers around the\\n    // underlying Set.\\n    // This means that we can only create new EnumerableSets for types that fit\\n    // in bytes32.\\n\\n    struct Set {\\n        // Storage of set values\\n        bytes32[] _values;\\n        // Position of the value in the `values` array, plus 1 because index 0\\n        // means a value is not in the set.\\n        mapping(bytes32 => uint256) _indexes;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function _add(Set storage set, bytes32 value) private returns (bool) {\\n        if (!_contains(set, value)) {\\n            set._values.push(value);\\n            // The value is stored at length-1, but we add 1 to all indexes\\n            // and use 0 as a sentinel value\\n            set._indexes[value] = set._values.length;\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\\n        // We read and store the value's index to prevent multiple reads from the same storage slot\\n        uint256 valueIndex = set._indexes[value];\\n\\n        if (valueIndex != 0) {\\n            // Equivalent to contains(set, value)\\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\\n            // This modifies the order of the array, as noted in {at}.\\n\\n            uint256 toDeleteIndex = valueIndex - 1;\\n            uint256 lastIndex = set._values.length - 1;\\n\\n            if (lastIndex != toDeleteIndex) {\\n                bytes32 lastvalue = set._values[lastIndex];\\n\\n                // Move the last value to the index where the value to delete is\\n                set._values[toDeleteIndex] = lastvalue;\\n                // Update the index for the moved value\\n                set._indexes[lastvalue] = valueIndex; // Replace lastvalue's index to valueIndex\\n            }\\n\\n            // Delete the slot where the moved value was stored\\n            set._values.pop();\\n\\n            // Delete the index for the deleted slot\\n            delete set._indexes[value];\\n\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\\n        return set._indexes[value] != 0;\\n    }\\n\\n    /**\\n     * @dev Returns the number of values on the set. O(1).\\n     */\\n    function _length(Set storage set) private view returns (uint256) {\\n        return set._values.length;\\n    }\\n\\n    /**\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\\n        return set._values[index];\\n    }\\n\\n    /**\\n     * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n    function _values(Set storage set) private view returns (bytes32[] memory) {\\n        return set._values;\\n    }\\n\\n    // Bytes32Set\\n\\n    struct Bytes32Set {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\\n        return _add(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\\n        return _remove(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\\n        return _contains(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Returns the number of values in the set. O(1).\\n     */\\n    function length(Bytes32Set storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n    /**\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\\n        return _at(set._inner, index);\\n    }\\n\\n    /**\\n     * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\\n        return _values(set._inner);\\n    }\\n\\n    // AddressSet\\n\\n    struct AddressSet {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(AddressSet storage set, address value) internal returns (bool) {\\n        return _add(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(AddressSet storage set, address value) internal returns (bool) {\\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    /**\\n     * @dev Returns the number of values in the set. O(1).\\n     */\\n    function length(AddressSet storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n    /**\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\\n        return address(uint160(uint256(_at(set._inner, index))));\\n    }\\n\\n    /**\\n     * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n    function values(AddressSet storage set) internal view returns (address[] memory) {\\n        bytes32[] memory store = _values(set._inner);\\n        address[] memory result;\\n\\n        assembly {\\n            result := store\\n        }\\n\\n        return result;\\n    }\\n\\n    // UintSet\\n\\n    struct UintSet {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\\n        return _add(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\\n        return _remove(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\\n        return _contains(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Returns the number of values on the set. O(1).\\n     */\\n    function length(UintSet storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n    /**\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\\n        return uint256(_at(set._inner, index));\\n    }\\n\\n    /**\\n     * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\\n        bytes32[] memory store = _values(set._inner);\\n        uint256[] memory result;\\n\\n        assembly {\\n            result := store\\n        }\\n\\n        return result;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/EAS/TellerAS.sol\": {\r\n      \"content\": \"pragma solidity >=0.8.0 <0.9.0;\\n// SPDX-License-Identifier: MIT\\n\\nimport \\\"../Types.sol\\\";\\nimport \\\"../interfaces/IEAS.sol\\\";\\nimport \\\"../interfaces/IASRegistry.sol\\\";\\n\\n/**\\n * @title TellerAS - Teller Attestation Service - based on EAS - Ethereum Attestation Service\\n */\\ncontract TellerAS is IEAS {\\n    error AccessDenied();\\n    error AlreadyRevoked();\\n    error InvalidAttestation();\\n    error InvalidExpirationTime();\\n    error InvalidOffset();\\n    error InvalidRegistry();\\n    error InvalidSchema();\\n    error InvalidVerifier();\\n    error NotFound();\\n    error NotPayable();\\n\\n    string public constant VERSION = \\\"0.8\\\";\\n\\n    // A terminator used when concatenating and hashing multiple fields.\\n    string private constant HASH_TERMINATOR = \\\"@\\\";\\n\\n    // The AS global registry.\\n    IASRegistry private immutable _asRegistry;\\n\\n    // The EIP712 verifier used to verify signed attestations.\\n    IEASEIP712Verifier private immutable _eip712Verifier;\\n\\n    // A mapping between attestations and their related attestations.\\n    mapping(bytes32 => bytes32[]) private _relatedAttestations;\\n\\n    // A mapping between an account and its received attestations.\\n    mapping(address => mapping(bytes32 => bytes32[]))\\n        private _receivedAttestations;\\n\\n    // A mapping between an account and its sent attestations.\\n    mapping(address => mapping(bytes32 => bytes32[])) private _sentAttestations;\\n\\n    // A mapping between a schema and its attestations.\\n    mapping(bytes32 => bytes32[]) private _schemaAttestations;\\n\\n    // The global mapping between attestations and their UUIDs.\\n    mapping(bytes32 => Attestation) private _db;\\n\\n    // The global counter for the total number of attestations.\\n    uint256 private _attestationsCount;\\n\\n    bytes32 private _lastUUID;\\n\\n    /**\\n     * @dev Creates a new EAS instance.\\n     *\\n     * @param registry The address of the global AS registry.\\n     * @param verifier The address of the EIP712 verifier.\\n     */\\n    constructor(IASRegistry registry, IEASEIP712Verifier verifier) {\\n        if (address(registry) == address(0x0)) {\\n            revert InvalidRegistry();\\n        }\\n\\n        if (address(verifier) == address(0x0)) {\\n            revert InvalidVerifier();\\n        }\\n\\n        _asRegistry = registry;\\n        _eip712Verifier = verifier;\\n    }\\n\\n    /**\\n     * @inheritdoc IEAS\\n     */\\n    function getASRegistry() external view override returns (IASRegistry) {\\n        return _asRegistry;\\n    }\\n\\n    /**\\n     * @inheritdoc IEAS\\n     */\\n    function getEIP712Verifier()\\n        external\\n        view\\n        override\\n        returns (IEASEIP712Verifier)\\n    {\\n        return _eip712Verifier;\\n    }\\n\\n    /**\\n     * @inheritdoc IEAS\\n     */\\n    function getAttestationsCount() external view override returns (uint256) {\\n        return _attestationsCount;\\n    }\\n\\n    /**\\n     * @inheritdoc IEAS\\n     */\\n    function attest(\\n        address recipient,\\n        bytes32 schema,\\n        uint256 expirationTime,\\n        bytes32 refUUID,\\n        bytes calldata data\\n    ) public payable virtual override returns (bytes32) {\\n        return\\n            _attest(\\n                recipient,\\n                schema,\\n                expirationTime,\\n                refUUID,\\n                data,\\n                msg.sender\\n            );\\n    }\\n\\n    /**\\n     * @inheritdoc IEAS\\n     */\\n    function attestByDelegation(\\n        address recipient,\\n        bytes32 schema,\\n        uint256 expirationTime,\\n        bytes32 refUUID,\\n        bytes calldata data,\\n        address attester,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public payable virtual override returns (bytes32) {\\n        _eip712Verifier.attest(\\n            recipient,\\n            schema,\\n            expirationTime,\\n            refUUID,\\n            data,\\n            attester,\\n            v,\\n            r,\\n            s\\n        );\\n\\n        return\\n            _attest(recipient, schema, expirationTime, refUUID, data, attester);\\n    }\\n\\n    /**\\n     * @inheritdoc IEAS\\n     */\\n    function revoke(bytes32 uuid) public virtual override {\\n        return _revoke(uuid, msg.sender);\\n    }\\n\\n    /**\\n     * @inheritdoc IEAS\\n     */\\n    function revokeByDelegation(\\n        bytes32 uuid,\\n        address attester,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual override {\\n        _eip712Verifier.revoke(uuid, attester, v, r, s);\\n\\n        _revoke(uuid, attester);\\n    }\\n\\n    /**\\n     * @inheritdoc IEAS\\n     */\\n    function getAttestation(bytes32 uuid)\\n        external\\n        view\\n        override\\n        returns (Attestation memory)\\n    {\\n        return _db[uuid];\\n    }\\n\\n    /**\\n     * @inheritdoc IEAS\\n     */\\n    function isAttestationValid(bytes32 uuid)\\n        public\\n        view\\n        override\\n        returns (bool)\\n    {\\n        return _db[uuid].uuid != 0;\\n    }\\n\\n    /**\\n     * @inheritdoc IEAS\\n     */\\n    function isAttestationActive(bytes32 uuid)\\n        public\\n        view\\n        override\\n        returns (bool)\\n    {\\n        return\\n            isAttestationValid(uuid) &&\\n            _db[uuid].expirationTime >= block.timestamp &&\\n            _db[uuid].revocationTime == 0;\\n    }\\n\\n    /**\\n     * @inheritdoc IEAS\\n     */\\n    function getReceivedAttestationUUIDs(\\n        address recipient,\\n        bytes32 schema,\\n        uint256 start,\\n        uint256 length,\\n        bool reverseOrder\\n    ) external view override returns (bytes32[] memory) {\\n        return\\n            _sliceUUIDs(\\n                _receivedAttestations[recipient][schema],\\n                start,\\n                length,\\n                reverseOrder\\n            );\\n    }\\n\\n    /**\\n     * @inheritdoc IEAS\\n     */\\n    function getReceivedAttestationUUIDsCount(address recipient, bytes32 schema)\\n        external\\n        view\\n        override\\n        returns (uint256)\\n    {\\n        return _receivedAttestations[recipient][schema].length;\\n    }\\n\\n    /**\\n     * @inheritdoc IEAS\\n     */\\n    function getSentAttestationUUIDs(\\n        address attester,\\n        bytes32 schema,\\n        uint256 start,\\n        uint256 length,\\n        bool reverseOrder\\n    ) external view override returns (bytes32[] memory) {\\n        return\\n            _sliceUUIDs(\\n                _sentAttestations[attester][schema],\\n                start,\\n                length,\\n                reverseOrder\\n            );\\n    }\\n\\n    /**\\n     * @inheritdoc IEAS\\n     */\\n    function getSentAttestationUUIDsCount(address recipient, bytes32 schema)\\n        external\\n        view\\n        override\\n        returns (uint256)\\n    {\\n        return _sentAttestations[recipient][schema].length;\\n    }\\n\\n    /**\\n     * @inheritdoc IEAS\\n     */\\n    function getRelatedAttestationUUIDs(\\n        bytes32 uuid,\\n        uint256 start,\\n        uint256 length,\\n        bool reverseOrder\\n    ) external view override returns (bytes32[] memory) {\\n        return\\n            _sliceUUIDs(\\n                _relatedAttestations[uuid],\\n                start,\\n                length,\\n                reverseOrder\\n            );\\n    }\\n\\n    /**\\n     * @inheritdoc IEAS\\n     */\\n    function getRelatedAttestationUUIDsCount(bytes32 uuid)\\n        external\\n        view\\n        override\\n        returns (uint256)\\n    {\\n        return _relatedAttestations[uuid].length;\\n    }\\n\\n    /**\\n     * @inheritdoc IEAS\\n     */\\n    function getSchemaAttestationUUIDs(\\n        bytes32 schema,\\n        uint256 start,\\n        uint256 length,\\n        bool reverseOrder\\n    ) external view override returns (bytes32[] memory) {\\n        return\\n            _sliceUUIDs(\\n                _schemaAttestations[schema],\\n                start,\\n                length,\\n                reverseOrder\\n            );\\n    }\\n\\n    /**\\n     * @inheritdoc IEAS\\n     */\\n    function getSchemaAttestationUUIDsCount(bytes32 schema)\\n        external\\n        view\\n        override\\n        returns (uint256)\\n    {\\n        return _schemaAttestations[schema].length;\\n    }\\n\\n    /**\\n     * @dev Attests to a specific AS.\\n     *\\n     * @param recipient The recipient of the attestation.\\n     * @param schema The UUID of the AS.\\n     * @param expirationTime The expiration time of the attestation.\\n     * @param refUUID An optional related attestation's UUID.\\n     * @param data Additional custom data.\\n     * @param attester The attesting account.\\n     *\\n     * @return The UUID of the new attestation.\\n     */\\n    function _attest(\\n        address recipient,\\n        bytes32 schema,\\n        uint256 expirationTime,\\n        bytes32 refUUID,\\n        bytes calldata data,\\n        address attester\\n    ) private returns (bytes32) {\\n        if (expirationTime <= block.timestamp) {\\n            revert InvalidExpirationTime();\\n        }\\n\\n        IASRegistry.ASRecord memory asRecord = _asRegistry.getAS(schema);\\n        if (asRecord.uuid == EMPTY_UUID) {\\n            revert InvalidSchema();\\n        }\\n\\n        IASResolver resolver = asRecord.resolver;\\n        if (address(resolver) != address(0x0)) {\\n            if (msg.value != 0 && !resolver.isPayable()) {\\n                revert NotPayable();\\n            }\\n\\n            if (\\n                !resolver.resolve{ value: msg.value }(\\n                    recipient,\\n                    asRecord.schema,\\n                    data,\\n                    expirationTime,\\n                    attester\\n                )\\n            ) {\\n                revert InvalidAttestation();\\n            }\\n        }\\n\\n        Attestation memory attestation = Attestation({\\n            uuid: EMPTY_UUID,\\n            schema: schema,\\n            recipient: recipient,\\n            attester: attester,\\n            time: block.timestamp,\\n            expirationTime: expirationTime,\\n            revocationTime: 0,\\n            refUUID: refUUID,\\n            data: data\\n        });\\n\\n        _lastUUID = _getUUID(attestation);\\n        attestation.uuid = _lastUUID;\\n\\n        _receivedAttestations[recipient][schema].push(_lastUUID);\\n        _sentAttestations[attester][schema].push(_lastUUID);\\n        _schemaAttestations[schema].push(_lastUUID);\\n\\n        _db[_lastUUID] = attestation;\\n        _attestationsCount++;\\n\\n        if (refUUID != 0) {\\n            if (!isAttestationValid(refUUID)) {\\n                revert NotFound();\\n            }\\n\\n            _relatedAttestations[refUUID].push(_lastUUID);\\n        }\\n\\n        emit Attested(recipient, attester, _lastUUID, schema);\\n\\n        return _lastUUID;\\n    }\\n\\n    function getLastUUID() external view returns (bytes32) {\\n        return _lastUUID;\\n    }\\n\\n    /**\\n     * @dev Revokes an existing attestation to a specific AS.\\n     *\\n     * @param uuid The UUID of the attestation to revoke.\\n     * @param attester The attesting account.\\n     */\\n    function _revoke(bytes32 uuid, address attester) private {\\n        Attestation storage attestation = _db[uuid];\\n        if (attestation.uuid == EMPTY_UUID) {\\n            revert NotFound();\\n        }\\n\\n        if (attestation.attester != attester) {\\n            revert AccessDenied();\\n        }\\n\\n        if (attestation.revocationTime != 0) {\\n            revert AlreadyRevoked();\\n        }\\n\\n        attestation.revocationTime = block.timestamp;\\n\\n        emit Revoked(attestation.recipient, attester, uuid, attestation.schema);\\n    }\\n\\n    /**\\n     * @dev Calculates a UUID for a given attestation.\\n     *\\n     * @param attestation The input attestation.\\n     *\\n     * @return Attestation UUID.\\n     */\\n    function _getUUID(Attestation memory attestation)\\n        private\\n        view\\n        returns (bytes32)\\n    {\\n        return\\n            keccak256(\\n                abi.encodePacked(\\n                    attestation.schema,\\n                    attestation.recipient,\\n                    attestation.attester,\\n                    attestation.time,\\n                    attestation.expirationTime,\\n                    attestation.data,\\n                    HASH_TERMINATOR,\\n                    _attestationsCount\\n                )\\n            );\\n    }\\n\\n    /**\\n     * @dev Returns a slice in an array of attestation UUIDs.\\n     *\\n     * @param uuids The array of attestation UUIDs.\\n     * @param start The offset to start from.\\n     * @param length The number of total members to retrieve.\\n     * @param reverseOrder Whether the offset starts from the end and the data is returned in reverse.\\n     *\\n     * @return An array of attestation UUIDs.\\n     */\\n    function _sliceUUIDs(\\n        bytes32[] memory uuids,\\n        uint256 start,\\n        uint256 length,\\n        bool reverseOrder\\n    ) private pure returns (bytes32[] memory) {\\n        uint256 attestationsLength = uuids.length;\\n        if (attestationsLength == 0) {\\n            return new bytes32[](0);\\n        }\\n\\n        if (start >= attestationsLength) {\\n            revert InvalidOffset();\\n        }\\n\\n        uint256 len = length;\\n        if (attestationsLength < start + length) {\\n            len = attestationsLength - start;\\n        }\\n\\n        bytes32[] memory res = new bytes32[](len);\\n\\n        for (uint256 i = 0; i < len; ++i) {\\n            res[i] = uuids[\\n                reverseOrder ? attestationsLength - (start + i + 1) : start + i\\n            ];\\n        }\\n\\n        return res;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/EAS/TellerASResolver.sol\": {\r\n      \"content\": \"pragma solidity >=0.8.0 <0.9.0;\\n// SPDX-License-Identifier: MIT\\n\\nimport \\\"../interfaces/IASResolver.sol\\\";\\n\\n/**\\n * @title A base resolver contract\\n */\\nabstract contract TellerASResolver is IASResolver {\\n    error NotPayable();\\n\\n    function isPayable() public pure virtual override returns (bool) {\\n        return false;\\n    }\\n\\n    receive() external payable virtual {\\n        if (!isPayable()) {\\n            revert NotPayable();\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/MarketRegistry.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n// Contracts\\nimport \\\"./EAS/TellerAS.sol\\\";\\nimport \\\"./EAS/TellerASResolver.sol\\\";\\n\\n//must continue to use this so storage slots are not broken\\nimport \\\"@openzeppelin/contracts/proxy/utils/Initializable.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/Context.sol\\\";\\n\\n// Interfaces\\nimport \\\"./interfaces/IMarketRegistry.sol\\\";\\n\\n// Libraries\\nimport {\\n    EnumerableSet\\n} from \\\"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\\\";\\n\\ncontract MarketRegistry is\\n    IMarketRegistry,\\n    Initializable,\\n    Context,\\n    TellerASResolver\\n{\\n    using EnumerableSet for EnumerableSet.AddressSet;\\n\\n    /** Constant Variables **/\\n\\n    uint256 public constant CURRENT_CODE_VERSION = 2;\\n\\n    /* Storage Variables */\\n\\n    struct Marketplace {\\n        address owner;\\n        string metadataURI;\\n        uint16 marketplaceFeePercent; // 10000 is 100%\\n        bool lenderAttestationRequired;\\n        EnumerableSet.AddressSet verifiedLendersForMarket;\\n        mapping(address => bytes32) lenderAttestationIds;\\n        uint32 paymentCycleDuration; //unix time\\n        uint32 paymentDefaultDuration; //unix time\\n        uint32 bidExpirationTime; //unix time\\n        bool borrowerAttestationRequired;\\n        EnumerableSet.AddressSet verifiedBorrowersForMarket;\\n        mapping(address => bytes32) borrowerAttestationIds;\\n    }\\n\\n    bytes32 public lenderAttestationSchemaId;\\n\\n    mapping(uint256 => Marketplace) internal markets;\\n    mapping(bytes32 => uint256) internal _uriToId;\\n    uint256 public marketCount;\\n    bytes32 private _attestingSchemaId;\\n    bytes32 public borrowerAttestationSchemaId;\\n\\n    uint256 public version;\\n\\n    mapping(uint256 => bool) private marketIsClosed;\\n\\n    TellerAS public tellerAS;\\n\\n    /* Modifiers */\\n\\n    modifier ownsMarket(uint256 _marketId) {\\n        require(markets[_marketId].owner == _msgSender(), \\\"Not the owner\\\");\\n        _;\\n    }\\n\\n    modifier withAttestingSchema(bytes32 schemaId) {\\n        _attestingSchemaId = schemaId;\\n        _;\\n        _attestingSchemaId = bytes32(0);\\n    }\\n\\n    /* Events */\\n\\n    event MarketCreated(address indexed owner, uint256 marketId);\\n    event SetMarketURI(uint256 marketId, string uri);\\n    event SetPaymentCycleDuration(uint256 marketId, uint32 duration);\\n    event SetPaymentDefaultDuration(uint256 marketId, uint32 duration);\\n    event SetBidExpirationTime(uint256 marketId, uint32 duration);\\n    event SetMarketFee(uint256 marketId, uint16 feePct);\\n    event LenderAttestation(uint256 marketId, address lender);\\n    event BorrowerAttestation(uint256 marketId, address borrower);\\n    event LenderRevocation(uint256 marketId, address lender);\\n    event BorrowerRevocation(uint256 marketId, address borrower);\\n    event MarketClosed(uint256 marketId);\\n    event LenderExitMarket(uint256 marketId, address lender);\\n    event BorrowerExitMarket(uint256 marketId, address borrower);\\n\\n    /* External Functions */\\n\\n    function initialize(TellerAS _tellerAS) external initializer {\\n        tellerAS = _tellerAS;\\n\\n        lenderAttestationSchemaId = tellerAS.getASRegistry().register(\\n            \\\"(uint256 marketId, address lenderAddress)\\\",\\n            this\\n        );\\n        borrowerAttestationSchemaId = tellerAS.getASRegistry().register(\\n            \\\"(uint256 marketId, address borrowerAddress)\\\",\\n            this\\n        );\\n    }\\n\\n    /**\\n     * @notice Sets the new tellerAS on upgrade\\n     */\\n    function onUpgrade(TellerAS _tellerAS) external {\\n        require(\\n            version != CURRENT_CODE_VERSION,\\n            \\\"Contract already upgraded to latest version!\\\"\\n        );\\n        version = CURRENT_CODE_VERSION;\\n\\n        tellerAS = _tellerAS;\\n    }\\n\\n    /**\\n     * @notice Creates a new market.\\n     * @param _initialOwner Address who will initially own the market.\\n     * @param _paymentCycleDuration Length of time in seconds before a bid's next payment is required to be made.\\n     * @param _paymentDefaultDuration Length of time in seconds before a loan is considered in default for non-payment.\\n     * @param _bidExpirationTime Length of time in seconds before pending bids expire.\\n     * @param _requireLenderAttestation Boolean that indicates if lenders require attestation to join market.\\n     * @param _requireBorrowerAttestation Boolean that indicates if borrowers require attestation to join market.\\n     * @param _uri URI string to get metadata details about the market.\\n     */\\n    function createMarket(\\n        address _initialOwner,\\n        uint32 _paymentCycleDuration,\\n        uint32 _paymentDefaultDuration,\\n        uint32 _bidExpirationTime,\\n        uint16 _feePercent,\\n        bool _requireLenderAttestation,\\n        bool _requireBorrowerAttestation,\\n        string calldata _uri\\n    ) external {\\n        require(_initialOwner != address(0), \\\"Invalid owner address\\\");\\n        // Increment market ID counter\\n        uint256 marketId = ++marketCount;\\n\\n        // Set the market owner\\n        markets[marketId].owner = _initialOwner;\\n\\n        setMarketURI(marketId, _uri);\\n        setPaymentCycleDuration(marketId, _paymentCycleDuration);\\n        setPaymentDefaultDuration(marketId, _paymentDefaultDuration);\\n        setMarketFeePercent(marketId, _feePercent);\\n        setBidExpirationTime(marketId, _bidExpirationTime);\\n\\n        // Check if market requires lender attestation to join\\n        if (_requireLenderAttestation) {\\n            markets[marketId].lenderAttestationRequired = true;\\n        }\\n        // Check if market requires borrower attestation to join\\n        if (_requireBorrowerAttestation) {\\n            markets[marketId].borrowerAttestationRequired = true;\\n        }\\n\\n        emit MarketCreated(_initialOwner, marketId);\\n    }\\n\\n    /**\\n     * @notice Closes a market so new bids cannot be added.\\n     * @param _marketId The market ID for the market to close.\\n     */\\n\\n    function closeMarket(uint256 _marketId) public ownsMarket(_marketId) {\\n        if (!marketIsClosed[_marketId]) {\\n            marketIsClosed[_marketId] = true;\\n\\n            emit MarketClosed(_marketId);\\n        }\\n    }\\n\\n    /**\\n     * @notice Returns the status of a market being open or closed for new bids.\\n     * @param _marketId The market ID for the market to check.\\n     */\\n    function isMarketClosed(uint256 _marketId)\\n        public\\n        view\\n        override\\n        returns (bool)\\n    {\\n        return marketIsClosed[_marketId];\\n    }\\n\\n    /**\\n     * @notice Adds a lender to a market.\\n     * @dev See {_attestStakeholder}.\\n     */\\n    function attestLender(\\n        uint256 _marketId,\\n        address _lenderAddress,\\n        uint256 _expirationTime\\n    ) external {\\n        _attestStakeholder(_marketId, _lenderAddress, _expirationTime, true);\\n    }\\n\\n    /**\\n     * @notice Adds a lender to a market via delegated attestation.\\n     * @dev See {_attestStakeholderViaDelegation}.\\n     */\\n    function attestLender(\\n        uint256 _marketId,\\n        address _lenderAddress,\\n        uint256 _expirationTime,\\n        uint8 _v,\\n        bytes32 _r,\\n        bytes32 _s\\n    ) external {\\n        _attestStakeholderViaDelegation(\\n            _marketId,\\n            _lenderAddress,\\n            _expirationTime,\\n            true,\\n            _v,\\n            _r,\\n            _s\\n        );\\n    }\\n\\n    /**\\n     * @notice Removes a lender from an market.\\n     * @dev See {_revokeStakeholder}.\\n     */\\n    function revokeLender(uint256 _marketId, address _lenderAddress) external {\\n        _revokeStakeholder(_marketId, _lenderAddress, true);\\n    }\\n\\n    /**\\n     * @notice Removes a borrower from a market via delegated revocation.\\n     * @dev See {_revokeStakeholderViaDelegation}.\\n     */\\n    function revokeLender(\\n        uint256 _marketId,\\n        address _lenderAddress,\\n        uint8 _v,\\n        bytes32 _r,\\n        bytes32 _s\\n    ) external {\\n        _revokeStakeholderViaDelegation(\\n            _marketId,\\n            _lenderAddress,\\n            true,\\n            _v,\\n            _r,\\n            _s\\n        );\\n    }\\n\\n    /**\\n     * @notice Allows a lender to voluntarily leave a market.\\n     * @param _marketId The market ID to leave.\\n     */\\n    function lenderExitMarket(uint256 _marketId) external {\\n        // Remove lender address from market set\\n        bool response = markets[_marketId].verifiedLendersForMarket.remove(\\n            _msgSender()\\n        );\\n        if (response) {\\n            emit LenderExitMarket(_marketId, _msgSender());\\n        }\\n    }\\n\\n    /**\\n     * @notice Adds a borrower to a market.\\n     * @dev See {_attestStakeholder}.\\n     */\\n    function attestBorrower(\\n        uint256 _marketId,\\n        address _borrowerAddress,\\n        uint256 _expirationTime\\n    ) external {\\n        _attestStakeholder(_marketId, _borrowerAddress, _expirationTime, false);\\n    }\\n\\n    /**\\n     * @notice Adds a borrower to a market via delegated attestation.\\n     * @dev See {_attestStakeholderViaDelegation}.\\n     */\\n    function attestBorrower(\\n        uint256 _marketId,\\n        address _borrowerAddress,\\n        uint256 _expirationTime,\\n        uint8 _v,\\n        bytes32 _r,\\n        bytes32 _s\\n    ) external {\\n        _attestStakeholderViaDelegation(\\n            _marketId,\\n            _borrowerAddress,\\n            _expirationTime,\\n            false,\\n            _v,\\n            _r,\\n            _s\\n        );\\n    }\\n\\n    /**\\n     * @notice Removes a borrower from an market.\\n     * @dev See {_revokeStakeholder}.\\n     */\\n    function revokeBorrower(uint256 _marketId, address _borrowerAddress)\\n        external\\n    {\\n        _revokeStakeholder(_marketId, _borrowerAddress, false);\\n    }\\n\\n    /**\\n     * @notice Removes a borrower from a market via delegated revocation.\\n     * @dev See {_revokeStakeholderViaDelegation}.\\n     */\\n    function revokeBorrower(\\n        uint256 _marketId,\\n        address _borrowerAddress,\\n        uint8 _v,\\n        bytes32 _r,\\n        bytes32 _s\\n    ) external {\\n        _revokeStakeholderViaDelegation(\\n            _marketId,\\n            _borrowerAddress,\\n            false,\\n            _v,\\n            _r,\\n            _s\\n        );\\n    }\\n\\n    /**\\n     * @notice Allows a borrower to voluntarily leave a market.\\n     * @param _marketId The market ID to leave.\\n     */\\n    function borrowerExitMarket(uint256 _marketId) external {\\n        // Remove borrower address from market set\\n        bool response = markets[_marketId].verifiedBorrowersForMarket.remove(\\n            _msgSender()\\n        );\\n        if (response) {\\n            emit BorrowerExitMarket(_marketId, _msgSender());\\n        }\\n    }\\n\\n    /**\\n     * @notice Verifies an attestation is valid.\\n     * @dev This function must only be called by the `attestLender` function above.\\n     * @param recipient Lender's address who is being attested.\\n     * @param schema The schema used for the attestation.\\n     * @param data Data the must include the market ID and lender's address\\n     * @param\\n     * @param attestor Market owner's address who signed the attestation.\\n     * @return Boolean indicating the attestation was successful.\\n     */\\n    function resolve(\\n        address recipient,\\n        bytes calldata schema,\\n        bytes calldata data,\\n        uint256, /* expirationTime */\\n        address attestor\\n    ) external payable override returns (bool) {\\n        bytes32 attestationSchemaId = keccak256(\\n            abi.encodePacked(schema, address(this))\\n        );\\n        (uint256 marketId, address lenderAddress) = abi.decode(\\n            data,\\n            (uint256, address)\\n        );\\n        return\\n            (_attestingSchemaId == attestationSchemaId &&\\n                recipient == lenderAddress &&\\n                attestor == markets[marketId].owner) ||\\n            attestor == address(this);\\n    }\\n\\n    /**\\n     * @notice Transfers ownership of a marketplace.\\n     * @param _marketId The ID of a market.\\n     * @param _newOwner Address of the new market owner.\\n     *\\n     * Requirements:\\n     * - The caller must by the current owner.\\n     */\\n    function transferMarketOwnership(uint256 _marketId, address _newOwner)\\n        public\\n        ownsMarket(_marketId)\\n    {\\n        markets[_marketId].owner = _newOwner;\\n    }\\n\\n    /**\\n     * @notice Sets the metadata URI for a market.\\n     * @param _marketId The ID of a market.\\n     * @param _uri A URI that points to a market's metadata.\\n     *\\n     * Requirements:\\n     * - The caller must by the current owner.\\n     */\\n    function setMarketURI(uint256 _marketId, string calldata _uri)\\n        public\\n        ownsMarket(_marketId)\\n    {\\n        // Check if URI is already used\\n        bytes32 uriId = keccak256(abi.encode(_uri));\\n        require(_uriToId[uriId] == 0, \\\"non-unique market URI\\\");\\n\\n        // Update market counter & store reverse lookup\\n        _uriToId[uriId] = _marketId;\\n        markets[_marketId].metadataURI = _uri;\\n\\n        emit SetMarketURI(_marketId, _uri);\\n    }\\n\\n    /**\\n     * @notice Sets the duration of new loans for this market before they turn delinquent.\\n     * @notice Changing this value does not change the terms of existing loans for this market.\\n     * @param _marketId The ID of a market.\\n     * @param _duration Delinquency duration for new loans\\n     */\\n    function setPaymentCycleDuration(uint256 _marketId, uint32 _duration)\\n        public\\n        ownsMarket(_marketId)\\n    {\\n        markets[_marketId].paymentCycleDuration = _duration;\\n\\n        emit SetPaymentCycleDuration(_marketId, _duration);\\n    }\\n\\n    /**\\n     * @notice Sets the duration of new loans for this market before they turn defaulted.\\n     * @notice Changing this value does not change the terms of existing loans for this market.\\n     * @param _marketId The ID of a market.\\n     * @param _duration Default duration for new loans\\n     */\\n    function setPaymentDefaultDuration(uint256 _marketId, uint32 _duration)\\n        public\\n        ownsMarket(_marketId)\\n    {\\n        markets[_marketId].paymentDefaultDuration = _duration;\\n\\n        emit SetPaymentDefaultDuration(_marketId, _duration);\\n    }\\n\\n    function setBidExpirationTime(uint256 marketId, uint32 duration)\\n        public\\n        ownsMarket(marketId)\\n    {\\n        markets[marketId].bidExpirationTime = duration;\\n\\n        emit SetBidExpirationTime(marketId, duration);\\n    }\\n\\n    /**\\n     * @notice Sets the fee for the market.\\n     * @param _marketId The ID of a market.\\n     * @param _newPercent The percentage fee in basis points.\\n     *\\n     * Requirements:\\n     * - The caller must by the current owner.\\n     */\\n    function setMarketFeePercent(uint256 _marketId, uint16 _newPercent)\\n        public\\n        ownsMarket(_marketId)\\n    {\\n        require(_newPercent >= 0 && _newPercent <= 10000, \\\"invalid percent\\\");\\n        markets[_marketId].marketplaceFeePercent = _newPercent;\\n        emit SetMarketFee(_marketId, _newPercent);\\n    }\\n\\n    /**\\n     * @notice Gets the data associated with a market.\\n     * @param _marketId The ID of a market.\\n     */\\n    function getMarketData(uint256 _marketId)\\n        public\\n        view\\n        returns (\\n            address owner,\\n            uint32 paymentCycleDuration,\\n            uint32 paymentDefaultDuration,\\n            uint32 loanExpirationTime,\\n            string memory metadataURI,\\n            uint16 marketplaceFeePercent,\\n            bool lenderAttestationRequired\\n        )\\n    {\\n        return (\\n            markets[_marketId].owner,\\n            markets[_marketId].paymentCycleDuration,\\n            markets[_marketId].paymentDefaultDuration,\\n            markets[_marketId].bidExpirationTime,\\n            markets[_marketId].metadataURI,\\n            markets[_marketId].marketplaceFeePercent,\\n            markets[_marketId].lenderAttestationRequired\\n        );\\n    }\\n\\n    /**\\n     * @notice Gets the attestation requirements for a given market.\\n     * @param _marketId The ID of the market.\\n     */\\n    function getMarketAttestationRequirements(uint256 _marketId)\\n        public\\n        view\\n        returns (\\n            bool lenderAttestationRequired,\\n            bool borrowerAttestationRequired\\n        )\\n    {\\n        return (\\n            markets[_marketId].lenderAttestationRequired,\\n            markets[_marketId].borrowerAttestationRequired\\n        );\\n    }\\n\\n    /**\\n     * @notice Gets the address of a market's owner.\\n     * @param _marketId The ID of a market.\\n     * @return The address of a market's owner.\\n     */\\n    function getMarketOwner(uint256 _marketId)\\n        public\\n        view\\n        override\\n        returns (address)\\n    {\\n        return markets[_marketId].owner;\\n    }\\n\\n    /**\\n     * @notice Gets the metadata URI of a market.\\n     * @param _marketId The ID of a market.\\n     * @return URI of a market's metadata.\\n     */\\n    function getMarketURI(uint256 _marketId)\\n        public\\n        view\\n        override\\n        returns (string memory)\\n    {\\n        return markets[_marketId].metadataURI;\\n    }\\n\\n    /**\\n     * @notice Gets the loan delinquent duration of a market.\\n     * @param _marketId The ID of a market.\\n     * @return Duration of a loan until it is delinquent.\\n     */\\n    function getPaymentCycleDuration(uint256 _marketId)\\n        public\\n        view\\n        override\\n        returns (uint32)\\n    {\\n        return markets[_marketId].paymentCycleDuration;\\n    }\\n\\n    /**\\n     * @notice Gets the loan default duration of a market.\\n     * @param _marketId The ID of a market.\\n     * @return Duration of a loan repayment interval until it is default.\\n     */\\n    function getPaymentDefaultDuration(uint256 _marketId)\\n        public\\n        view\\n        override\\n        returns (uint32)\\n    {\\n        return markets[_marketId].paymentDefaultDuration;\\n    }\\n\\n    function getBidExpirationTime(uint256 marketId)\\n        public\\n        view\\n        override\\n        returns (uint32)\\n    {\\n        return markets[marketId].bidExpirationTime;\\n    }\\n\\n    /**\\n     * @notice Gets the marketplace fee in basis points\\n     * @param _marketId The ID of a market.\\n     * @return fee in basis points\\n     */\\n    function getMarketplaceFee(uint256 _marketId)\\n        public\\n        view\\n        override\\n        returns (uint16 fee)\\n    {\\n        return markets[_marketId].marketplaceFeePercent;\\n    }\\n\\n    /**\\n     * @notice Checks if a lender has been attested and added to a market.\\n     * @param _marketId The ID of a market.\\n     * @param _lenderAddress Address to check.\\n     * @return isVerified_ Boolean indicating if a lender has been added to a market.\\n     * @return uuid_ Bytes32 representing the UUID of the lender.\\n     */\\n    function isVerifiedLender(uint256 _marketId, address _lenderAddress)\\n        public\\n        view\\n        override\\n        returns (bool isVerified_, bytes32 uuid_)\\n    {\\n        return\\n            _isVerified(\\n                _lenderAddress,\\n                markets[_marketId].lenderAttestationRequired,\\n                markets[_marketId].lenderAttestationIds,\\n                markets[_marketId].verifiedLendersForMarket\\n            );\\n    }\\n\\n    /**\\n     * @notice Checks if a borrower has been attested and added to a market.\\n     * @param _marketId The ID of a market.\\n     * @param _borrowerAddress Address of the borrower to check.\\n     * @return isVerified_ Boolean indicating if a borrower has been added to a market.\\n     * @return uuid_ Bytes32 representing the UUID of the borrower.\\n     */\\n    function isVerifiedBorrower(uint256 _marketId, address _borrowerAddress)\\n        public\\n        view\\n        override\\n        returns (bool isVerified_, bytes32 uuid_)\\n    {\\n        return\\n            _isVerified(\\n                _borrowerAddress,\\n                markets[_marketId].borrowerAttestationRequired,\\n                markets[_marketId].borrowerAttestationIds,\\n                markets[_marketId].verifiedBorrowersForMarket\\n            );\\n    }\\n\\n    /**\\n     * @notice Gets addresses of all attested lenders.\\n     * @param _marketId The ID of a market.\\n     * @param _page Page index to start from.\\n     * @param _perPage Number of items in a page to return.\\n     * @return Array of addresses that have been added to a market.\\n     */\\n    function getAllVerifiedLendersForMarket(\\n        uint256 _marketId,\\n        uint256 _page,\\n        uint256 _perPage\\n    ) public view returns (address[] memory) {\\n        EnumerableSet.AddressSet storage set = markets[_marketId]\\n            .verifiedLendersForMarket;\\n\\n        return _getStakeholdersForMarket(set, _page, _perPage);\\n    }\\n\\n    /**\\n     * @notice Gets addresses of all attested borrowers.\\n     * @param _marketId The ID of the market.\\n     * @param _page Page index to start from.\\n     * @param _perPage Number of items in a page to return.\\n     * @return Array of addresses that have been added to a market.\\n     */\\n    function getAllVerifiedBorrowersForMarket(\\n        uint256 _marketId,\\n        uint256 _page,\\n        uint256 _perPage\\n    ) public view returns (address[] memory) {\\n        EnumerableSet.AddressSet storage set = markets[_marketId]\\n            .verifiedBorrowersForMarket;\\n        return _getStakeholdersForMarket(set, _page, _perPage);\\n    }\\n\\n    /**\\n     * @notice Gets addresses of all attested relevant stakeholders.\\n     * @param _set The stored set of stakeholders to index from.\\n     * @param _page Page index to start from.\\n     * @param _perPage Number of items in a page to return.\\n     * @return stakeholders_ Array of addresses that have been added to a market.\\n     */\\n    function _getStakeholdersForMarket(\\n        EnumerableSet.AddressSet storage _set,\\n        uint256 _page,\\n        uint256 _perPage\\n    ) internal view returns (address[] memory stakeholders_) {\\n        uint256 len = _set.length();\\n\\n        uint256 start = _page * _perPage;\\n        if (start <= len) {\\n            uint256 end = start + _perPage;\\n            // Ensure we do not go out of bounds\\n            if (end > len) {\\n                end = len;\\n            }\\n\\n            stakeholders_ = new address[](end - start);\\n            for (uint256 i = start; i < end; i++) {\\n                stakeholders_[i] = _set.at(i);\\n            }\\n        }\\n    }\\n\\n    /* Internal Functions */\\n\\n    /**\\n     * @notice Sets the metadata URI for a market.\\n     * @param _marketId The ID of a market.\\n     * @param _uri A URI that points to a market's metadata.\\n     */\\n    function _setMarketUri(uint256 _marketId, string calldata _uri) internal {\\n        require(_marketId > 0, \\\"Market ID 0\\\");\\n\\n        // Check if URI is already used\\n        bytes32 uriId = keccak256(abi.encode(_uri));\\n        require(_uriToId[uriId] == 0, \\\"non-unique market URI\\\");\\n\\n        // Update market counter & store reverse lookup\\n        _uriToId[uriId] = _marketId;\\n        markets[_marketId].metadataURI = _uri;\\n\\n        emit SetMarketURI(_marketId, _uri);\\n    }\\n\\n    /**\\n     * @notice Adds a stakeholder (lender or borrower) to a market.\\n     * @param _marketId The market ID to add a borrower to.\\n     * @param _stakeholderAddress The address of the stakeholder to add to the market.\\n     * @param _expirationTime The expiration time of the attestation.\\n     * @param _expirationTime The expiration time of the attestation.\\n     * @param _isLender Boolean indicating if the stakeholder is a lender. Otherwise it is a borrower.\\n     */\\n    function _attestStakeholder(\\n        uint256 _marketId,\\n        address _stakeholderAddress,\\n        uint256 _expirationTime,\\n        bool _isLender\\n    )\\n        internal\\n        withAttestingSchema(\\n            _isLender ? lenderAttestationSchemaId : borrowerAttestationSchemaId\\n        )\\n    {\\n        require(\\n            _msgSender() == markets[_marketId].owner,\\n            \\\"Not the market owner\\\"\\n        );\\n\\n        // Submit attestation for borrower to join a market\\n        bytes32 uuid = tellerAS.attest(\\n            _stakeholderAddress,\\n            _attestingSchemaId, // set by the modifier\\n            _expirationTime,\\n            0,\\n            abi.encode(_marketId, _stakeholderAddress)\\n        );\\n        _attestStakeholderVerification(\\n            _marketId,\\n            _stakeholderAddress,\\n            uuid,\\n            _isLender\\n        );\\n    }\\n\\n    /**\\n     * @notice Adds a stakeholder (lender or borrower) to a market via delegated attestation.\\n     * @dev The signature must match that of the market owner.\\n     * @param _marketId The market ID to add a lender to.\\n     * @param _stakeholderAddress The address of the lender to add to the market.\\n     * @param _expirationTime The expiration time of the attestation.\\n     * @param _isLender Boolean indicating if the stakeholder is a lender. Otherwise it is a borrower.\\n     * @param _v Signature value\\n     * @param _r Signature value\\n     * @param _s Signature value\\n     */\\n    function _attestStakeholderViaDelegation(\\n        uint256 _marketId,\\n        address _stakeholderAddress,\\n        uint256 _expirationTime,\\n        bool _isLender,\\n        uint8 _v,\\n        bytes32 _r,\\n        bytes32 _s\\n    )\\n        internal\\n        withAttestingSchema(\\n            _isLender ? lenderAttestationSchemaId : borrowerAttestationSchemaId\\n        )\\n    {\\n        // NOTE: block scope to prevent stack too deep!\\n        bytes32 uuid;\\n        {\\n            bytes memory data = abi.encode(_marketId, _stakeholderAddress);\\n            address attestor = markets[_marketId].owner;\\n            // Submit attestation for stakeholder to join a market (attestation must be signed by market owner)\\n            uuid = tellerAS.attestByDelegation(\\n                _stakeholderAddress,\\n                _attestingSchemaId, // set by the modifier\\n                _expirationTime,\\n                0,\\n                data,\\n                attestor,\\n                _v,\\n                _r,\\n                _s\\n            );\\n        }\\n        _attestStakeholderVerification(\\n            _marketId,\\n            _stakeholderAddress,\\n            uuid,\\n            _isLender\\n        );\\n    }\\n\\n    /**\\n     * @notice Adds a stakeholder (borrower/lender) to a market.\\n     * @param _marketId The market ID to add a stakeholder to.\\n     * @param _stakeholderAddress The address of the stakeholder to add to the market.\\n     * @param _uuid The UUID of the attestation created.\\n     * @param _isLender Boolean indicating if the stakeholder is a lender. Otherwise it is a borrower.\\n     */\\n    function _attestStakeholderVerification(\\n        uint256 _marketId,\\n        address _stakeholderAddress,\\n        bytes32 _uuid,\\n        bool _isLender\\n    ) internal {\\n        if (_isLender) {\\n            // Store the lender attestation ID for the market ID\\n            markets[_marketId].lenderAttestationIds[\\n                _stakeholderAddress\\n            ] = _uuid;\\n            // Add lender address to market set\\n            markets[_marketId].verifiedLendersForMarket.add(\\n                _stakeholderAddress\\n            );\\n\\n            emit LenderAttestation(_marketId, _stakeholderAddress);\\n        } else {\\n            // Store the lender attestation ID for the market ID\\n            markets[_marketId].borrowerAttestationIds[\\n                _stakeholderAddress\\n            ] = _uuid;\\n            // Add lender address to market set\\n            markets[_marketId].verifiedBorrowersForMarket.add(\\n                _stakeholderAddress\\n            );\\n\\n            emit BorrowerAttestation(_marketId, _stakeholderAddress);\\n        }\\n    }\\n\\n    /**\\n     * @notice Removes a stakeholder from an market.\\n     * @dev The caller must be the market owner.\\n     * @param _marketId The market ID to remove the borrower from.\\n     * @param _stakeholderAddress The address of the borrower to remove from the market.\\n     * @param _isLender Boolean indicating if the stakeholder is a lender. Otherwise it is a borrower.\\n     */\\n    function _revokeStakeholder(\\n        uint256 _marketId,\\n        address _stakeholderAddress,\\n        bool _isLender\\n    ) internal {\\n        require(\\n            _msgSender() == markets[_marketId].owner,\\n            \\\"Not the market owner\\\"\\n        );\\n\\n        bytes32 uuid = _revokeStakeholderVerification(\\n            _marketId,\\n            _stakeholderAddress,\\n            _isLender\\n        );\\n        // NOTE: Disabling the call to revoke the attestation on EAS contracts\\n        //        tellerAS.revoke(uuid);\\n    }\\n\\n    /**\\n     * @notice Removes a stakeholder from an market via delegated revocation.\\n     * @param _marketId The market ID to remove the borrower from.\\n     * @param _stakeholderAddress The address of the borrower to remove from the market.\\n     * @param _isLender Boolean indicating if the stakeholder is a lender. Otherwise it is a borrower.\\n     * @param _v Signature value\\n     * @param _r Signature value\\n     * @param _s Signature value\\n     */\\n    function _revokeStakeholderViaDelegation(\\n        uint256 _marketId,\\n        address _stakeholderAddress,\\n        bool _isLender,\\n        uint8 _v,\\n        bytes32 _r,\\n        bytes32 _s\\n    ) internal {\\n        bytes32 uuid = _revokeStakeholderVerification(\\n            _marketId,\\n            _stakeholderAddress,\\n            _isLender\\n        );\\n        // NOTE: Disabling the call to revoke the attestation on EAS contracts\\n        //        address attestor = markets[_marketId].owner;\\n        //        tellerAS.revokeByDelegation(uuid, attestor, _v, _r, _s);\\n    }\\n\\n    /**\\n     * @notice Removes a stakeholder (borrower/lender) from a market.\\n     * @param _marketId The market ID to remove the lender from.\\n     * @param _stakeholderAddress The address of the stakeholder to remove from the market.\\n     * @param _isLender Boolean indicating if the stakeholder is a lender. Otherwise it is a borrower.\\n     * @return uuid_ The ID of the previously verified attestation.\\n     */\\n    function _revokeStakeholderVerification(\\n        uint256 _marketId,\\n        address _stakeholderAddress,\\n        bool _isLender\\n    ) internal returns (bytes32 uuid_) {\\n        if (_isLender) {\\n            uuid_ = markets[_marketId].lenderAttestationIds[\\n                _stakeholderAddress\\n            ];\\n            // Remove lender address from market set\\n            markets[_marketId].verifiedLendersForMarket.remove(\\n                _stakeholderAddress\\n            );\\n\\n            emit LenderRevocation(_marketId, _stakeholderAddress);\\n        } else {\\n            uuid_ = markets[_marketId].borrowerAttestationIds[\\n                _stakeholderAddress\\n            ];\\n            // Remove borrower address from market set\\n            markets[_marketId].verifiedBorrowersForMarket.remove(\\n                _stakeholderAddress\\n            );\\n\\n            emit BorrowerRevocation(_marketId, _stakeholderAddress);\\n        }\\n    }\\n\\n    /**\\n     * @notice Checks if a stakeholder has been attested and added to a market.\\n     * @param _stakeholderAddress Address of the stakeholder to check.\\n     * @param _attestationRequired Stored boolean indicating if attestation is required for the stakeholder class.\\n     * @param _stakeholderAttestationIds Mapping of attested Ids for the stakeholder class.\\n     */\\n    function _isVerified(\\n        address _stakeholderAddress,\\n        bool _attestationRequired,\\n        mapping(address => bytes32) storage _stakeholderAttestationIds,\\n        EnumerableSet.AddressSet storage _verifiedStakeholderForMarket\\n    ) internal view returns (bool isVerified_, bytes32 uuid_) {\\n        if (_attestationRequired) {\\n            isVerified_ =\\n                _verifiedStakeholderForMarket.contains(_stakeholderAddress) &&\\n                tellerAS.isAttestationActive(\\n                    _stakeholderAttestationIds[_stakeholderAddress]\\n                );\\n            uuid_ = _stakeholderAttestationIds[_stakeholderAddress];\\n        } else {\\n            isVerified_ = true;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/Types.sol\": {\r\n      \"content\": \"pragma solidity >=0.8.0 <0.9.0;\\n// SPDX-License-Identifier: MIT\\n\\n// A representation of an empty/uninitialized UUID.\\nbytes32 constant EMPTY_UUID = 0;\\n\"\r\n    },\r\n    \"contracts/interfaces/IASRegistry.sol\": {\r\n      \"content\": \"pragma solidity >=0.8.0 <0.9.0;\\n// SPDX-License-Identifier: MIT\\n\\nimport \\\"./IASResolver.sol\\\";\\n\\n/**\\n * @title The global AS registry interface.\\n */\\ninterface IASRegistry {\\n    /**\\n     * @title A struct representing a record for a submitted AS (Attestation Schema).\\n     */\\n    struct ASRecord {\\n        // A unique identifier of the AS.\\n        bytes32 uuid;\\n        // Optional schema resolver.\\n        IASResolver resolver;\\n        // Auto-incrementing index for reference, assigned by the registry itself.\\n        uint256 index;\\n        // Custom specification of the AS (e.g., an ABI).\\n        bytes schema;\\n    }\\n\\n    /**\\n     * @dev Triggered when a new AS has been registered\\n     *\\n     * @param uuid The AS UUID.\\n     * @param index The AS index.\\n     * @param schema The AS schema.\\n     * @param resolver An optional AS schema resolver.\\n     * @param attester The address of the account used to register the AS.\\n     */\\n    event Registered(\\n        bytes32 indexed uuid,\\n        uint256 indexed index,\\n        bytes schema,\\n        IASResolver resolver,\\n        address attester\\n    );\\n\\n    /**\\n     * @dev Submits and reserve a new AS\\n     *\\n     * @param schema The AS data schema.\\n     * @param resolver An optional AS schema resolver.\\n     *\\n     * @return The UUID of the new AS.\\n     */\\n    function register(bytes calldata schema, IASResolver resolver)\\n        external\\n        returns (bytes32);\\n\\n    /**\\n     * @dev Returns an existing AS by UUID\\n     *\\n     * @param uuid The UUID of the AS to retrieve.\\n     *\\n     * @return The AS data members.\\n     */\\n    function getAS(bytes32 uuid) external view returns (ASRecord memory);\\n\\n    /**\\n     * @dev Returns the global counter for the total number of attestations\\n     *\\n     * @return The global counter for the total number of attestations.\\n     */\\n    function getASCount() external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IASResolver.sol\": {\r\n      \"content\": \"pragma solidity >=0.8.0 <0.9.0;\\n\\n// SPDX-License-Identifier: MIT\\n\\n/**\\n * @title The interface of an optional AS resolver.\\n */\\ninterface IASResolver {\\n    /**\\n     * @dev Returns whether the resolver supports ETH transfers\\n     */\\n    function isPayable() external pure returns (bool);\\n\\n    /**\\n     * @dev Resolves an attestation and verifier whether its data conforms to the spec.\\n     *\\n     * @param recipient The recipient of the attestation.\\n     * @param schema The AS data schema.\\n     * @param data The actual attestation data.\\n     * @param expirationTime The expiration time of the attestation.\\n     * @param msgSender The sender of the original attestation message.\\n     *\\n     * @return Whether the data is valid according to the scheme.\\n     */\\n    function resolve(\\n        address recipient,\\n        bytes calldata schema,\\n        bytes calldata data,\\n        uint256 expirationTime,\\n        address msgSender\\n    ) external payable returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IEAS.sol\": {\r\n      \"content\": \"pragma solidity >=0.8.0 <0.9.0;\\n// SPDX-License-Identifier: MIT\\n\\nimport \\\"./IASRegistry.sol\\\";\\nimport \\\"./IEASEIP712Verifier.sol\\\";\\n\\n/**\\n * @title EAS - Ethereum Attestation Service interface\\n */\\ninterface IEAS {\\n    /**\\n     * @dev A struct representing a single attestation.\\n     */\\n    struct Attestation {\\n        // A unique identifier of the attestation.\\n        bytes32 uuid;\\n        // A unique identifier of the AS.\\n        bytes32 schema;\\n        // The recipient of the attestation.\\n        address recipient;\\n        // The attester/sender of the attestation.\\n        address attester;\\n        // The time when the attestation was created (Unix timestamp).\\n        uint256 time;\\n        // The time when the attestation expires (Unix timestamp).\\n        uint256 expirationTime;\\n        // The time when the attestation was revoked (Unix timestamp).\\n        uint256 revocationTime;\\n        // The UUID of the related attestation.\\n        bytes32 refUUID;\\n        // Custom attestation data.\\n        bytes data;\\n    }\\n\\n    /**\\n     * @dev Triggered when an attestation has been made.\\n     *\\n     * @param recipient The recipient of the attestation.\\n     * @param attester The attesting account.\\n     * @param uuid The UUID the revoked attestation.\\n     * @param schema The UUID of the AS.\\n     */\\n    event Attested(\\n        address indexed recipient,\\n        address indexed attester,\\n        bytes32 uuid,\\n        bytes32 indexed schema\\n    );\\n\\n    /**\\n     * @dev Triggered when an attestation has been revoked.\\n     *\\n     * @param recipient The recipient of the attestation.\\n     * @param attester The attesting account.\\n     * @param schema The UUID of the AS.\\n     * @param uuid The UUID the revoked attestation.\\n     */\\n    event Revoked(\\n        address indexed recipient,\\n        address indexed attester,\\n        bytes32 uuid,\\n        bytes32 indexed schema\\n    );\\n\\n    /**\\n     * @dev Returns the address of the AS global registry.\\n     *\\n     * @return The address of the AS global registry.\\n     */\\n    function getASRegistry() external view returns (IASRegistry);\\n\\n    /**\\n     * @dev Returns the address of the EIP712 verifier used to verify signed attestations.\\n     *\\n     * @return The address of the EIP712 verifier used to verify signed attestations.\\n     */\\n    function getEIP712Verifier() external view returns (IEASEIP712Verifier);\\n\\n    /**\\n     * @dev Returns the global counter for the total number of attestations.\\n     *\\n     * @return The global counter for the total number of attestations.\\n     */\\n    function getAttestationsCount() external view returns (uint256);\\n\\n    /**\\n     * @dev Attests to a specific AS.\\n     *\\n     * @param recipient The recipient of the attestation.\\n     * @param schema The UUID of the AS.\\n     * @param expirationTime The expiration time of the attestation.\\n     * @param refUUID An optional related attestation's UUID.\\n     * @param data Additional custom data.\\n     *\\n     * @return The UUID of the new attestation.\\n     */\\n    function attest(\\n        address recipient,\\n        bytes32 schema,\\n        uint256 expirationTime,\\n        bytes32 refUUID,\\n        bytes calldata data\\n    ) external payable returns (bytes32);\\n\\n    /**\\n     * @dev Attests to a specific AS using a provided EIP712 signature.\\n     *\\n     * @param recipient The recipient of the attestation.\\n     * @param schema The UUID of the AS.\\n     * @param expirationTime The expiration time of the attestation.\\n     * @param refUUID An optional related attestation's UUID.\\n     * @param data Additional custom data.\\n     * @param attester The attesting account.\\n     * @param v The recovery ID.\\n     * @param r The x-coordinate of the nonce R.\\n     * @param s The signature data.\\n     *\\n     * @return The UUID of the new attestation.\\n     */\\n    function attestByDelegation(\\n        address recipient,\\n        bytes32 schema,\\n        uint256 expirationTime,\\n        bytes32 refUUID,\\n        bytes calldata data,\\n        address attester,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external payable returns (bytes32);\\n\\n    /**\\n     * @dev Revokes an existing attestation to a specific AS.\\n     *\\n     * @param uuid The UUID of the attestation to revoke.\\n     */\\n    function revoke(bytes32 uuid) external;\\n\\n    /**\\n     * @dev Attests to a specific AS using a provided EIP712 signature.\\n     *\\n     * @param uuid The UUID of the attestation to revoke.\\n     * @param attester The attesting account.\\n     * @param v The recovery ID.\\n     * @param r The x-coordinate of the nonce R.\\n     * @param s The signature data.\\n     */\\n    function revokeByDelegation(\\n        bytes32 uuid,\\n        address attester,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external;\\n\\n    /**\\n     * @dev Returns an existing attestation by UUID.\\n     *\\n     * @param uuid The UUID of the attestation to retrieve.\\n     *\\n     * @return The attestation data members.\\n     */\\n    function getAttestation(bytes32 uuid)\\n        external\\n        view\\n        returns (Attestation memory);\\n\\n    /**\\n     * @dev Checks whether an attestation exists.\\n     *\\n     * @param uuid The UUID of the attestation to retrieve.\\n     *\\n     * @return Whether an attestation exists.\\n     */\\n    function isAttestationValid(bytes32 uuid) external view returns (bool);\\n\\n    /**\\n     * @dev Checks whether an attestation is active.\\n     *\\n     * @param uuid The UUID of the attestation to retrieve.\\n     *\\n     * @return Whether an attestation is active.\\n     */\\n    function isAttestationActive(bytes32 uuid) external view returns (bool);\\n\\n    /**\\n     * @dev Returns all received attestation UUIDs.\\n     *\\n     * @param recipient The recipient of the attestation.\\n     * @param schema The UUID of the AS.\\n     * @param start The offset to start from.\\n     * @param length The number of total members to retrieve.\\n     * @param reverseOrder Whether the offset starts from the end and the data is returned in reverse.\\n     *\\n     * @return An array of attestation UUIDs.\\n     */\\n    function getReceivedAttestationUUIDs(\\n        address recipient,\\n        bytes32 schema,\\n        uint256 start,\\n        uint256 length,\\n        bool reverseOrder\\n    ) external view returns (bytes32[] memory);\\n\\n    /**\\n     * @dev Returns the number of received attestation UUIDs.\\n     *\\n     * @param recipient The recipient of the attestation.\\n     * @param schema The UUID of the AS.\\n     *\\n     * @return The number of attestations.\\n     */\\n    function getReceivedAttestationUUIDsCount(address recipient, bytes32 schema)\\n        external\\n        view\\n        returns (uint256);\\n\\n    /**\\n     * @dev Returns all sent attestation UUIDs.\\n     *\\n     * @param attester The attesting account.\\n     * @param schema The UUID of the AS.\\n     * @param start The offset to start from.\\n     * @param length The number of total members to retrieve.\\n     * @param reverseOrder Whether the offset starts from the end and the data is returned in reverse.\\n     *\\n     * @return An array of attestation UUIDs.\\n     */\\n    function getSentAttestationUUIDs(\\n        address attester,\\n        bytes32 schema,\\n        uint256 start,\\n        uint256 length,\\n        bool reverseOrder\\n    ) external view returns (bytes32[] memory);\\n\\n    /**\\n     * @dev Returns the number of sent attestation UUIDs.\\n     *\\n     * @param recipient The recipient of the attestation.\\n     * @param schema The UUID of the AS.\\n     *\\n     * @return The number of attestations.\\n     */\\n    function getSentAttestationUUIDsCount(address recipient, bytes32 schema)\\n        external\\n        view\\n        returns (uint256);\\n\\n    /**\\n     * @dev Returns all attestations related to a specific attestation.\\n     *\\n     * @param uuid The UUID of the attestation to retrieve.\\n     * @param start The offset to start from.\\n     * @param length The number of total members to retrieve.\\n     * @param reverseOrder Whether the offset starts from the end and the data is returned in reverse.\\n     *\\n     * @return An array of attestation UUIDs.\\n     */\\n    function getRelatedAttestationUUIDs(\\n        bytes32 uuid,\\n        uint256 start,\\n        uint256 length,\\n        bool reverseOrder\\n    ) external view returns (bytes32[] memory);\\n\\n    /**\\n     * @dev Returns the number of related attestation UUIDs.\\n     *\\n     * @param uuid The UUID of the attestation to retrieve.\\n     *\\n     * @return The number of related attestations.\\n     */\\n    function getRelatedAttestationUUIDsCount(bytes32 uuid)\\n        external\\n        view\\n        returns (uint256);\\n\\n    /**\\n     * @dev Returns all per-schema attestation UUIDs.\\n     *\\n     * @param schema The UUID of the AS.\\n     * @param start The offset to start from.\\n     * @param length The number of total members to retrieve.\\n     * @param reverseOrder Whether the offset starts from the end and the data is returned in reverse.\\n     *\\n     * @return An array of attestation UUIDs.\\n     */\\n    function getSchemaAttestationUUIDs(\\n        bytes32 schema,\\n        uint256 start,\\n        uint256 length,\\n        bool reverseOrder\\n    ) external view returns (bytes32[] memory);\\n\\n    /**\\n     * @dev Returns the number of per-schema  attestation UUIDs.\\n     *\\n     * @param schema The UUID of the AS.\\n     *\\n     * @return The number of attestations.\\n     */\\n    function getSchemaAttestationUUIDsCount(bytes32 schema)\\n        external\\n        view\\n        returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IEASEIP712Verifier.sol\": {\r\n      \"content\": \"pragma solidity >=0.8.0 <0.9.0;\\n\\n// SPDX-License-Identifier: MIT\\n\\n/**\\n * @title EIP712 typed signatures verifier for EAS delegated attestations interface.\\n */\\ninterface IEASEIP712Verifier {\\n    /**\\n     * @dev Returns the current nonce per-account.\\n     *\\n     * @param account The requested accunt.\\n     *\\n     * @return The current nonce.\\n     */\\n    function getNonce(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Verifies signed attestation.\\n     *\\n     * @param recipient The recipient of the attestation.\\n     * @param schema The UUID of the AS.\\n     * @param expirationTime The expiration time of the attestation.\\n     * @param refUUID An optional related attestation's UUID.\\n     * @param data Additional custom data.\\n     * @param attester The attesting account.\\n     * @param v The recovery ID.\\n     * @param r The x-coordinate of the nonce R.\\n     * @param s The signature data.\\n     */\\n    function attest(\\n        address recipient,\\n        bytes32 schema,\\n        uint256 expirationTime,\\n        bytes32 refUUID,\\n        bytes calldata data,\\n        address attester,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external;\\n\\n    /**\\n     * @dev Verifies signed revocations.\\n     *\\n     * @param uuid The UUID of the attestation to revoke.\\n     * @param attester The attesting account.\\n     * @param v The recovery ID.\\n     * @param r The x-coordinate of the nonce R.\\n     * @param s The signature data.\\n     */\\n    function revoke(\\n        bytes32 uuid,\\n        address attester,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IMarketRegistry.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface IMarketRegistry {\\n    function isVerifiedLender(uint256 _marketId, address _lender)\\n        external\\n        returns (bool, bytes32);\\n\\n    function isMarketClosed(uint256 _marketId) external returns (bool);\\n\\n    function isVerifiedBorrower(uint256 _marketId, address _borrower)\\n        external\\n        returns (bool, bytes32);\\n\\n    function getMarketOwner(uint256 _marketId) external returns (address);\\n\\n    function getMarketURI(uint256 _marketId) external returns (string memory);\\n\\n    function getPaymentCycleDuration(uint256 _marketId)\\n        external\\n        returns (uint32);\\n\\n    function getPaymentDefaultDuration(uint256 _marketId)\\n        external\\n        returns (uint32);\\n\\n    function getBidExpirationTime(uint256 _marketId) external returns (uint32);\\n\\n    function getMarketplaceFee(uint256 _marketId) external returns (uint16);\\n}\\n\"\r\n    }\r\n  }\r\n}}","ABI":"[{\"inputs\":[],\"name\":\"NotPayable\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"marketId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"borrower\",\"type\":\"address\"}],\"name\":\"BorrowerAttestation\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"marketId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"borrower\",\"type\":\"address\"}],\"name\":\"BorrowerExitMarket\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"marketId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"borrower\",\"type\":\"address\"}],\"name\":\"BorrowerRevocation\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"marketId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"lender\",\"type\":\"address\"}],\"name\":\"LenderAttestation\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"marketId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"lender\",\"type\":\"address\"}],\"name\":\"LenderExitMarket\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"marketId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"lender\",\"type\":\"address\"}],\"name\":\"LenderRevocation\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"marketId\",\"type\":\"uint256\"}],\"name\":\"MarketClosed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"marketId\",\"type\":\"uint256\"}],\"name\":\"MarketCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"marketId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"duration\",\"type\":\"uint32\"}],\"name\":\"SetBidExpirationTime\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"marketId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint16\",\"name\":\"feePct\",\"type\":\"uint16\"}],\"name\":\"SetMarketFee\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"marketId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"uri\",\"type\":\"string\"}],\"name\":\"SetMarketURI\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"marketId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"duration\",\"type\":\"uint32\"}],\"name\":\"SetPaymentCycleDuration\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"marketId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"duration\",\"type\":\"uint32\"}],\"name\":\"SetPaymentDefaultDuration\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"CURRENT_CODE_VERSION\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_marketId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_borrowerAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_expirationTime\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"_v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"_r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"_s\",\"type\":\"bytes32\"}],\"name\":\"attestBorrower\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_marketId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_borrowerAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_expirationTime\",\"type\":\"uint256\"}],\"name\":\"attestBorrower\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_marketId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_lenderAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_expirationTime\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"_v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"_r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"_s\",\"type\":\"bytes32\"}],\"name\":\"attestLender\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_marketId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_lenderAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_expirationTime\",\"type\":\"uint256\"}],\"name\":\"attestLender\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"borrowerAttestationSchemaId\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_marketId\",\"type\":\"uint256\"}],\"name\":\"borrowerExitMarket\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_marketId\",\"type\":\"uint256\"}],\"name\":\"closeMarket\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_initialOwner\",\"type\":\"address\"},{\"internalType\":\"uint32\",\"name\":\"_paymentCycleDuration\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"_paymentDefaultDuration\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"_bidExpirationTime\",\"type\":\"uint32\"},{\"internalType\":\"uint16\",\"name\":\"_feePercent\",\"type\":\"uint16\"},{\"internalType\":\"bool\",\"name\":\"_requireLenderAttestation\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"_requireBorrowerAttestation\",\"type\":\"bool\"},{\"internalType\":\"string\",\"name\":\"_uri\",\"type\":\"string\"}],\"name\":\"createMarket\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_marketId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_page\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_perPage\",\"type\":\"uint256\"}],\"name\":\"getAllVerifiedBorrowersForMarket\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_marketId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_page\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_perPage\",\"type\":\"uint256\"}],\"name\":\"getAllVerifiedLendersForMarket\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"marketId\",\"type\":\"uint256\"}],\"name\":\"getBidExpirationTime\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_marketId\",\"type\":\"uint256\"}],\"name\":\"getMarketAttestationRequirements\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"lenderAttestationRequired\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"borrowerAttestationRequired\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_marketId\",\"type\":\"uint256\"}],\"name\":\"getMarketData\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"uint32\",\"name\":\"paymentCycleDuration\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"paymentDefaultDuration\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"loanExpirationTime\",\"type\":\"uint32\"},{\"internalType\":\"string\",\"name\":\"metadataURI\",\"type\":\"string\"},{\"internalType\":\"uint16\",\"name\":\"marketplaceFeePercent\",\"type\":\"uint16\"},{\"internalType\":\"bool\",\"name\":\"lenderAttestationRequired\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_marketId\",\"type\":\"uint256\"}],\"name\":\"getMarketOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_marketId\",\"type\":\"uint256\"}],\"name\":\"getMarketURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_marketId\",\"type\":\"uint256\"}],\"name\":\"getMarketplaceFee\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"fee\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_marketId\",\"type\":\"uint256\"}],\"name\":\"getPaymentCycleDuration\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_marketId\",\"type\":\"uint256\"}],\"name\":\"getPaymentDefaultDuration\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract TellerAS\",\"name\":\"_tellerAS\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_marketId\",\"type\":\"uint256\"}],\"name\":\"isMarketClosed\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isPayable\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_marketId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_borrowerAddress\",\"type\":\"address\"}],\"name\":\"isVerifiedBorrower\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"isVerified_\",\"type\":\"bool\"},{\"internalType\":\"bytes32\",\"name\":\"uuid_\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_marketId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_lenderAddress\",\"type\":\"address\"}],\"name\":\"isVerifiedLender\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"isVerified_\",\"type\":\"bool\"},{\"internalType\":\"bytes32\",\"name\":\"uuid_\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lenderAttestationSchemaId\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_marketId\",\"type\":\"uint256\"}],\"name\":\"lenderExitMarket\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"marketCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract TellerAS\",\"name\":\"_tellerAS\",\"type\":\"address\"}],\"name\":\"onUpgrade\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"schema\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"attestor\",\"type\":\"address\"}],\"name\":\"resolve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_marketId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_borrowerAddress\",\"type\":\"address\"}],\"name\":\"revokeBorrower\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_marketId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_borrowerAddress\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"_v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"_r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"_s\",\"type\":\"bytes32\"}],\"name\":\"revokeBorrower\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_marketId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_lenderAddress\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"_v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"_r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"_s\",\"type\":\"bytes32\"}],\"name\":\"revokeLender\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_marketId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_lenderAddress\",\"type\":\"address\"}],\"name\":\"revokeLender\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"marketId\",\"type\":\"uint256\"},{\"internalType\":\"uint32\",\"name\":\"duration\",\"type\":\"uint32\"}],\"name\":\"setBidExpirationTime\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_marketId\",\"type\":\"uint256\"},{\"internalType\":\"uint16\",\"name\":\"_newPercent\",\"type\":\"uint16\"}],\"name\":\"setMarketFeePercent\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_marketId\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"_uri\",\"type\":\"string\"}],\"name\":\"setMarketURI\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_marketId\",\"type\":\"uint256\"},{\"internalType\":\"uint32\",\"name\":\"_duration\",\"type\":\"uint32\"}],\"name\":\"setPaymentCycleDuration\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_marketId\",\"type\":\"uint256\"},{\"internalType\":\"uint32\",\"name\":\"_duration\",\"type\":\"uint32\"}],\"name\":\"setPaymentDefaultDuration\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tellerAS\",\"outputs\":[{\"internalType\":\"contract TellerAS\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_marketId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferMarketOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"version\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]","ContractName":"MarketRegistry","CompilerVersion":"v0.8.9+commit.e5eed63a","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":""}]}