{"status":"1","message":"OK","result":[{"SourceCode":"//SPDX-License-Identifier: MIT\r\n// Copy from: https://github.com/0age/metamorphic/blob/master/contracts/MetamorphicContractFactory.sol\r\n// Edited by devysq@gmail.com\r\npragma solidity 0.5.12;\r\n\r\n/**\r\n * @title Immutable Create2 Contract Factory\r\n * @author 0age & ysqi\r\n * @notice This contract provides a safeCreate2 function that takes a salt value\r\n * and a block of initialization code as arguments and passes them into inline\r\n * assembly. The contract prevents redeploys by maintaining a mapping of all\r\n * contracts that have already been deployed, and prevents frontrunning or other\r\n * collisions by requiring that the first 20 bytes of the salt are equal to the\r\n * address of the caller (this can be bypassed by setting the first 20 bytes to\r\n * the null address). There is also a view function that computes the address of\r\n * the contract that will be created when submitting a given salt or nonce along\r\n * with a given block of initialization code.\r\n * @dev This contract has not yet been fully tested or audited - proceed with\r\n * caution and please share any exploits or optimizations you discover.\r\n */\r\ncontract LastCreate2Factory {\r\n    // a new contract deployed event\r\n    event Deployed(address addr, bytes32 salt);\r\n\r\n    // mapping to track which addresses have already been deployed.\r\n    mapping(address => bool) public deployed;\r\n\r\n    /**\r\n     * @notice create\r\n     * @dev Create a contract using CREATE2 by submitting a given salt or nonce\r\n     * along with the initialization code for the contract. Note that the first 20\r\n     * bytes of the salt must match those of the calling address, which prevents\r\n     * contract creation events from being submitted by unintended parties.\r\n     * @param salt bytes32 The nonce that will be passed into the CREATE2 call.\r\n     * @param initializationCode bytes The initialization code that will be passed\r\n     * into the CREATE2 call.\r\n     * @param callData If callData is not empty, the new contract will be called\r\n     * with callData after the contract is created successfully.\r\n     * You can use it to initialize contracts, transfer management roles, or otherwise.\r\n     * @return deploymentAddress is Address of the contract that will be created, or the null address\r\n     * if a contract already exists at that address.\r\n     */\r\n    function safeCreate2(\r\n        bytes32 salt,\r\n        bytes calldata initializationCode,\r\n        bytes calldata callData\r\n    ) external returns (address deploymentAddress) {\r\n        // prevent contract submissions from being stolen from tx.pool by requiring\r\n        // that the first 20 bytes of the submitted salt match msg.sender.\r\n        require(\r\n            (bytes20(salt) == bytes20(0)) ||\r\n                (address(bytes20(salt)) == msg.sender),\r\n            \"E1\" // - first 20 bytes of the salt must match calling address.\r\n        );\r\n\r\n        // determine the target address for contract deployment.\r\n        address targetDeploymentAddress = _create2Address(\r\n            salt,\r\n            keccak256(abi.encodePacked(initializationCode))\r\n        );\r\n\r\n        // ensure that a contract hasn't been previously deployed to target address.\r\n        require(!deployed[targetDeploymentAddress], \"E2\");\r\n\r\n        // move the initialization code from calldata to memory.\r\n        bytes memory initCode = initializationCode;\r\n\r\n        // using inline assembly: load data and length of data, then call CREATE2.\r\n        assembly {\r\n            // solhint-disable-line\r\n            deploymentAddress := create2(\r\n                callvalue(), // forward any attached value.\r\n                add(0x20, initCode), // pass in initialization code.\r\n                mload(initCode), // pass in init code's length.\r\n                salt // pass in the salt value.\r\n            )\r\n            if iszero(extcodesize(deploymentAddress)) {\r\n                revert(0, 0)\r\n            }\r\n        }\r\n\r\n        // check address against target to ensure that deployment was successful.\r\n        require(deploymentAddress == targetDeploymentAddress, \"E3\");\r\n\r\n        // record the deployment of the contract to prevent redeploys.\r\n        deployed[deploymentAddress] = true;\r\n\r\n        // call contract after created\r\n        if (callData.length > 0) {\r\n            (bool success, ) = deploymentAddress.call(callData);\r\n            require(success, \"E4\");\r\n        }\r\n\r\n        emit Deployed(deploymentAddress, salt);\r\n    }\r\n\r\n    /**\r\n     * @dev Compute the address of the contract that will be created when\r\n     * submitting a given salt or nonce to the contract along with the contract's\r\n     * initialization code. The CREATE2 address is computed in accordance with\r\n     * EIP-1014, and adheres to the formula therein of\r\n     * `keccak256( 0xff ++ address ++ salt ++ keccak256(init_code)))[12:]` when\r\n     * performing the computation. The computed address is then checked for any\r\n     * existing contract code - if so, the null address will be returned instead.\r\n     * @param salt bytes32 The nonce passed into the CREATE2 address calculation.\r\n     * @param initCode bytes The contract initialization code to be used.\r\n     * that will be passed into the CREATE2 address calculation.\r\n     * @return deploymentAddress is Address of the contract that will be created, or the null address\r\n     * if a contract has already been deployed to that address.\r\n     */\r\n    function findCreate2Address(bytes32 salt, bytes calldata initCode)\r\n        external\r\n        view\r\n        returns (address deploymentAddress)\r\n    {\r\n        // determine the address where the contract will be deployed.\r\n        deploymentAddress = _create2Address(\r\n            salt,\r\n            keccak256(abi.encodePacked(initCode))\r\n        );\r\n\r\n        // return null address to signify failure if contract has been deployed.\r\n        if (deployed[deploymentAddress]) {\r\n            return address(0);\r\n        }\r\n    }\r\n\r\n    // determine the target address for contract deployment.\r\n    function _create2Address(bytes32 salt, bytes32 initCodeHash)\r\n        private\r\n        view\r\n        returns (address)\r\n    {\r\n        return\r\n            address(\r\n                uint160( // downcast to match the address type.\r\n                    uint256( // convert to uint to truncate upper digits.\r\n                        keccak256( // compute the CREATE2 hash using 4 inputs.\r\n                            abi.encodePacked( // pack all inputs to the hash together.\r\n                                hex\"ff\", // start with 0xff to distinguish from RLP.\r\n                                address(this), // this contract will be the caller.\r\n                                salt, // pass in the supplied salt value.\r\n                                initCodeHash // pass in the hash of initialization code.\r\n                            )\r\n                        )\r\n                    )\r\n                )\r\n            );\r\n    }\r\n}","ABI":"[{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"salt\",\"type\":\"bytes32\"}],\"name\":\"Deployed\",\"type\":\"event\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"deployed\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"salt\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"initCode\",\"type\":\"bytes\"}],\"name\":\"findCreate2Address\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"deploymentAddress\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"salt\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"initializationCode\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"callData\",\"type\":\"bytes\"}],\"name\":\"safeCreate2\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"deploymentAddress\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"LastCreate2Factory","CompilerVersion":"v0.5.12+commit.7709ece9","OptimizationUsed":"1","Runs":"99999","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"bzzr://daceebb60b80dca77cc18d9120921ff6fab5e3cb54a009370727c6d8e23caafb"}]}