{"status":"1","message":"OK","result":[{"SourceCode":"// SPDX-License-Identifier: MIT\r\n// Sources flattened with hardhat v2.9.3 https://hardhat.org\r\n\r\n// File contracts/lib/interfaces/MarketTokenInterface.sol\r\n\r\n\r\npragma solidity ^0.8.0;\r\n\r\ninterface MarketTokenInterface {\r\n    function isMarketToken() external view returns (bool);\r\n    function name() external view returns (string memory);\r\n    function symbol() external view returns (string memory);\r\n    function decimals() external view returns (uint8);\r\n    function totalSupply() external view returns (uint256);\r\n    function underlying() external view returns (address);\r\n    function reserveFactorMantissa() external view returns (uint256);\r\n    function accrualBlockTimestamp() external view returns (uint256);\r\n    function borrowIndex() external view returns (uint256);\r\n    function totalBorrows() external view returns (uint256);\r\n    function totalReserves() external view returns (uint256);\r\n    function accountTokens(address account) external view returns (uint256);\r\n    function accountBorrows(address account) external view returns (uint256,uint256);\r\n    function protocolSeizeShareMantissa() external view returns (uint256);\r\n    function comptroller() external view returns (address);\r\n    function interestRateModel() external view returns (address);\r\n\r\n    function transfer(address dst, uint amount) external returns (bool);\r\n    function transferFrom(address src, address dst, uint amount) external returns (bool);\r\n    function approve(address spender, uint amount) external returns (bool);\r\n    function allowance(address owner, address spender) external view returns (uint);\r\n    function balanceOf(address owner) external view returns (uint);\r\n    function balanceOfUnderlying(address owner) external returns (uint);\r\n    function getAccountSnapshot(address account) external view returns (uint, uint, uint, uint);\r\n    function borrowRatePerSecond() external view returns (uint);\r\n    function supplyRatePerSecond() external view returns (uint);\r\n    function totalBorrowsCurrent() external returns (uint);\r\n    function borrowBalanceCurrent(address account) external returns (uint);\r\n    function borrowBalanceStored(address account) external view returns (uint);\r\n    function exchangeRateCurrent() external returns (uint);\r\n    function exchangeRateStored() external view returns (uint);\r\n    function getCash() external view returns (uint);\r\n    function accrueInterest() external returns (uint);\r\n    function seize(address liquidator, address borrower, uint seizeTokens) external returns (uint);\r\n\r\n    function _setComptroller(address newComptroller) external returns (uint);\r\n    function _setReserveFactor(uint newReserveFactorMantissa) external  returns (uint);\r\n    function _reduceReserves(uint reduceAmount) external  returns (uint);\r\n    function _setInterestRateModel(address newInterestRateModel) external  returns (uint);\r\n\r\n\r\n\r\n    \r\n}\r\n\r\ninterface MarketTokenEtherInterface is MarketTokenInterface{\r\n\r\n    function mint() external payable;\r\n    function redeem(uint redeemTokens) external returns (uint);\r\n    function redeemUnderlying(uint redeemAmount) external returns (uint);\r\n    function borrow(uint borrowAmount) external returns (uint);\r\n    function repayBorrow() external payable;\r\n    function repayBorrowBehalf(address borrower) external payable;\r\n    function liquidateBorrow(address borrower, address marketTokenCollateral) external payable;\r\n\r\n    function _addReserves() external payable returns (uint);\r\n\r\n}\r\n\r\ninterface MarketTokenERC20Interface is MarketTokenInterface{\r\n\r\n    function mint(uint mintAmount) external returns (uint);\r\n    function redeem(uint redeemTokens) external returns (uint);\r\n    function redeemUnderlying(uint redeemAmount) external returns (uint);\r\n    function borrow(uint borrowAmount) external returns (uint);\r\n    function repayBorrow(uint repayAmount) external returns (uint);\r\n    function repayBorrowBehalf(address borrower, uint repayAmount) external returns (uint);\r\n    function liquidateBorrow(address borrower, uint repayAmount, address marketTokenCollateral) external returns (uint);\r\n    function sweepToken(address token) external ;\r\n\r\n    function _addReserves(uint addAmount) external returns (uint);\r\n\r\n}\r\n\r\n\r\n// File contracts/lib/interfaces/PriceOracle.sol\r\n\r\n\r\npragma solidity ^0.8.0;\r\n\r\ninterface PriceOracle {\r\n    /**\r\n      * @notice Get the underlying price of a marketToken asset\r\n      * @param marketToken The marketToken to get the underlying price of\r\n      * @return The underlying asset price mantissa (scaled by 1e(36-decimals)).\r\n      *  Zero means the price is unavailable.\r\n      */\r\n    function getUnderlyingPrice(MarketTokenInterface marketToken) external view returns (uint);\r\n}\r\n\r\n\r\ninterface PriceSource {\r\n    /**\r\n     * @notice Get the price of an token asset.\r\n     * @param token The token asset to get the price of.\r\n     * @return The token asset price in USD as a mantissa (scaled by 1e8).\r\n    */\r\n    function getPrice(address token) external view returns (uint);\r\n}\r\n\r\n\r\n// File contracts/lib/interfaces/DistributionerInterface.sol\r\n\r\n\r\npragma solidity ^0.8.0;\r\n\r\ninterface DistributionerInterface {\r\n\r\n    function _initializeMarket(address marketToken) external;\r\n\r\n    function distributeMintReward(address marketToken, address minter) external;\r\n    function distributeRedeemReward(address marketToken, address redeemer) external;\r\n    function distributeBorrowReward(address marketToken, address borrower) external;\r\n    function distributeRepayBorrowReward(address marketToken, address borrower) external;\r\n    function distributeSeizeReward(address marketTokenCollateral, address borrower, address liquidator) external;\r\n    function distributeTransferReward(address marketToken, address src, address dst) external;\r\n\r\n    function rewardSupplySpeeds(address marketToken) external view returns(uint);\r\n    function rewardBorrowSpeeds(address marketToken) external view returns(uint);\r\n    function rewardAccrued(address account) external view returns(uint);\r\n    function rewardToken() external view returns(address);\r\n\r\n    function claimRewardToken(address holder) external;\r\n    function claimRewardToken(address holder, address[] memory marketTokens) external;\r\n    function claimRewardToken(address[] memory holders, address[] memory marketTokens, bool borrowers, bool suppliers) external;\r\n\r\n\r\n}\r\n\r\ninterface DistributionerManagerInterface {\r\n    function getDistributioners() external view returns(address[] memory);\r\n}\r\n\r\n\r\n// File contracts/lib/ExponentialNoError.sol\r\n\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @title Exponential module for storing fixed-precision decimals\r\n * @author Compound\r\n * @notice Exp is a struct which stores decimals with a fixed precision of 18 decimal places.\r\n *         Thus, if we wanted to store the 5.1, mantissa would store 5.1e18. That is:\r\n *         `Exp({mantissa: 5100000000000000000})`.\r\n */\r\ncontract ExponentialNoError {\r\n    uint constant expScale = 1e18;\r\n    uint constant doubleScale = 1e36;\r\n    uint constant halfExpScale = expScale/2;\r\n    uint constant mantissaOne = expScale;\r\n\r\n    struct Exp {\r\n        uint mantissa;\r\n    }\r\n\r\n    struct Double {\r\n        uint mantissa;\r\n    }\r\n\r\n    /**\r\n     * @dev Truncates the given exp to a whole number value.\r\n     *      For example, truncate(Exp{mantissa: 15 * expScale}) = 15\r\n     */\r\n    function truncate(Exp memory exp) pure internal returns (uint) {\r\n        // Note: We are not using careful math here as we're performing a division that cannot fail\r\n        return exp.mantissa / expScale;\r\n    }\r\n\r\n    /**\r\n     * @dev Multiply an Exp by a scalar, then truncate to return an unsigned integer.\r\n     */\r\n    function mul_ScalarTruncate(Exp memory a, uint scalar) pure internal returns (uint) {\r\n        Exp memory product = mul_(a, scalar);\r\n        return truncate(product);\r\n    }\r\n\r\n    /**\r\n     * @dev Multiply an Exp by a scalar, truncate, then add an to an unsigned integer, returning an unsigned integer.\r\n     */\r\n    function mul_ScalarTruncateAddUInt(Exp memory a, uint scalar, uint addend) pure internal returns (uint) {\r\n        Exp memory product = mul_(a, scalar);\r\n        return add_(truncate(product), addend);\r\n    }\r\n\r\n    /**\r\n     * @dev Checks if first Exp is less than second Exp.\r\n     */\r\n    function lessThanExp(Exp memory left, Exp memory right) pure internal returns (bool) {\r\n        return left.mantissa < right.mantissa;\r\n    }\r\n\r\n    /**\r\n     * @dev Checks if left Exp <= right Exp.\r\n     */\r\n    function lessThanOrEqualExp(Exp memory left, Exp memory right) pure internal returns (bool) {\r\n        return left.mantissa <= right.mantissa;\r\n    }\r\n\r\n    /**\r\n     * @dev Checks if left Exp > right Exp.\r\n     */\r\n    function greaterThanExp(Exp memory left, Exp memory right) pure internal returns (bool) {\r\n        return left.mantissa > right.mantissa;\r\n    }\r\n\r\n    /**\r\n     * @dev returns true if Exp is exactly zero\r\n     */\r\n    function isZeroExp(Exp memory value) pure internal returns (bool) {\r\n        return value.mantissa == 0;\r\n    }\r\n\r\n    function safe224(uint n, string memory errorMessage) pure internal returns (uint224) {\r\n        require(n < 2**224, errorMessage);\r\n        return uint224(n);\r\n    }\r\n\r\n    function safe32(uint n, string memory errorMessage) pure internal returns (uint32) {\r\n        require(n < 2**32, errorMessage);\r\n        return uint32(n);\r\n    }\r\n\r\n    function add_(Exp memory a, Exp memory b) pure internal returns (Exp memory) {\r\n        return Exp({mantissa: add_(a.mantissa, b.mantissa)});\r\n    }\r\n\r\n    function add_(Double memory a, Double memory b) pure internal returns (Double memory) {\r\n        return Double({mantissa: add_(a.mantissa, b.mantissa)});\r\n    }\r\n\r\n    function add_(uint a, uint b) pure internal returns (uint) {\r\n        return add_(a, b, \"addition overflow\");\r\n    }\r\n\r\n    function add_(uint a, uint b, string memory errorMessage) pure internal returns (uint) {\r\n        uint c = a + b;\r\n        require(c >= a, errorMessage);\r\n        return c;\r\n    }\r\n\r\n    function sub_(Exp memory a, Exp memory b) pure internal returns (Exp memory) {\r\n        return Exp({mantissa: sub_(a.mantissa, b.mantissa)});\r\n    }\r\n\r\n    function sub_(Double memory a, Double memory b) pure internal returns (Double memory) {\r\n        return Double({mantissa: sub_(a.mantissa, b.mantissa)});\r\n    }\r\n\r\n    function sub_(uint a, uint b) pure internal returns (uint) {\r\n        return sub_(a, b, \"subtraction underflow\");\r\n    }\r\n\r\n    function sub_(uint a, uint b, string memory errorMessage) pure internal returns (uint) {\r\n        require(b <= a, errorMessage);\r\n        return a - b;\r\n    }\r\n\r\n    function mul_(Exp memory a, Exp memory b) pure internal returns (Exp memory) {\r\n        return Exp({mantissa: mul_(a.mantissa, b.mantissa) / expScale});\r\n    }\r\n\r\n    function mul_(Exp memory a, uint b) pure internal returns (Exp memory) {\r\n        return Exp({mantissa: mul_(a.mantissa, b)});\r\n    }\r\n\r\n    function mul_(uint a, Exp memory b) pure internal returns (uint) {\r\n        return mul_(a, b.mantissa) / expScale;\r\n    }\r\n\r\n    function mul_(Double memory a, Double memory b) pure internal returns (Double memory) {\r\n        return Double({mantissa: mul_(a.mantissa, b.mantissa) / doubleScale});\r\n    }\r\n\r\n    function mul_(Double memory a, uint b) pure internal returns (Double memory) {\r\n        return Double({mantissa: mul_(a.mantissa, b)});\r\n    }\r\n\r\n    function mul_(uint a, Double memory b) pure internal returns (uint) {\r\n        return mul_(a, b.mantissa) / doubleScale;\r\n    }\r\n\r\n    function mul_(uint a, uint b) pure internal returns (uint) {\r\n        return mul_(a, b, \"multiplication overflow\");\r\n    }\r\n\r\n    function mul_(uint a, uint b, string memory errorMessage) pure internal returns (uint) {\r\n        if (a == 0 || b == 0) {\r\n            return 0;\r\n        }\r\n        uint c = a * b;\r\n        require(c / a == b, errorMessage);\r\n        return c;\r\n    }\r\n\r\n    function div_(Exp memory a, Exp memory b) pure internal returns (Exp memory) {\r\n        return Exp({mantissa: div_(mul_(a.mantissa, expScale), b.mantissa)});\r\n    }\r\n\r\n    function div_(Exp memory a, uint b) pure internal returns (Exp memory) {\r\n        return Exp({mantissa: div_(a.mantissa, b)});\r\n    }\r\n\r\n    function div_(uint a, Exp memory b) pure internal returns (uint) {\r\n        return div_(mul_(a, expScale), b.mantissa);\r\n    }\r\n\r\n    function div_(Double memory a, Double memory b) pure internal returns (Double memory) {\r\n        return Double({mantissa: div_(mul_(a.mantissa, doubleScale), b.mantissa)});\r\n    }\r\n\r\n    function div_(Double memory a, uint b) pure internal returns (Double memory) {\r\n        return Double({mantissa: div_(a.mantissa, b)});\r\n    }\r\n\r\n    function div_(uint a, Double memory b) pure internal returns (uint) {\r\n        return div_(mul_(a, doubleScale), b.mantissa);\r\n    }\r\n\r\n    function div_(uint a, uint b) pure internal returns (uint) {\r\n        return div_(a, b, \"divide by zero\");\r\n    }\r\n\r\n    function div_(uint a, uint b, string memory errorMessage) pure internal returns (uint) {\r\n        require(b > 0, errorMessage);\r\n        return a / b;\r\n    }\r\n\r\n    function fraction(uint a, uint b) pure internal returns (Double memory) {\r\n        return Double({mantissa: div_(mul_(a, doubleScale), b)});\r\n    }\r\n}\r\n\r\n\r\n// File contracts/lib/ErrorReporter.sol\r\n\r\n\r\npragma solidity ^0.8.0;\r\n\r\ncontract ComptrollerErrorReporter {\r\n\r\n  uint public constant NO_ERROR = 0; // support legacy return codes\r\n\r\n  error Unauthorized();\r\n  error ComptrollerMismatch();\r\n  error InsufficientShortfall();\r\n  error InsufficientLiquidity(); \r\n  error InvalidCloseFactor();\r\n  error InvalidCollateralFactor();\r\n  error MarketNotEntered();\r\n  error MarketNotListed();\r\n  error MarketAlreadyListed();\r\n  error NonzeroBorrowBalance();\r\n  error PriceError();\r\n  error Rejection();\r\n  error SnapshotError();\r\n  error TooManyAssets();\r\n  error TooMuchRepay();\r\n\r\n  error ExitMarketBalanceOwed();\r\n  error ExitMarketRejection();\r\n  error SetCloseFactorOwnerCheck();\r\n  error SetCloseFactorValidation();\r\n  error SetCollateralFactorOwnerCheck();\r\n  error SetCollateralFactorNoExists();\r\n  error SetCollateralFactorValidation();\r\n  error SetCollateralFactorWithoutPrice();\r\n  error SetLiquidationIncentiveOwnerCheck();\r\n  error SetLiquidationIncentiveValidation();\r\n  error SetMaxAssetsOwnerCheck();\r\n  error SetPriceOracleOwnerCheck();\r\n  error SupportMarketExists();\r\n  error SupportMarketOwnerCheck();\r\n  error SetPauseGuarianOwnerCheck();\r\n\r\n}\r\n\r\ncontract TokenErrorReporter {\r\n\r\n  uint public constant NO_ERROR = 0; // support legacy return codes\r\n\r\n  error TransferComptrollerRejection(uint256 errorCode);\r\n  error TransferNotAllowed();\r\n  error TransferNotEnough();\r\n  error TransferTooMuch();\r\n\r\n  error ExchangeRateReadFailed(uint errorCode);\r\n\r\n  error MintComptrollerRejection(uint256 errorCode);\r\n  error MintFreshnessCheck();\r\n  \r\n  error RedeemExchangeTokenCalculationFailed(uint256 errorCode);\r\n  error RedeemExchangeAmountCalculationFailed(uint256 errorCode);\r\n  error RedeemComptrollerRejection(uint256 errorCode);\r\n  error RedeemFreshnessCheck();\r\n  error RedeemTransferOutNotPossible();\r\n\r\n  error BorrowComptrollerRejection(uint256 errorCode);\r\n  error BorrowFreshnessCheck();\r\n  error BorrowCashNotAvailable();\r\n\r\n  error RepayBorrowComptrollerRejection(uint256 errorCode);\r\n  error RepayBorrowFreshnessCheck();\r\n\r\n  error LiquidateComptrollerRejection(uint256 errorCode);\r\n  error LiquidateFreshnessCheck();\r\n  error LiquidateCollateralFreshnessCheck();\r\n  error LiquidateAccrueBorrowInterestFailed(uint256 errorCode);\r\n  error LiquidateAccrueCollateralInterestFailed(uint256 errorCode);\r\n  error LiquidateLiquidatorIsBorrower();\r\n  error LiquidateCloseAmountIsZero();\r\n  error LiquidateCloseAmountIsUintMax();\r\n  error LiquidateRepayBorrowFreshFailed(uint256 errorCode);\r\n\r\n  error LiquidateSeizeComptrollerRejection(uint256 errorCode);\r\n  error LiquidateSeizeLiquidatorIsBorrower();\r\n\r\n  error AcceptAdminPendingAdminCheck();\r\n\r\n  error SetComptrollerOwnerCheck();\r\n  error SetPendingAdminOwnerCheck();\r\n\r\n  error SetReserveFactorAdminCheck();\r\n  error SetReserveFactorFreshCheck();\r\n  error SetReserveFactorBoundsCheck();\r\n\r\n  error AddReservesFactorFreshCheck(uint256 actualAddAmount);\r\n\r\n  error ReduceReservesAdminCheck();\r\n  error ReduceReservesFreshCheck();\r\n  error ReduceReservesCashNotAvailable();\r\n  error ReduceReservesCashValidation();\r\n\r\n  error SetInterestRateModelOwnerCheck();\r\n  error SetInterestRateModelFreshCheck();\r\n\r\n\r\n}\r\n\r\n\r\n// File @openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol@v4.5.2\r\n\r\n\r\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/Address.sol)\r\n\r\npragma solidity ^0.8.1;\r\n\r\n/**\r\n * @dev Collection of functions related to the address type\r\n */\r\nlibrary AddressUpgradeable {\r\n    /**\r\n     * @dev Returns true if `account` is a contract.\r\n     *\r\n     * [IMPORTANT]\r\n     * ====\r\n     * It is unsafe to assume that an address for which this function returns\r\n     * false is an externally-owned account (EOA) and not a contract.\r\n     *\r\n     * Among others, `isContract` will return false for the following\r\n     * types of addresses:\r\n     *\r\n     *  - an externally-owned account\r\n     *  - a contract in construction\r\n     *  - an address where a contract will be created\r\n     *  - an address where a contract lived, but was destroyed\r\n     * ====\r\n     *\r\n     * [IMPORTANT]\r\n     * ====\r\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\r\n     *\r\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\r\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\r\n     * constructor.\r\n     * ====\r\n     */\r\n    function isContract(address account) internal view returns (bool) {\r\n        // This method relies on extcodesize/address.code.length, which returns 0\r\n        // for contracts in construction, since the code is only stored at the end\r\n        // of the constructor execution.\r\n\r\n        return account.code.length > 0;\r\n    }\r\n\r\n    /**\r\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\r\n     * `recipient`, forwarding all available gas and reverting on errors.\r\n     *\r\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\r\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\r\n     * imposed by `transfer`, making them unable to receive funds via\r\n     * `transfer`. {sendValue} removes this limitation.\r\n     *\r\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\r\n     *\r\n     * IMPORTANT: because control is transferred to `recipient`, care must be\r\n     * taken to not create reentrancy vulnerabilities. Consider using\r\n     * {ReentrancyGuard} or the\r\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\r\n     */\r\n    function sendValue(address payable recipient, uint256 amount) internal {\r\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\r\n\r\n        (bool success, ) = recipient.call{value: amount}(\"\");\r\n        require(success, \"Address: unable to send value, recipient may have reverted\");\r\n    }\r\n\r\n    /**\r\n     * @dev Performs a Solidity function call using a low level `call`. A\r\n     * plain `call` is an unsafe replacement for a function call: use this\r\n     * function instead.\r\n     *\r\n     * If `target` reverts with a revert reason, it is bubbled up by this\r\n     * function (like regular Solidity function calls).\r\n     *\r\n     * Returns the raw returned data. To convert to the expected return value,\r\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `target` must be a contract.\r\n     * - calling `target` with `data` must not revert.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\r\n        return functionCall(target, data, \"Address: low-level call failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\r\n     * `errorMessage` as a fallback revert reason when `target` reverts.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCall(\r\n        address target,\r\n        bytes memory data,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, 0, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but also transferring `value` wei to `target`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - the calling contract must have an ETH balance of at least `value`.\r\n     * - the called Solidity function must be `payable`.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCallWithValue(\r\n        address target,\r\n        bytes memory data,\r\n        uint256 value\r\n    ) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\r\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCallWithValue(\r\n        address target,\r\n        bytes memory data,\r\n        uint256 value,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\r\n        require(isContract(target), \"Address: call to non-contract\");\r\n\r\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\r\n        return verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but performing a static call.\r\n     *\r\n     * _Available since v3.3._\r\n     */\r\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\r\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\r\n     * but performing a static call.\r\n     *\r\n     * _Available since v3.3._\r\n     */\r\n    function functionStaticCall(\r\n        address target,\r\n        bytes memory data,\r\n        string memory errorMessage\r\n    ) internal view returns (bytes memory) {\r\n        require(isContract(target), \"Address: static call to non-contract\");\r\n\r\n        (bool success, bytes memory returndata) = target.staticcall(data);\r\n        return verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\r\n     * revert reason using the provided one.\r\n     *\r\n     * _Available since v4.3._\r\n     */\r\n    function verifyCallResult(\r\n        bool success,\r\n        bytes memory returndata,\r\n        string memory errorMessage\r\n    ) internal pure returns (bytes memory) {\r\n        if (success) {\r\n            return returndata;\r\n        } else {\r\n            // Look for revert reason and bubble it up if present\r\n            if (returndata.length > 0) {\r\n                // The easiest way to bubble the revert reason is using memory via assembly\r\n\r\n                assembly {\r\n                    let returndata_size := mload(returndata)\r\n                    revert(add(32, returndata), returndata_size)\r\n                }\r\n            } else {\r\n                revert(errorMessage);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n\r\n// File @openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol@v4.5.2\r\n\r\n\r\n// OpenZeppelin Contracts (last updated v4.5.0) (proxy/utils/Initializable.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\r\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\r\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\r\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\r\n *\r\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\r\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\r\n *\r\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\r\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\r\n *\r\n * [CAUTION]\r\n * ====\r\n * Avoid leaving a contract uninitialized.\r\n *\r\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\r\n * contract, which may impact the proxy. To initialize the implementation contract, you can either invoke the\r\n * initializer manually, or you can include a constructor to automatically mark it as initialized when it is deployed:\r\n *\r\n * [.hljs-theme-light.nopadding]\r\n * ```\r\n * /// @custom:oz-upgrades-unsafe-allow constructor\r\n * constructor() initializer {}\r\n * ```\r\n * ====\r\n */\r\nabstract contract Initializable {\r\n    /**\r\n     * @dev Indicates that the contract has been initialized.\r\n     */\r\n    bool private _initialized;\r\n\r\n    /**\r\n     * @dev Indicates that the contract is in the process of being initialized.\r\n     */\r\n    bool private _initializing;\r\n\r\n    /**\r\n     * @dev Modifier to protect an initializer function from being invoked twice.\r\n     */\r\n    modifier initializer() {\r\n        // If the contract is initializing we ignore whether _initialized is set in order to support multiple\r\n        // inheritance patterns, but we only do this in the context of a constructor, because in other contexts the\r\n        // contract may have been reentered.\r\n        require(_initializing ? _isConstructor() : !_initialized, \"Initializable: contract is already initialized\");\r\n\r\n        bool isTopLevelCall = !_initializing;\r\n        if (isTopLevelCall) {\r\n            _initializing = true;\r\n            _initialized = true;\r\n        }\r\n\r\n        _;\r\n\r\n        if (isTopLevelCall) {\r\n            _initializing = false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\r\n     * {initializer} modifier, directly or indirectly.\r\n     */\r\n    modifier onlyInitializing() {\r\n        require(_initializing, \"Initializable: contract is not initializing\");\r\n        _;\r\n    }\r\n\r\n    function _isConstructor() private view returns (bool) {\r\n        return !AddressUpgradeable.isContract(address(this));\r\n    }\r\n}\r\n\r\n\r\n// File @openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol@v4.5.2\r\n\r\n\r\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n */\r\nabstract contract ContextUpgradeable is Initializable {\r\n    function __Context_init() internal onlyInitializing {\r\n    }\r\n\r\n    function __Context_init_unchained() internal onlyInitializing {\r\n    }\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes calldata) {\r\n        return msg.data;\r\n    }\r\n\r\n    /**\r\n     * @dev This empty reserved space is put in place to allow future versions to add new\r\n     * variables without shifting down storage in the inheritance chain.\r\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\r\n     */\r\n    uint256[50] private __gap;\r\n}\r\n\r\n\r\n// File @openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol@v4.5.2\r\n\r\n\r\n// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * By default, the owner account will be the one that deploys the contract. This\r\n * can later be changed with {transferOwnership}.\r\n *\r\n * This module is used through inheritance. It will make available the modifier\r\n * `onlyOwner`, which can be applied to your functions to restrict their use to\r\n * the owner.\r\n */\r\nabstract contract OwnableUpgradeable is Initializable, ContextUpgradeable {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    function __Ownable_init() internal onlyInitializing {\r\n        __Ownable_init_unchained();\r\n    }\r\n\r\n    function __Ownable_init_unchained() internal onlyInitializing {\r\n        _transferOwnership(_msgSender());\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view virtual returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Leaves the contract without owner. It will not be possible to call\r\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\r\n     *\r\n     * NOTE: Renouncing ownership will leave the contract without an owner,\r\n     * thereby removing any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        _transferOwnership(address(0));\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Internal function without access restriction.\r\n     */\r\n    function _transferOwnership(address newOwner) internal virtual {\r\n        address oldOwner = _owner;\r\n        _owner = newOwner;\r\n        emit OwnershipTransferred(oldOwner, newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev This empty reserved space is put in place to allow future versions to add new\r\n     * variables without shifting down storage in the inheritance chain.\r\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\r\n     */\r\n    uint256[49] private __gap;\r\n}\r\n\r\n\r\n// File contracts/comptroller/AbstractComptroller.sol\r\n\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\n\r\n\r\n\r\n\r\nabstract contract AbstractComptroller is ComptrollerErrorReporter, ExponentialNoError, OwnableUpgradeable{\r\n\r\n    bool public constant isComptroller = true;\r\n\r\n    /**\r\n     * @notice Oracle which gives the price of any given asset\r\n     */\r\n    PriceOracle public oracle;\r\n\r\n    /**\r\n     * @notice distribution the reward token\r\n     */\r\n    DistributionerInterface public distributioner;\r\n\r\n    /**\r\n     * @notice Multiplier used to calculate the maximum repayAmount when liquidating a borrow\r\n     */\r\n    uint public closeFactorMantissa;\r\n\r\n    /**\r\n     * @notice Multiplier representing the discount on collateral that a liquidator receives\r\n     */\r\n    uint public liquidationIncentiveMantissa;\r\n\r\n    /**\r\n     * @notice Per-account mapping of \"assets you are in\"\r\n     */\r\n    mapping(address => MarketTokenInterface[]) public accountAssets;\r\n\r\n    /**\r\n     * @notice A list of all markets\r\n     */\r\n    MarketTokenInterface[] public allMarkets;\r\n\r\n    struct Market {\r\n        /**\r\n         * @notice Whether or not this market is listed\r\n         */\r\n        bool isListed;\r\n\r\n        /**\r\n         * @notice Multiplier representing the most one can borrow against their collateral in this market.\r\n         *  For instance, 0.9 to allow borrowing 90% of collateral value.\r\n         *  Must be between 0 and 1, and stored as a mantissa.\r\n         */\r\n        uint collateralFactorMantissa;\r\n\r\n        /**\r\n         * @notice Per-market mapping of \"accounts in this asset\"\r\n         */\r\n        mapping(address => bool) accountMembership;\r\n\r\n    }\r\n\r\n    /**\r\n     * @notice Official mapping of pTokens -> Market metadata\r\n     * @dev Used e.g. to determine if a market is supported\r\n     */\r\n    mapping(address => Market) public markets;\r\n\r\n    /**\r\n     * @notice The Pause Guardian can pause certain actions as a safety mechanism.\r\n     *  Actions which allow users to remove their own assets cannot be paused.\r\n     */\r\n    address public pauseGuardian;\r\n    bool public paused;\r\n    mapping(address => bool) public marketMintPaused;\r\n    mapping(address => bool) public marketRedeemPaused;\r\n    mapping(address => bool) public marketBorrowPaused;\r\n    mapping(address => bool) public marketRepayBorrowPaused;\r\n    mapping(address => bool) public marketTransferPaused;\r\n    mapping(address => bool) public marketSeizePaused;\r\n\r\n    /**\r\n     * @notice Borrow caps enforced by borrowAllowed for each marketToken address. Defaults to zero which corresponds to unlimited borrowing.\r\n     */\r\n    mapping(address => uint) public borrowCaps;\r\n\r\n    /**\r\n     * @notice Supply caps enforced by mintAllowed for each marketToken address. Defaults to zero which corresponds to unlimited minting.\r\n     */\r\n    mapping(address => uint) public supplyCaps;\r\n\r\n    /**\r\n     * @notice Only addresses in the allowlist can call liquidations\r\n     */\r\n    address[] public liquidateAllowAddresses;\r\n\r\n    // No collateralFactorMantissa may exceed this value\r\n    uint internal constant collateralFactorMaxMantissa = 0.9e18; // 0.9\r\n\r\n    /// @notice Emitted when an admin supports a market\r\n    event MarketListed(MarketTokenInterface marketToken);\r\n\r\n    /// @notice Emitted when an account enters a market\r\n    event MarketEntered(MarketTokenInterface marketToken, address account);\r\n\r\n    /// @notice Emitted when an account exits a market\r\n    event MarketExited(MarketTokenInterface marketToken, address account);\r\n\r\n    /// @notice Emitted when close factor is changed by admin\r\n    event NewCloseFactor(uint oldCloseFactorMantissa, uint newCloseFactorMantissa);\r\n\r\n    /// @notice Emitted when a collateral factor is changed by admin\r\n    event NewCollateralFactor(MarketTokenInterface marketToken, uint oldCollateralFactorMantissa, uint newCollateralFactorMantissa);\r\n\r\n    /// @notice Emitted when liquidation incentive is changed by admin\r\n    event NewLiquidationIncentive(uint oldLiquidationIncentiveMantissa, uint newLiquidationIncentiveMantissa);\r\n\r\n    /// @notice Emitted when price oracle is changed\r\n    event NewPriceOracle(PriceOracle oldPriceOracle, PriceOracle newPriceOracle);\r\n\r\n    /// @notice Emitted when pause guardian is changed\r\n    event NewPauseGuardian(address oldPauseGuardian, address newPauseGuardian);\r\n\r\n    /// @notice Emitted when distributioner is changed\r\n    event NewDistributioner(address oldDistributioner, address newDistributioner);\r\n\r\n    /// @notice Emitted when an action is paused on a market\r\n    event ActionPaused(MarketTokenInterface marketToken, string action, bool pauseState);\r\n\r\n    /// @notice Emitted when paused changed\r\n    event Paused(bool pauseState);\r\n\r\n    /// @notice Emitted when borrow cap for a marketToken is changed\r\n    event NewBorrowCap(MarketTokenInterface indexed marketToken, uint newBorrowCap);\r\n\r\n    /// @notice Emitted when mint cap for a marketToken is changed\r\n    event NewSupplyCap(MarketTokenInterface indexed marketToken, uint newSupplyCap);\r\n\r\n    /// @notice Emitted when minted\r\n    event MintVerify(address marketToken, address minter, uint actualMintAmount, uint mintTokens);\r\n\r\n    /// @notice Emitted when redeemed\r\n    event RedeemVerify(address marketToken, address redeemer, uint redeemAmount, uint redeemTokens);\r\n\r\n    /// @notice Emitted when borrowed\r\n    event BorrowVerify(address marketToken, address borrower, uint borrowAmount);\r\n\r\n    /// @notice Emitted when repayborrowed\r\n    event RepayBorrowVerify(address marketToken, address payer, address borrower, uint actualRepayAmount, uint borrowerIndex);\r\n\r\n    /// @notice Emitted when liquidateborrowed\r\n    event LiquidateBorrowVerify(address marketTokenBorrowed,address marketTokenCollateral,address liquidator,address borrower,uint actualRepayAmount,uint seizeTokens);\r\n\r\n    /// @notice Emitted when seized\r\n    event SeizeVerify(address marketTokenCollateral,address marketTokenBorrowed,address liquidator,address borrower,uint seizeTokens); \r\n\r\n    /// @notice Emitted when transfered\r\n    event TransferVerify(address marketToken, address src, address dst, uint transferTokens);\r\n\r\n    function hasOwnerRights() public virtual view returns(bool) {\r\n        return msg.sender == owner();\r\n    }\r\n\r\n\r\n}\r\n\r\n\r\n// File contracts/comptroller/Comptroller.sol\r\n\r\n\r\npragma solidity ^0.8.0;\r\n\r\ncontract Comptroller is AbstractComptroller {\r\n\r\n    function initialize(PriceOracle _oracle, uint _closeFactorMantissa,uint _liquidationIncentiveMantissa) public initializer virtual {\r\n        OwnableUpgradeable.__Ownable_init();\r\n       \r\n        oracle = _oracle;\r\n        closeFactorMantissa = _closeFactorMantissa;\r\n        liquidationIncentiveMantissa = _liquidationIncentiveMantissa;\r\n    }\r\n\r\n    /*** Assets You Are In ***/\r\n\r\n    /**\r\n     * @notice Returns the assets an account has entered\r\n     * @param account The address of the account to pull assets for\r\n     * @return A dynamic list with the assets the account has entered\r\n     */\r\n    function getAssetsIn(address account) external view returns (MarketTokenInterface[] memory) {\r\n        MarketTokenInterface[] memory assetsIn = accountAssets[account];\r\n        return assetsIn;\r\n    }\r\n\r\n    /**\r\n     * @notice Returns whether the given account is entered in the given asset\r\n     * @param account The address of the account to check\r\n     * @param marketToken The marketToken to check\r\n     * @return True if the account is in the asset, otherwise false.\r\n     */\r\n    function checkMembership(address account, MarketTokenInterface marketToken) external view returns (bool) {\r\n        return markets[address(marketToken)].accountMembership[account];\r\n    }\r\n\r\n    /**\r\n     * @notice Add assets to be included in account liquidity calculation\r\n     * @param marketTokens The list of addresses of the marketToken markets to be enabled\r\n     * @return Success indicator for whether each corresponding market was entered\r\n     */\r\n    function enterMarkets(address[] memory marketTokens) public returns (uint[] memory) {\r\n        uint len = marketTokens.length;\r\n\r\n        uint[] memory results = new uint[](len);\r\n        for (uint i = 0; i < len; i++) {\r\n            MarketTokenInterface marketToken = MarketTokenInterface(marketTokens[i]);\r\n            addToMarketInternal(marketToken, msg.sender);\r\n\r\n            results[i] = NO_ERROR;\r\n        }\r\n\r\n        return results;\r\n    }\r\n\r\n    /**\r\n     * @notice Add the market to the borrower's \"assets in\" for liquidity calculations\r\n     * @param marketToken The market to enter\r\n     * @param borrower The address of the account to modify\r\n     */\r\n    function addToMarketInternal(MarketTokenInterface marketToken, address borrower) internal {\r\n        Market storage marketToJoin = markets[address(marketToken)];\r\n\r\n        if (!marketToJoin.isListed) {\r\n            // market is not listed, cannot join\r\n            revert MarketNotListed();\r\n        }\r\n\r\n        if (marketToJoin.accountMembership[borrower] == true) {\r\n            // already joined\r\n            return;\r\n        }\r\n\r\n        // survived the gauntlet, add to list\r\n        // NOTE: we store these somewhat redundantly as a significant optimization\r\n        //  this avoids having to iterate through the list for the most common use cases\r\n        //  that is, only when we need to perform liquidity checks\r\n        //  and not whenever we want to check if an account is in a particular market\r\n        marketToJoin.accountMembership[borrower] = true;\r\n        accountAssets[borrower].push(marketToken);\r\n\r\n        emit MarketEntered(marketToken, borrower);\r\n\r\n    }\r\n\r\n    /**\r\n     * @notice Removes asset from sender's account liquidity calculation\r\n     * @dev Sender must not have an outstanding borrow balance in the asset,\r\n     *  or be providing necessary collateral for an outstanding borrow.\r\n     * @param marketTokenAddress The address of the asset to be removed\r\n     * @return Whether or not the account successfully exited the market\r\n     */\r\n    function exitMarket(address marketTokenAddress) external returns (uint) {\r\n        MarketTokenInterface marketToken = MarketTokenInterface(marketTokenAddress);\r\n        /* Get sender tokensHeld and amountOwed underlying from the marketToken */\r\n        (uint oErr, uint tokensHeld, uint amountOwed, ) = marketToken.getAccountSnapshot(msg.sender);\r\n        require(oErr == 0, \"exitMarket: getAccountSnapshot failed\"); // semi-opaque error code\r\n\r\n        /* Fail if the sender has a borrow balance */\r\n        if (amountOwed != 0) {\r\n            revert NonzeroBorrowBalance();\r\n        }\r\n\r\n        /* Fail if the sender is not permitted to redeem all of their tokens */\r\n        redeemAllowedInternal(marketTokenAddress, msg.sender, tokensHeld);\r\n\r\n        Market storage marketToExit = markets[address(marketToken)];\r\n\r\n        /* Return true if the sender is not already ‘in’ the market */\r\n        if (!marketToExit.accountMembership[msg.sender]) {\r\n            return NO_ERROR;\r\n        }\r\n\r\n        /* Set marketToken account membership to false */\r\n        delete marketToExit.accountMembership[msg.sender];\r\n\r\n        /* Delete marketToken from the account’s list of assets */\r\n        // load into memory for faster iteration\r\n        MarketTokenInterface[] memory userAssetList = accountAssets[msg.sender];\r\n        uint len = userAssetList.length;\r\n        uint assetIndex = len;\r\n        for (uint i = 0; i < len; i++) {\r\n            if (userAssetList[i] == marketToken) {\r\n                assetIndex = i;\r\n                break;\r\n            }\r\n        }\r\n\r\n        // We *must* have found the asset in the list or our redundant data structure is broken\r\n        assert(assetIndex < len);\r\n\r\n        // copy last item in list to location of item to be removed, reduce length by 1\r\n        MarketTokenInterface[] storage storedList = accountAssets[msg.sender];\r\n        storedList[assetIndex] = storedList[storedList.length - 1];\r\n        storedList.pop();\r\n\r\n        emit MarketExited(marketToken, msg.sender);\r\n\r\n        return NO_ERROR;\r\n    }\r\n\r\n    /*** Policy Hooks ***/\r\n\r\n    /**\r\n     * @notice Checks if the account should be allowed to mint tokens in the given market\r\n     * @param marketToken The market to verify the mint against\r\n     * @param minter The account which would get the minted tokens\r\n     * @param mintAmount The amount of underlying being supplied to the market in exchange for tokens\r\n     * @return 0 if the mint is allowed, otherwise a semi-opaque error code (See ErrorReporter.sol)\r\n     */\r\n    function mintAllowed(address marketToken, address minter, uint mintAmount) external returns (uint) {\r\n        // Pausing is a very serious situation - we revert to sound the alarms\r\n        require(!marketMintPaused[marketToken] && paused==false, \"mint is paused\");\r\n\r\n        if (!markets[marketToken].isListed) {\r\n            revert MarketNotListed();\r\n        }\r\n\r\n        // addToMarket when user mint\r\n        if (!markets[marketToken].accountMembership[minter]) {\r\n            require(msg.sender == marketToken, \"sender must be marketToken\");\r\n            addToMarketInternal(MarketTokenInterface(msg.sender), minter);\r\n            assert(markets[marketToken].accountMembership[minter]);\r\n        }\r\n\r\n        // make sure the supplyCap\r\n        uint supplyCap = supplyCaps[marketToken];\r\n        if (supplyCap != 0) {\r\n            uint totalSupply = MarketTokenInterface(marketToken).totalSupply();\r\n            uint exchangeRate = MarketTokenInterface(marketToken).exchangeRateStored();\r\n            uint balance = mul_ScalarTruncate(Exp({mantissa : exchangeRate}), totalSupply);\r\n            uint nextTotalMints = add_(balance, mintAmount);\r\n            require(nextTotalMints < supplyCap, \"market mint cap reached\");\r\n        }\r\n\r\n        if(address(distributioner) != address(0)){\r\n            distributioner.distributeMintReward(marketToken,minter);\r\n        }\r\n\r\n        return NO_ERROR;\r\n    }\r\n\r\n    /**\r\n     * @notice Validates mint and reverts on rejection. May emit logs.\r\n     * @param marketToken Asset being minted\r\n     * @param minter The address minting the tokens\r\n     * @param actualMintAmount The amount of the underlying asset being minted\r\n     * @param mintTokens The number of tokens being minted\r\n     */\r\n    function mintVerify(address marketToken, address minter, uint actualMintAmount, uint mintTokens) public virtual{\r\n        emit MintVerify(marketToken, minter, actualMintAmount, mintTokens);\r\n    }\r\n\r\n    /**\r\n     * @notice Checks if the account should be allowed to redeem tokens in the given market\r\n     * @param marketToken The market to verify the redeem against\r\n     * @param redeemer The account which would redeem the tokens\r\n     * @param redeemTokens The number of marketTokens to exchange for the underlying asset in the market\r\n     * @return 0 if the redeem is allowed, otherwise a semi-opaque error code (See ErrorReporter.sol)\r\n     */\r\n    function redeemAllowed(address marketToken, address redeemer, uint redeemTokens) external returns (uint) {\r\n        // Pausing is a very serious situation - we revert to sound the alarms\r\n        require(!marketRedeemPaused[marketToken] && paused==false, \"redeem is paused\");\r\n\r\n        redeemAllowedInternal(marketToken, redeemer, redeemTokens);\r\n\r\n        if(address(distributioner) != address(0)){\r\n            distributioner.distributeRedeemReward(marketToken,redeemer);\r\n        }\r\n\r\n        return NO_ERROR;\r\n    }\r\n\r\n    function redeemAllowedInternal(address marketToken, address redeemer, uint redeemTokens) internal view{\r\n        if (!markets[marketToken].isListed) {\r\n            revert MarketNotListed();\r\n        }\r\n\r\n        /* If the redeemer is not 'in' the market, then we can bypass the liquidity check */\r\n        if (!markets[marketToken].accountMembership[redeemer]) {\r\n            return;\r\n        }\r\n\r\n        /* Otherwise, perform a hypothetical liquidity check to guard against shortfall */\r\n        (, uint shortfall) = getHypotheticalAccountLiquidityInternal(redeemer, MarketTokenInterface(marketToken), redeemTokens, 0);\r\n    \r\n        if (shortfall > 0) {\r\n            revert InsufficientLiquidity();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Validates redeem and reverts on rejection. May emit logs.\r\n     * @param marketToken Asset being redeemed\r\n     * @param redeemer The address redeeming the tokens\r\n     * @param redeemAmount The amount of the underlying asset being redeemed\r\n     * @param redeemTokens The number of tokens being redeemed\r\n     */\r\n    function redeemVerify(address marketToken, address redeemer, uint redeemAmount, uint redeemTokens) public virtual{\r\n        emit RedeemVerify(marketToken, redeemer, redeemAmount, redeemTokens);\r\n    }\r\n\r\n    /**\r\n     * @notice Checks if the account should be allowed to borrow the underlying asset of the given market\r\n     * @param marketToken The market to verify the borrow against\r\n     * @param borrower The account which would borrow the asset\r\n     * @param borrowAmount The amount of underlying the account would borrow\r\n     * @return 0 if the borrow is allowed, otherwise a semi-opaque error code (See ErrorReporter.sol)\r\n     */\r\n    function borrowAllowed(address marketToken, address borrower, uint borrowAmount) external returns (uint) {\r\n        // Pausing is a very serious situation - we revert to sound the alarms\r\n        require(!marketBorrowPaused[marketToken] && paused==false, \"borrow is paused\");\r\n\r\n        if (!markets[marketToken].isListed) {\r\n            revert MarketNotListed();\r\n        }\r\n\r\n        if (!markets[marketToken].accountMembership[borrower]) {\r\n            // only marketTokens may call borrowAllowed if borrower not in market\r\n            require(msg.sender == marketToken, \"sender must be marketToken\");\r\n\r\n            // attempt to add borrower to the market\r\n            addToMarketInternal(MarketTokenInterface(msg.sender), borrower);\r\n\r\n            // it should be impossible to break the important invariant\r\n            assert(markets[marketToken].accountMembership[borrower]);\r\n        }\r\n\r\n        if (oracle.getUnderlyingPrice(MarketTokenInterface(marketToken)) == 0) {\r\n            revert PriceError();\r\n        }\r\n\r\n        uint borrowCap = borrowCaps[marketToken];\r\n        // Borrow cap of 0 corresponds to unlimited borrowing\r\n        if (borrowCap != 0) {\r\n            uint totalBorrows = MarketTokenInterface(marketToken).totalBorrows();\r\n            uint nextTotalBorrows = add_(totalBorrows, borrowAmount);\r\n            require(nextTotalBorrows < borrowCap, \"market borrow cap reached\");\r\n        }\r\n\r\n        ( , uint shortfall) = getHypotheticalAccountLiquidityInternal(borrower, MarketTokenInterface(marketToken), 0, borrowAmount);\r\n        if (shortfall > 0) {\r\n            revert InsufficientLiquidity();\r\n        }\r\n\r\n        if(address(distributioner) != address(0)){\r\n            distributioner.distributeBorrowReward(marketToken, borrower);\r\n        }\r\n\r\n        return NO_ERROR;\r\n    }\r\n\r\n    /**\r\n     * @notice Validates borrow and reverts on rejection. May emit logs.\r\n     * @param marketToken Asset whose underlying is being borrowed\r\n     * @param borrower The address borrowing the underlying\r\n     * @param borrowAmount The amount of the underlying asset requested to borrow\r\n     */\r\n    function borrowVerify(address marketToken, address borrower, uint borrowAmount) public virtual{\r\n        emit BorrowVerify(marketToken, borrower, borrowAmount);\r\n    }\r\n\r\n    /**\r\n     * @notice Checks if the account should be allowed to repay a borrow in the given market\r\n     * @param marketToken The market to verify the repay against\r\n     * @param payer The account which would repay the asset\r\n     * @param borrower The account which would borrowed the asset\r\n     * @param repayAmount The amount of the underlying asset the account would repay\r\n     * @return 0 if the repay is allowed, otherwise a semi-opaque error code (See ErrorReporter.sol)\r\n     */\r\n    function repayBorrowAllowed(\r\n        address marketToken,\r\n        address payer,\r\n        address borrower,\r\n        uint repayAmount) external returns (uint) {\r\n\r\n        // Pausing is a very serious situation - we revert to sound the alarms\r\n        require(!marketRepayBorrowPaused[marketToken] && paused==false, \"repayborrow is paused\");\r\n\r\n        // Shh - currently unused\r\n        payer;\r\n        borrower;\r\n        repayAmount;\r\n\r\n        if (!markets[marketToken].isListed) {\r\n            revert MarketNotListed();\r\n        }\r\n\r\n        if(address(distributioner) != address(0)){\r\n            distributioner.distributeRepayBorrowReward(marketToken, borrower);\r\n        }\r\n\r\n        return NO_ERROR;\r\n    }\r\n\r\n    /**\r\n     * @notice Validates repayBorrow and reverts on rejection. May emit logs.\r\n     * @param marketToken Asset being repaid\r\n     * @param payer The address repaying the borrow\r\n     * @param borrower The address of the borrower\r\n     * @param actualRepayAmount The amount of underlying being repaid\r\n     */\r\n    function repayBorrowVerify(\r\n        address marketToken,\r\n        address payer,\r\n        address borrower,\r\n        uint actualRepayAmount,\r\n        uint borrowerIndex) public virtual {\r\n        emit RepayBorrowVerify(marketToken,payer,borrower,actualRepayAmount,borrowerIndex);\r\n    }\r\n\r\n    /**\r\n     * @notice Checks if the liquidation should be allowed to occur\r\n     * @param marketTokenBorrowed Asset which was borrowed by the borrower\r\n     * @param marketTokenCollateral Asset which was used as collateral and will be seized\r\n     * @param liquidator The address repaying the borrow and seizing the collateral\r\n     * @param borrower The address of the borrower\r\n     * @param repayAmount The amount of underlying being repaid\r\n     */\r\n    function liquidateBorrowAllowed (\r\n        address marketTokenBorrowed,\r\n        address marketTokenCollateral,\r\n        address liquidator,\r\n        address borrower,\r\n        uint repayAmount) external view returns (uint) {\r\n        \r\n        // check the liquidateAllowAddresses\r\n        if(liquidateAllowAddresses.length > 0) {\r\n            bool _liquidateBorrowAllowed = false;\r\n            for(uint i = 0; i < liquidateAllowAddresses.length; i++){\r\n                if(liquidator == liquidateAllowAddresses[i]){\r\n                    _liquidateBorrowAllowed = true;\r\n                    break;\r\n                }\r\n            }\r\n            require(_liquidateBorrowAllowed,\"The liquidator is not permitted to execute.\");\r\n        }\r\n        \r\n\r\n        if (!markets[marketTokenBorrowed].isListed || !markets[marketTokenCollateral].isListed) {\r\n            revert MarketNotListed();\r\n        }\r\n\r\n        // Make sure the borrower's marketTokenCollateral has entered\r\n        bool marketEntered = markets[address(marketTokenCollateral)].accountMembership[borrower];\r\n        if(marketEntered == false){\r\n            revert MarketNotEntered();\r\n        }\r\n\r\n        uint borrowBalance = MarketTokenInterface(marketTokenBorrowed).borrowBalanceStored(borrower);\r\n\r\n        /* allow accounts to be liquidated if the market is deprecated */\r\n        if (isDeprecated(MarketTokenInterface(marketTokenBorrowed))) {\r\n            require(borrowBalance >= repayAmount, \"Can not repay more than the total borrow\");\r\n        } else {\r\n            /* The borrower must have shortfall in order to be liquidatable */\r\n            (, uint shortfall) = getAccountLiquidityInternal(borrower);\r\n            if (shortfall == 0) {\r\n                revert InsufficientShortfall();\r\n            }\r\n\r\n            /* The liquidator may not repay more than what is allowed by the closeFactor */\r\n            uint maxClose = mul_ScalarTruncate(Exp({mantissa: closeFactorMantissa}), borrowBalance);\r\n            if (repayAmount > maxClose) {\r\n                revert TooMuchRepay();\r\n            }\r\n        }\r\n\r\n        return NO_ERROR;\r\n    }\r\n\r\n    /**\r\n     * @notice Validates liquidateBorrow and reverts on rejection. May emit logs.\r\n     * @param marketTokenBorrowed Asset which was borrowed by the borrower\r\n     * @param marketTokenCollateral Asset which was used as collateral and will be seized\r\n     * @param liquidator The address repaying the borrow and seizing the collateral\r\n     * @param borrower The address of the borrower\r\n     * @param actualRepayAmount The amount of underlying being repaid\r\n     */\r\n    function liquidateBorrowVerify(\r\n        address marketTokenBorrowed,\r\n        address marketTokenCollateral,\r\n        address liquidator,\r\n        address borrower,\r\n        uint actualRepayAmount,\r\n        uint seizeTokens) public virtual{\r\n         \r\n        emit LiquidateBorrowVerify(marketTokenBorrowed,marketTokenCollateral,liquidator,borrower,actualRepayAmount,seizeTokens);\r\n    }\r\n\r\n    /**\r\n     * @notice Checks if the seizing of assets should be allowed to occur\r\n     * @param marketTokenCollateral Asset which was used as collateral and will be seized\r\n     * @param marketTokenBorrowed Asset which was borrowed by the borrower\r\n     * @param liquidator The address repaying the borrow and seizing the collateral\r\n     * @param borrower The address of the borrower\r\n     * @param seizeTokens The number of collateral tokens to seize\r\n     */\r\n    function seizeAllowed(\r\n        address marketTokenCollateral,\r\n        address marketTokenBorrowed,\r\n        address liquidator,\r\n        address borrower,\r\n        uint seizeTokens) external returns (uint) {\r\n        // Pausing is a very serious situation - we revert to sound the alarms\r\n        require(!marketSeizePaused[marketTokenCollateral] && !marketSeizePaused[marketTokenBorrowed] && paused==false, \"seize is paused\");\r\n\r\n        // Shh - currently unused\r\n        seizeTokens;\r\n\r\n        if (!markets[marketTokenCollateral].isListed || !markets[marketTokenBorrowed].isListed) {\r\n            revert MarketNotListed();\r\n        }\r\n\r\n        if (MarketTokenInterface(marketTokenCollateral).comptroller() != MarketTokenInterface(marketTokenBorrowed).comptroller()) {\r\n            revert ComptrollerMismatch();\r\n        }\r\n\r\n        if(address(distributioner) != address(0)){\r\n            distributioner.distributeSeizeReward(marketTokenCollateral,borrower,liquidator);\r\n        }\r\n\r\n        return NO_ERROR;\r\n    }\r\n\r\n    /**\r\n     * @notice Validates seize and reverts on rejection. May emit logs.\r\n     * @param marketTokenCollateral Asset which was used as collateral and will be seized\r\n     * @param marketTokenBorrowed Asset which was borrowed by the borrower\r\n     * @param liquidator The address repaying the borrow and seizing the collateral\r\n     * @param borrower The address of the borrower\r\n     * @param seizeTokens The number of collateral tokens to seize\r\n     */\r\n    function seizeVerify(\r\n        address marketTokenCollateral,\r\n        address marketTokenBorrowed,\r\n        address liquidator,\r\n        address borrower,\r\n        uint seizeTokens) public virtual{\r\n        \r\n        emit SeizeVerify(marketTokenCollateral,marketTokenBorrowed,liquidator,borrower,seizeTokens);\r\n    }\r\n\r\n    /**\r\n     * @notice Checks if the account should be allowed to transfer tokens in the given market\r\n     * @param marketToken The market to verify the transfer against\r\n     * @param src The account which sources the tokens\r\n     * @param dst The account which receives the tokens\r\n     * @param transferTokens The number of marketTokens to transfer\r\n     * @return 0 if the transfer is allowed, otherwise a semi-opaque error code (See ErrorReporter.sol)\r\n     */\r\n    function transferAllowed(address marketToken, address src, address dst, uint transferTokens) external returns (uint) {\r\n        // Pausing is a very serious situation - we revert to sound the alarms\r\n        require(!marketTransferPaused[marketToken] && paused==false, \"transfer is paused\");\r\n\r\n        // Currently the only consideration is whether or not\r\n        //  the src is allowed to redeem this many tokens\r\n        redeemAllowedInternal(marketToken, src, transferTokens);\r\n\r\n        // the dst will enter market\r\n        if (!markets[marketToken].accountMembership[dst]) {\r\n            require(msg.sender == marketToken, \"sender must be marketToken\");\r\n            addToMarketInternal(MarketTokenInterface(msg.sender), dst);\r\n            assert(markets[marketToken].accountMembership[dst]);\r\n        }\r\n\r\n        if(address(distributioner) != address(0)){\r\n            distributioner.distributeTransferReward(marketToken,src,dst);\r\n        }\r\n\r\n        return NO_ERROR;\r\n    }\r\n\r\n    /**\r\n     * @notice Validates transfer and reverts on rejection. May emit logs.\r\n     * @param marketToken Asset being transferred\r\n     * @param src The account which sources the tokens\r\n     * @param dst The account which receives the tokens\r\n     * @param transferTokens The number of marketTokens to transfer\r\n     */\r\n    function transferVerify(address marketToken, address src, address dst, uint transferTokens) public virtual {\r\n        \r\n        emit TransferVerify(marketToken, src, dst, transferTokens);\r\n    }\r\n\r\n    /*** Liquidity/Liquidation Calculations ***/\r\n\r\n    /**\r\n     * @dev Local vars for avoiding stack-depth limits in calculating account liquidity.\r\n     *  Note that `cTokenBalance` is the number of marketTokens the account owns in the market,\r\n     *  whereas `borrowBalance` is the amount of underlying that the account has borrowed.\r\n     */\r\n    struct AccountLiquidityLocalVars {\r\n        uint sumCollateral;\r\n        uint sumBorrowPlusEffects;\r\n        uint cTokenBalance;\r\n        uint borrowBalance;\r\n        uint exchangeRateMantissa;\r\n        uint oraclePriceMantissa;\r\n        Exp collateralFactor;\r\n        Exp exchangeRate;\r\n        Exp oraclePrice;\r\n        Exp tokensToDenom;\r\n    }\r\n\r\n    /**\r\n     * @notice Determine the current account liquidity wrt collateral requirements\r\n     * @return (possible error code (semi-opaque),\r\n                account liquidity in excess of collateral requirements,\r\n     *          account shortfall below collateral requirements)\r\n     */\r\n    function getAccountLiquidity(address account) public view returns (uint, uint, uint) {\r\n        (uint liquidity, uint shortfall) = getHypotheticalAccountLiquidityInternal(account, MarketTokenInterface(address(0)), 0, 0);\r\n\r\n        return (NO_ERROR, liquidity, shortfall);\r\n    }\r\n\r\n    /**\r\n     * @notice Determine the current account liquidity wrt collateral requirements\r\n     * @return (possible error code,\r\n                account liquidity in excess of collateral requirements,\r\n     *          account shortfall below collateral requirements)\r\n     */\r\n    function getAccountLiquidityInternal(address account) internal view returns (uint, uint) {\r\n        return getHypotheticalAccountLiquidityInternal(account, MarketTokenInterface(address(0)), 0, 0);\r\n    }\r\n\r\n    /**\r\n     * @notice Determine what the account liquidity would be if the given amounts were redeemed/borrowed\r\n     * @param marketTokenModify The market to hypothetically redeem/borrow in\r\n     * @param account The account to determine liquidity for\r\n     * @param redeemTokens The number of tokens to hypothetically redeem\r\n     * @param borrowAmount The amount of underlying to hypothetically borrow\r\n     * @return (possible error code (semi-opaque),\r\n                hypothetical account liquidity in excess of collateral requirements,\r\n     *          hypothetical account shortfall below collateral requirements)\r\n     */\r\n    function getHypotheticalAccountLiquidity(\r\n        address account,\r\n        address marketTokenModify,\r\n        uint redeemTokens,\r\n        uint borrowAmount) public view returns (uint, uint, uint) {\r\n        (uint liquidity, uint shortfall) = getHypotheticalAccountLiquidityInternal(account, MarketTokenInterface(marketTokenModify), redeemTokens, borrowAmount);\r\n        return (NO_ERROR, liquidity, shortfall);\r\n    }\r\n\r\n    /**\r\n     * @notice Determine what the account liquidity would be if the given amounts were redeemed/borrowed\r\n     * @param marketTokenModify The market to hypothetically redeem/borrow in\r\n     * @param account The account to determine liquidity for\r\n     * @param redeemTokens The number of tokens to hypothetically redeem\r\n     * @param borrowAmount The amount of underlying to hypothetically borrow\r\n     * @dev Note that we calculate the exchangeRateStored for each collateral marketToken using stored data,\r\n     *  without calculating accumulated interest.\r\n     * @return (possible error code,\r\n                hypothetical account liquidity in excess of collateral requirements,\r\n     *          hypothetical account shortfall below collateral requirements)\r\n     */\r\n    function getHypotheticalAccountLiquidityInternal(\r\n        address account,\r\n        MarketTokenInterface marketTokenModify,\r\n        uint redeemTokens,\r\n        uint borrowAmount) internal view returns (uint, uint) {\r\n\r\n        AccountLiquidityLocalVars memory vars; // Holds all our calculation results\r\n        uint oErr;\r\n\r\n        // For each asset the account is in\r\n        MarketTokenInterface[] memory assets = accountAssets[account];\r\n        for (uint i = 0; i < assets.length; i++) {\r\n            MarketTokenInterface asset = assets[i];\r\n\r\n            // Read the balances and exchange rate from the marketToken\r\n            (oErr, vars.cTokenBalance, vars.borrowBalance, vars.exchangeRateMantissa) = asset.getAccountSnapshot(account);\r\n            if (oErr != 0) { // semi-opaque error code, we assume NO_ERROR == 0 is invariant between upgrades\r\n                revert SnapshotError();\r\n            }\r\n            vars.collateralFactor = Exp({mantissa: markets[address(asset)].collateralFactorMantissa});\r\n            vars.exchangeRate = Exp({mantissa: vars.exchangeRateMantissa});\r\n\r\n            // Get the normalized price of the asset\r\n            vars.oraclePriceMantissa = oracle.getUnderlyingPrice(asset);\r\n            if (vars.oraclePriceMantissa == 0) {\r\n                revert PriceError();\r\n            }\r\n            vars.oraclePrice = Exp({mantissa: vars.oraclePriceMantissa});\r\n\r\n            // Pre-compute a conversion factor from tokens -> ether (normalized price value)\r\n            vars.tokensToDenom = mul_(mul_(vars.collateralFactor, vars.exchangeRate), vars.oraclePrice);\r\n\r\n            // sumCollateral += tokensToDenom * cTokenBalance\r\n            vars.sumCollateral = mul_ScalarTruncateAddUInt(vars.tokensToDenom, vars.cTokenBalance, vars.sumCollateral);\r\n\r\n            // sumBorrowPlusEffects += oraclePrice * borrowBalance\r\n            vars.sumBorrowPlusEffects = mul_ScalarTruncateAddUInt(vars.oraclePrice, vars.borrowBalance, vars.sumBorrowPlusEffects);\r\n\r\n            // Calculate effects of interacting with marketTokenModify\r\n            if (asset == marketTokenModify) {\r\n                // redeem effect\r\n                // sumBorrowPlusEffects += tokensToDenom * redeemTokens\r\n                vars.sumBorrowPlusEffects = mul_ScalarTruncateAddUInt(vars.tokensToDenom, redeemTokens, vars.sumBorrowPlusEffects);\r\n\r\n                // borrow effect\r\n                // sumBorrowPlusEffects += oraclePrice * borrowAmount\r\n                vars.sumBorrowPlusEffects = mul_ScalarTruncateAddUInt(vars.oraclePrice, borrowAmount, vars.sumBorrowPlusEffects);\r\n            }\r\n        }\r\n\r\n        // These are safe, as the underflow condition is checked first\r\n        if (vars.sumCollateral > vars.sumBorrowPlusEffects) {\r\n            return (vars.sumCollateral - vars.sumBorrowPlusEffects, 0);\r\n        } else {\r\n            return (0, vars.sumBorrowPlusEffects - vars.sumCollateral);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Calculate number of tokens of collateral asset to seize given an underlying amount\r\n     * @dev Used in liquidation (called in marketToken.liquidateBorrowFresh)\r\n     * @param marketTokenBorrowed The address of the borrowed marketToken\r\n     * @param marketTokenCollateral The address of the collateral marketToken\r\n     * @param actualRepayAmount The amount of marketTokenBorrowed underlying to convert into marketTokenCollateral tokens\r\n     * @return (errorCode, number of marketTokenCollateral tokens to be seized in a liquidation)\r\n     */\r\n    function liquidateCalculateSeizeTokens(address marketTokenBorrowed, address marketTokenCollateral, uint actualRepayAmount) external view returns (uint, uint) {\r\n        /* Read oracle prices for borrowed and collateral markets */\r\n        uint priceBorrowedMantissa = oracle.getUnderlyingPrice(MarketTokenInterface(marketTokenBorrowed));\r\n        uint priceCollateralMantissa = oracle.getUnderlyingPrice(MarketTokenInterface(marketTokenCollateral));\r\n        if (priceBorrowedMantissa == 0 || priceCollateralMantissa == 0) {\r\n            revert PriceError();\r\n        }\r\n\r\n        /*\r\n         * Get the exchange rate and calculate the number of collateral tokens to seize:\r\n         *  seizeAmount = actualRepayAmount * liquidationIncentive * priceBorrowed / priceCollateral\r\n         *  seizeTokens = seizeAmount / exchangeRate\r\n         *   = actualRepayAmount * (liquidationIncentive * priceBorrowed) / (priceCollateral * exchangeRate)\r\n         */\r\n        uint exchangeRateMantissa = MarketTokenInterface(marketTokenCollateral).exchangeRateStored(); // Note: reverts on error\r\n        uint seizeTokens;\r\n        Exp memory numerator;\r\n        Exp memory denominator;\r\n        Exp memory ratio;\r\n\r\n        numerator = mul_(Exp({mantissa: liquidationIncentiveMantissa}), Exp({mantissa: priceBorrowedMantissa}));\r\n        denominator = mul_(Exp({mantissa: priceCollateralMantissa}), Exp({mantissa: exchangeRateMantissa}));\r\n        ratio = div_(numerator, denominator);\r\n\r\n        seizeTokens = mul_ScalarTruncate(ratio, actualRepayAmount);\r\n\r\n        return (NO_ERROR, seizeTokens);\r\n    }\r\n\r\n    /*** Admin Functions ***/\r\n\r\n    /**\r\n      * @notice Sets a new price oracle for the comptroller\r\n      * @dev Admin function to set a new price oracle\r\n      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\r\n      */\r\n    function _setPriceOracle(PriceOracle newOracle) public returns (uint) {\r\n        require(hasOwnerRights(), \"only owner can set price oracle\");\r\n\r\n        // Track the old oracle for the comptroller\r\n        PriceOracle oldOracle = oracle;\r\n\r\n        // Set comptroller's oracle to newOracle\r\n        oracle = newOracle;\r\n\r\n        // Emit NewPriceOracle(oldOracle, newOracle)\r\n        emit NewPriceOracle(oldOracle, newOracle);\r\n\r\n        return NO_ERROR;\r\n    }\r\n\r\n    /**\r\n      * @notice Sets the closeFactor used when liquidating borrows\r\n      * @dev Admin function to set closeFactor\r\n      * @param newCloseFactorMantissa New close factor, scaled by 1e18\r\n      * @return uint 0=success, otherwise a failure\r\n      */\r\n    function _setCloseFactor(uint newCloseFactorMantissa) external returns (uint) {\r\n    \trequire(hasOwnerRights(), \"only owner can set close factor\");\r\n\r\n        uint oldCloseFactorMantissa = closeFactorMantissa;\r\n        closeFactorMantissa = newCloseFactorMantissa;\r\n        emit NewCloseFactor(oldCloseFactorMantissa, closeFactorMantissa);\r\n\r\n        return NO_ERROR;\r\n    }\r\n\r\n    /**\r\n      * @notice Sets the collateralFactor for a market\r\n      * @dev Admin function to set per-market collateralFactor\r\n      * @param marketToken The market to set the factor on\r\n      * @param newCollateralFactorMantissa The new collateral factor, scaled by 1e18\r\n      * @return uint 0=success, otherwise a failure. (See ErrorReporter for details)\r\n      */\r\n    function _setCollateralFactor(MarketTokenInterface marketToken, uint newCollateralFactorMantissa) public returns (uint) {\r\n        require(hasOwnerRights(), \"only owner can set collateral factor\");\r\n        \r\n        // Verify market is listed\r\n        Market storage market = markets[address(marketToken)];\r\n        if (!market.isListed) {\r\n            revert SetCollateralFactorNoExists(); \r\n        }\r\n\r\n        Exp memory newCollateralFactorExp = Exp({mantissa: newCollateralFactorMantissa});\r\n\r\n        // Check collateral factor <= 0.9\r\n        Exp memory highLimit = Exp({mantissa: collateralFactorMaxMantissa});\r\n        if (lessThanExp(highLimit, newCollateralFactorExp)) {\r\n            revert SetCollateralFactorValidation();\r\n        }\r\n\r\n        // If collateral factor != 0, fail if price == 0\r\n        if (newCollateralFactorMantissa != 0 && oracle.getUnderlyingPrice(marketToken) == 0) {\r\n            revert SetCollateralFactorWithoutPrice();\r\n        }\r\n\r\n        // Set market's collateral factor to new collateral factor, remember old value\r\n        uint oldCollateralFactorMantissa = market.collateralFactorMantissa;\r\n        market.collateralFactorMantissa = newCollateralFactorMantissa;\r\n\r\n        // Emit event with asset, old collateral factor, and new collateral factor\r\n        emit NewCollateralFactor(marketToken, oldCollateralFactorMantissa, newCollateralFactorMantissa);\r\n\r\n        return NO_ERROR;\r\n    }\r\n\r\n    /**\r\n      * @notice Sets liquidationIncentive\r\n      * @dev Admin function to set liquidationIncentive\r\n      * @param newLiquidationIncentiveMantissa New liquidationIncentive scaled by 1e18\r\n      * @return uint 0=success, otherwise a failure. (See ErrorReporter for details)\r\n      */\r\n    function _setLiquidationIncentive(uint newLiquidationIncentiveMantissa) external returns (uint) {\r\n        require(hasOwnerRights(), \"only owner can set liquidation incentive matissa\");\r\n\r\n        // Save current value for use in log\r\n        uint oldLiquidationIncentiveMantissa = liquidationIncentiveMantissa;\r\n\r\n        // Set liquidation incentive to new incentive\r\n        liquidationIncentiveMantissa = newLiquidationIncentiveMantissa;\r\n\r\n        // Emit event with old incentive, new incentive\r\n        emit NewLiquidationIncentive(oldLiquidationIncentiveMantissa, newLiquidationIncentiveMantissa);\r\n\r\n        return NO_ERROR;\r\n    }\r\n\r\n    /**\r\n      * @notice Add the market to the markets mapping and set it as listed\r\n      * @dev Admin function to set isListed and add support for the market\r\n      * @param marketToken The address of the market (token) to list\r\n      * @return uint 0=success, otherwise a failure. (See enum Error for details)\r\n      */\r\n    function _supportMarket(MarketTokenInterface marketToken) public returns (uint) {\r\n        require(hasOwnerRights(), \"only owner can support market\");\r\n\r\n        if (markets[address(marketToken)].isListed) {\r\n            revert SupportMarketExists();\r\n        }\r\n\r\n        marketToken.isMarketToken(); // Sanity check to make sure its really a MarketTokenInterface\r\n\r\n        Market storage market = markets[address(marketToken)];\r\n        market.isListed = true;\r\n        market.collateralFactorMantissa = 0;\r\n\r\n        _addMarketInternal(address(marketToken));\r\n        if(address(distributioner) != address(0)){\r\n            distributioner._initializeMarket(address(marketToken));\r\n        }\r\n        \r\n        emit MarketListed(marketToken);\r\n\r\n        return NO_ERROR;\r\n    }\r\n\r\n    function _addMarketInternal(address marketToken) internal {\r\n        for (uint i = 0; i < allMarkets.length; i ++) {\r\n            require(allMarkets[i] != MarketTokenInterface(marketToken), \"market already added\");\r\n        }\r\n        allMarkets.push(MarketTokenInterface(marketToken));\r\n    }\r\n\r\n\r\n    /**\r\n      * @notice Set the given borrow caps for the given marketToken markets. Borrowing that brings total borrows to or above borrow cap will revert.\r\n      * @dev Owner function to set the borrow caps. A borrow cap of 0 corresponds to unlimited borrowing.\r\n      * @param marketTokens The addresses of the markets (tokens) to change the borrow caps for\r\n      * @param newBorrowCaps The new borrow cap values in underlying to be set. A value of 0 corresponds to unlimited borrowing.\r\n      */\r\n    function _setMarketBorrowCaps(MarketTokenInterface[] calldata marketTokens, uint[] calldata newBorrowCaps) external {\r\n    \trequire(hasOwnerRights(), \"only owner can set borrow caps\"); \r\n\r\n        uint numMarkets = marketTokens.length;\r\n        uint numBorrowCaps = newBorrowCaps.length;\r\n\r\n        require(numMarkets != 0 && numMarkets == numBorrowCaps, \"invalid input\");\r\n\r\n        for(uint i = 0; i < numMarkets; i++) {\r\n            borrowCaps[address(marketTokens[i])] = newBorrowCaps[i];\r\n            emit NewBorrowCap(marketTokens[i], newBorrowCaps[i]);\r\n        }\r\n    }\r\n\r\n    /**\r\n      * @notice Set the given supply caps for the given marketToken markets. Minting that brings total borrows to or above supply cap will revert.\r\n      * @dev Owner function to set the supply caps. A supply cap of 0 corresponds to unlimited minting.\r\n      * @param marketTokens The addresses of the markets (tokens) to change the supply caps for\r\n      * @param newSupplyCaps The new supply cap values in underlying to be set. A value of 0 corresponds to unlimited minting.\r\n      */\r\n    function _setMarketSupplyCaps(MarketTokenInterface[] calldata marketTokens, uint[] calldata newSupplyCaps) external {\r\n        require(hasOwnerRights(), \"only owner can set borrow caps\"); \r\n\r\n        uint numMarkets = marketTokens.length;\r\n        uint numSupplyCaps = newSupplyCaps.length;\r\n\r\n        require(numMarkets != 0 && numMarkets == numSupplyCaps, \"invalid input\");\r\n        for(uint i = 0; i < numMarkets; i++) {\r\n            supplyCaps[address(marketTokens[i])] = newSupplyCaps[i];\r\n            emit NewSupplyCap(marketTokens[i], newSupplyCaps[i]);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Admin function to change the Pause Guardian\r\n     * @param newPauseGuardian The address of the new Pause Guardian\r\n     * @return uint 0=success, otherwise a failure. (See enum Error for details)\r\n     */\r\n    function _setPauseGuardian(address newPauseGuardian) public returns (uint) {\r\n        require(hasOwnerRights(), \"only owner can set pause guardian\"); \r\n\r\n        // Save current value for inclusion in log\r\n        address oldPauseGuardian = pauseGuardian;\r\n\r\n        // Store pauseGuardian with value newPauseGuardian\r\n        pauseGuardian = newPauseGuardian;\r\n\r\n        emit NewPauseGuardian(oldPauseGuardian, pauseGuardian);\r\n\r\n        return NO_ERROR;\r\n    }\r\n\r\n    function _setDistributioner(address newDistributioner) public returns (uint) {\r\n        require(hasOwnerRights(),\"only owner can set distributioner\");\r\n\r\n        // Save current value for inclusion in log\r\n        address oldDistributioner = address(distributioner);\r\n\r\n        distributioner = DistributionerInterface(newDistributioner);\r\n\r\n        emit NewDistributioner(oldDistributioner, address(distributioner));\r\n\r\n        return NO_ERROR;\r\n    }\r\n\r\n\r\n    function _setMarketMintPaused(MarketTokenInterface marketToken, bool state) public returns (bool) {\r\n       require(msg.sender == pauseGuardian || hasOwnerRights(), \"only pause guardian and owner can pause\");\r\n\r\n        marketMintPaused[address(marketToken)] = state;\r\n        emit ActionPaused(marketToken, \"Mint\", state);\r\n        return state;\r\n    }\r\n\r\n    function _setMarketRedeemPaused(MarketTokenInterface marketToken, bool state) public returns (bool) {\r\n        require(msg.sender == pauseGuardian || hasOwnerRights(), \"only pause guardian and owner can pause\");\r\n\r\n        marketRedeemPaused[address(marketToken)] = state;\r\n        emit ActionPaused(marketToken, \"Redeem\", state);\r\n        return state;\r\n    }\r\n\r\n    function _setMarketBorrowPaused(MarketTokenInterface marketToken, bool state) public returns (bool) {\r\n        require(msg.sender == pauseGuardian || hasOwnerRights(), \"only pause guardian and owner can pause\");\r\n\r\n        marketBorrowPaused[address(marketToken)] = state;\r\n        emit ActionPaused(marketToken, \"Borrow\", state);\r\n        return state;\r\n    }\r\n\r\n    function _setMarketRepayBorrowPaused(MarketTokenInterface marketToken, bool state) public returns (bool) {\r\n        require(msg.sender == pauseGuardian || hasOwnerRights(), \"only pause guardian and owner can pause\");\r\n\r\n        marketRepayBorrowPaused[address(marketToken)] = state;\r\n        emit ActionPaused(marketToken, \"RepayBorrow\", state);\r\n        return state;\r\n    }\r\n    \r\n    function _setMarketTransferPaused(MarketTokenInterface marketToken, bool state) public returns (bool) {\r\n        require(msg.sender == pauseGuardian || hasOwnerRights(), \"only pause guardian and owner can pause\");\r\n\r\n        marketTransferPaused[address(marketToken)] = state;\r\n        emit ActionPaused(marketToken, \"Transfer\", state);\r\n        return state;\r\n    }\r\n\r\n    function _setMarketSeizePaused(MarketTokenInterface marketToken, bool state) public returns (bool) {\r\n        require(msg.sender == pauseGuardian || hasOwnerRights(), \"only pause guardian and owner can pause\");\r\n\r\n        marketSeizePaused[address(marketToken)]  = state;\r\n        emit ActionPaused(marketToken, \"Seize\", state);\r\n        return state;\r\n    }\r\n\r\n    function _setPaused(bool state) public {\r\n        require(hasOwnerRights(), \"only owner can pause\");\r\n        paused = state;\r\n        emit Paused(state);\r\n    }\r\n\r\n    /**\r\n     * @notice Return all of the markets\r\n     * @dev The automatic getter may be used to access an individual market.\r\n     * @return The list of market addresses\r\n     */\r\n    function getAllMarkets() public view returns (MarketTokenInterface[] memory) {\r\n        return allMarkets;\r\n    }\r\n\r\n    function isMarketListed(address marketToken) public view returns (bool){\r\n        return markets[marketToken].isListed;\r\n    }\r\n\r\n    function isDeprecated(MarketTokenInterface marketToken) public view returns (bool) {\r\n        return\r\n            markets[address(marketToken)].collateralFactorMantissa == 0 && \r\n            marketBorrowPaused[address(marketToken)] == true && \r\n            marketToken.reserveFactorMantissa() == 1e18\r\n        ;\r\n    }\r\n\r\n    function _setLiquidateAllowAddresses(address[] memory _liquidateAllowAddresses) public  {\r\n        require(hasOwnerRights(),\"only owner can set liquidateAllowAddresses\");\r\n        liquidateAllowAddresses = _liquidateAllowAddresses;\r\n    }\r\n\r\n}","ABI":"[{\"inputs\":[],\"name\":\"ComptrollerMismatch\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ExitMarketBalanceOwed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ExitMarketRejection\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InsufficientLiquidity\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InsufficientShortfall\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidCloseFactor\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidCollateralFactor\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"MarketAlreadyListed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"MarketNotEntered\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"MarketNotListed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NonzeroBorrowBalance\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"PriceError\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Rejection\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"SetCloseFactorOwnerCheck\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"SetCloseFactorValidation\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"SetCollateralFactorNoExists\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"SetCollateralFactorOwnerCheck\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"SetCollateralFactorValidation\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"SetCollateralFactorWithoutPrice\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"SetLiquidationIncentiveOwnerCheck\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"SetLiquidationIncentiveValidation\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"SetMaxAssetsOwnerCheck\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"SetPauseGuarianOwnerCheck\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"SetPriceOracleOwnerCheck\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"SnapshotError\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"SupportMarketExists\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"SupportMarketOwnerCheck\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TooManyAssets\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TooMuchRepay\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Unauthorized\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"contract MarketTokenInterface\",\"name\":\"marketToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"action\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"pauseState\",\"type\":\"bool\"}],\"name\":\"ActionPaused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"marketToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"borrower\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"borrowAmount\",\"type\":\"uint256\"}],\"name\":\"BorrowVerify\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"marketTokenBorrowed\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"marketTokenCollateral\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"liquidator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"borrower\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"actualRepayAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"seizeTokens\",\"type\":\"uint256\"}],\"name\":\"LiquidateBorrowVerify\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"contract MarketTokenInterface\",\"name\":\"marketToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"MarketEntered\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"contract MarketTokenInterface\",\"name\":\"marketToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"MarketExited\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"contract MarketTokenInterface\",\"name\":\"marketToken\",\"type\":\"address\"}],\"name\":\"MarketListed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"marketToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"minter\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"actualMintAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"mintTokens\",\"type\":\"uint256\"}],\"name\":\"MintVerify\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"contract MarketTokenInterface\",\"name\":\"marketToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newBorrowCap\",\"type\":\"uint256\"}],\"name\":\"NewBorrowCap\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"oldCloseFactorMantissa\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newCloseFactorMantissa\",\"type\":\"uint256\"}],\"name\":\"NewCloseFactor\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"contract MarketTokenInterface\",\"name\":\"marketToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"oldCollateralFactorMantissa\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newCollateralFactorMantissa\",\"type\":\"uint256\"}],\"name\":\"NewCollateralFactor\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldDistributioner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newDistributioner\",\"type\":\"address\"}],\"name\":\"NewDistributioner\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"oldLiquidationIncentiveMantissa\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newLiquidationIncentiveMantissa\",\"type\":\"uint256\"}],\"name\":\"NewLiquidationIncentive\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldPauseGuardian\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newPauseGuardian\",\"type\":\"address\"}],\"name\":\"NewPauseGuardian\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"contract PriceOracle\",\"name\":\"oldPriceOracle\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"contract PriceOracle\",\"name\":\"newPriceOracle\",\"type\":\"address\"}],\"name\":\"NewPriceOracle\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"contract MarketTokenInterface\",\"name\":\"marketToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newSupplyCap\",\"type\":\"uint256\"}],\"name\":\"NewSupplyCap\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"pauseState\",\"type\":\"bool\"}],\"name\":\"Paused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"marketToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"redeemer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"redeemAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"redeemTokens\",\"type\":\"uint256\"}],\"name\":\"RedeemVerify\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"marketToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"payer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"borrower\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"actualRepayAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"borrowerIndex\",\"type\":\"uint256\"}],\"name\":\"RepayBorrowVerify\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"marketTokenCollateral\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"marketTokenBorrowed\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"liquidator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"borrower\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"seizeTokens\",\"type\":\"uint256\"}],\"name\":\"SeizeVerify\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"marketToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"src\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"dst\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"transferTokens\",\"type\":\"uint256\"}],\"name\":\"TransferVerify\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"NO_ERROR\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newCloseFactorMantissa\",\"type\":\"uint256\"}],\"name\":\"_setCloseFactor\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract MarketTokenInterface\",\"name\":\"marketToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"newCollateralFactorMantissa\",\"type\":\"uint256\"}],\"name\":\"_setCollateralFactor\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newDistributioner\",\"type\":\"address\"}],\"name\":\"_setDistributioner\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_liquidateAllowAddresses\",\"type\":\"address[]\"}],\"name\":\"_setLiquidateAllowAddresses\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newLiquidationIncentiveMantissa\",\"type\":\"uint256\"}],\"name\":\"_setLiquidationIncentive\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract MarketTokenInterface[]\",\"name\":\"marketTokens\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"newBorrowCaps\",\"type\":\"uint256[]\"}],\"name\":\"_setMarketBorrowCaps\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract MarketTokenInterface\",\"name\":\"marketToken\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"state\",\"type\":\"bool\"}],\"name\":\"_setMarketBorrowPaused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract MarketTokenInterface\",\"name\":\"marketToken\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"state\",\"type\":\"bool\"}],\"name\":\"_setMarketMintPaused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract MarketTokenInterface\",\"name\":\"marketToken\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"state\",\"type\":\"bool\"}],\"name\":\"_setMarketRedeemPaused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract MarketTokenInterface\",\"name\":\"marketToken\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"state\",\"type\":\"bool\"}],\"name\":\"_setMarketRepayBorrowPaused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract MarketTokenInterface\",\"name\":\"marketToken\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"state\",\"type\":\"bool\"}],\"name\":\"_setMarketSeizePaused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract MarketTokenInterface[]\",\"name\":\"marketTokens\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"newSupplyCaps\",\"type\":\"uint256[]\"}],\"name\":\"_setMarketSupplyCaps\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract MarketTokenInterface\",\"name\":\"marketToken\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"state\",\"type\":\"bool\"}],\"name\":\"_setMarketTransferPaused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newPauseGuardian\",\"type\":\"address\"}],\"name\":\"_setPauseGuardian\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"state\",\"type\":\"bool\"}],\"name\":\"_setPaused\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract PriceOracle\",\"name\":\"newOracle\",\"type\":\"address\"}],\"name\":\"_setPriceOracle\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract MarketTokenInterface\",\"name\":\"marketToken\",\"type\":\"address\"}],\"name\":\"_supportMarket\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"accountAssets\",\"outputs\":[{\"internalType\":\"contract MarketTokenInterface\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"allMarkets\",\"outputs\":[{\"internalType\":\"contract MarketTokenInterface\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"marketToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"borrower\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"borrowAmount\",\"type\":\"uint256\"}],\"name\":\"borrowAllowed\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"borrowCaps\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"marketToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"borrower\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"borrowAmount\",\"type\":\"uint256\"}],\"name\":\"borrowVerify\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"contract MarketTokenInterface\",\"name\":\"marketToken\",\"type\":\"address\"}],\"name\":\"checkMembership\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"closeFactorMantissa\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"distributioner\",\"outputs\":[{\"internalType\":\"contract DistributionerInterface\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"marketTokens\",\"type\":\"address[]\"}],\"name\":\"enterMarkets\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"marketTokenAddress\",\"type\":\"address\"}],\"name\":\"exitMarket\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"getAccountLiquidity\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getAllMarkets\",\"outputs\":[{\"internalType\":\"contract MarketTokenInterface[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"getAssetsIn\",\"outputs\":[{\"internalType\":\"contract MarketTokenInterface[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"marketTokenModify\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"redeemTokens\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"borrowAmount\",\"type\":\"uint256\"}],\"name\":\"getHypotheticalAccountLiquidity\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"hasOwnerRights\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract PriceOracle\",\"name\":\"_oracle\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_closeFactorMantissa\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_liquidationIncentiveMantissa\",\"type\":\"uint256\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isComptroller\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract MarketTokenInterface\",\"name\":\"marketToken\",\"type\":\"address\"}],\"name\":\"isDeprecated\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"marketToken\",\"type\":\"address\"}],\"name\":\"isMarketListed\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"liquidateAllowAddresses\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"marketTokenBorrowed\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"marketTokenCollateral\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"liquidator\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"borrower\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"repayAmount\",\"type\":\"uint256\"}],\"name\":\"liquidateBorrowAllowed\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"marketTokenBorrowed\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"marketTokenCollateral\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"liquidator\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"borrower\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"actualRepayAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"seizeTokens\",\"type\":\"uint256\"}],\"name\":\"liquidateBorrowVerify\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"marketTokenBorrowed\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"marketTokenCollateral\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"actualRepayAmount\",\"type\":\"uint256\"}],\"name\":\"liquidateCalculateSeizeTokens\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"liquidationIncentiveMantissa\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"marketBorrowPaused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"marketMintPaused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"marketRedeemPaused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"marketRepayBorrowPaused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"marketSeizePaused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"marketTransferPaused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"markets\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"isListed\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"collateralFactorMantissa\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"marketToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"minter\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"mintAmount\",\"type\":\"uint256\"}],\"name\":\"mintAllowed\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"marketToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"minter\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"actualMintAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"mintTokens\",\"type\":\"uint256\"}],\"name\":\"mintVerify\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"oracle\",\"outputs\":[{\"internalType\":\"contract PriceOracle\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pauseGuardian\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"marketToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"redeemer\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"redeemTokens\",\"type\":\"uint256\"}],\"name\":\"redeemAllowed\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"marketToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"redeemer\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"redeemAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"redeemTokens\",\"type\":\"uint256\"}],\"name\":\"redeemVerify\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"marketToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"payer\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"borrower\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"repayAmount\",\"type\":\"uint256\"}],\"name\":\"repayBorrowAllowed\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"marketToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"payer\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"borrower\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"actualRepayAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"borrowerIndex\",\"type\":\"uint256\"}],\"name\":\"repayBorrowVerify\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"marketTokenCollateral\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"marketTokenBorrowed\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"liquidator\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"borrower\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"seizeTokens\",\"type\":\"uint256\"}],\"name\":\"seizeAllowed\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"marketTokenCollateral\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"marketTokenBorrowed\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"liquidator\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"borrower\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"seizeTokens\",\"type\":\"uint256\"}],\"name\":\"seizeVerify\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"supplyCaps\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"marketToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"src\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"dst\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"transferTokens\",\"type\":\"uint256\"}],\"name\":\"transferAllowed\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"marketToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"src\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"dst\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"transferTokens\",\"type\":\"uint256\"}],\"name\":\"transferVerify\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"Comptroller","CompilerVersion":"v0.8.9+commit.e5eed63a","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"ipfs://ac783cb3c2937b41c6c19d2dc8047fc13de8b9668b6866b9c7a33184dce6d4b4"}]}