{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"settings\": {\r\n    \"evmVersion\": \"istanbul\",\r\n    \"libraries\": {},\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"remappings\": [],\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  },\r\n  \"sources\": {\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if the sender is not the owner.\\n     */\\n    function _checkOwner() internal view virtual {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Strings.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/Strings.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev String operations.\\n */\\nlibrary Strings {\\n    bytes16 private constant _HEX_SYMBOLS = \\\"0123456789abcdef\\\";\\n    uint8 private constant _ADDRESS_LENGTH = 20;\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        // Inspired by OraclizeAPI's implementation - MIT licence\\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\\n\\n        if (value == 0) {\\n            return \\\"0\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 digits;\\n        while (temp != 0) {\\n            digits++;\\n            temp /= 10;\\n        }\\n        bytes memory buffer = new bytes(digits);\\n        while (value != 0) {\\n            digits -= 1;\\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\\n            value /= 10;\\n        }\\n        return string(buffer);\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(uint256 value) internal pure returns (string memory) {\\n        if (value == 0) {\\n            return \\\"0x00\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 length = 0;\\n        while (temp != 0) {\\n            length++;\\n            temp >>= 8;\\n        }\\n        return toHexString(value, length);\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\\n     */\\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\\n        bytes memory buffer = new bytes(2 * length + 2);\\n        buffer[0] = \\\"0\\\";\\n        buffer[1] = \\\"x\\\";\\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\\n            value >>= 4;\\n        }\\n        require(value == 0, \\\"Strings: hex length insufficient\\\");\\n        return string(buffer);\\n    }\\n\\n    /**\\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(address addr) internal pure returns (string memory) {\\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\\n    }\\n}\\n\"\r\n    },\r\n    \"base64-sol/base64.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0;\\n\\n/// @title Base64\\n/// @author Brecht Devos - <brecht@loopring.org>\\n/// @notice Provides functions for encoding/decoding base64\\nlibrary Base64 {\\n    string internal constant TABLE_ENCODE = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\\n    bytes  internal constant TABLE_DECODE = hex\\\"0000000000000000000000000000000000000000000000000000000000000000\\\"\\n                                            hex\\\"00000000000000000000003e0000003f3435363738393a3b3c3d000000000000\\\"\\n                                            hex\\\"00000102030405060708090a0b0c0d0e0f101112131415161718190000000000\\\"\\n                                            hex\\\"001a1b1c1d1e1f202122232425262728292a2b2c2d2e2f303132330000000000\\\";\\n\\n    function encode(bytes memory data) internal pure returns (string memory) {\\n        if (data.length == 0) return '';\\n\\n        // load the table into memory\\n        string memory table = TABLE_ENCODE;\\n\\n        // multiply by 4/3 rounded up\\n        uint256 encodedLen = 4 * ((data.length + 2) / 3);\\n\\n        // add some extra buffer at the end required for the writing\\n        string memory result = new string(encodedLen + 32);\\n\\n        assembly {\\n            // set the actual output length\\n            mstore(result, encodedLen)\\n\\n            // prepare the lookup table\\n            let tablePtr := add(table, 1)\\n\\n            // input ptr\\n            let dataPtr := data\\n            let endPtr := add(dataPtr, mload(data))\\n\\n            // result ptr, jump over length\\n            let resultPtr := add(result, 32)\\n\\n            // run over the input, 3 bytes at a time\\n            for {} lt(dataPtr, endPtr) {}\\n            {\\n                // read 3 bytes\\n                dataPtr := add(dataPtr, 3)\\n                let input := mload(dataPtr)\\n\\n                // write 4 characters\\n                mstore8(resultPtr, mload(add(tablePtr, and(shr(18, input), 0x3F))))\\n                resultPtr := add(resultPtr, 1)\\n                mstore8(resultPtr, mload(add(tablePtr, and(shr(12, input), 0x3F))))\\n                resultPtr := add(resultPtr, 1)\\n                mstore8(resultPtr, mload(add(tablePtr, and(shr( 6, input), 0x3F))))\\n                resultPtr := add(resultPtr, 1)\\n                mstore8(resultPtr, mload(add(tablePtr, and(        input,  0x3F))))\\n                resultPtr := add(resultPtr, 1)\\n            }\\n\\n            // padding with '='\\n            switch mod(mload(data), 3)\\n            case 1 { mstore(sub(resultPtr, 2), shl(240, 0x3d3d)) }\\n            case 2 { mstore(sub(resultPtr, 1), shl(248, 0x3d)) }\\n        }\\n\\n        return result;\\n    }\\n\\n    function decode(string memory _data) internal pure returns (bytes memory) {\\n        bytes memory data = bytes(_data);\\n\\n        if (data.length == 0) return new bytes(0);\\n        require(data.length % 4 == 0, \\\"invalid base64 decoder input\\\");\\n\\n        // load the table into memory\\n        bytes memory table = TABLE_DECODE;\\n\\n        // every 4 characters represent 3 bytes\\n        uint256 decodedLen = (data.length / 4) * 3;\\n\\n        // add some extra buffer at the end required for the writing\\n        bytes memory result = new bytes(decodedLen + 32);\\n\\n        assembly {\\n            // padding with '='\\n            let lastBytes := mload(add(data, mload(data)))\\n            if eq(and(lastBytes, 0xFF), 0x3d) {\\n                decodedLen := sub(decodedLen, 1)\\n                if eq(and(lastBytes, 0xFFFF), 0x3d3d) {\\n                    decodedLen := sub(decodedLen, 1)\\n                }\\n            }\\n\\n            // set the actual output length\\n            mstore(result, decodedLen)\\n\\n            // prepare the lookup table\\n            let tablePtr := add(table, 1)\\n\\n            // input ptr\\n            let dataPtr := data\\n            let endPtr := add(dataPtr, mload(data))\\n\\n            // result ptr, jump over length\\n            let resultPtr := add(result, 32)\\n\\n            // run over the input, 4 characters at a time\\n            for {} lt(dataPtr, endPtr) {}\\n            {\\n               // read 4 characters\\n               dataPtr := add(dataPtr, 4)\\n               let input := mload(dataPtr)\\n\\n               // write 3 bytes\\n               let output := add(\\n                   add(\\n                       shl(18, and(mload(add(tablePtr, and(shr(24, input), 0xFF))), 0xFF)),\\n                       shl(12, and(mload(add(tablePtr, and(shr(16, input), 0xFF))), 0xFF))),\\n                   add(\\n                       shl( 6, and(mload(add(tablePtr, and(shr( 8, input), 0xFF))), 0xFF)),\\n                               and(mload(add(tablePtr, and(        input , 0xFF))), 0xFF)\\n                    )\\n                )\\n                mstore(resultPtr, shl(232, output))\\n                resultPtr := add(resultPtr, 3)\\n            }\\n        }\\n\\n        return result;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/SVGRender.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\npragma solidity 0.8.15;\\n\\nimport { Base64 } from \\\"base64-sol/base64.sol\\\";\\nimport { Ownable } from \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport { Strings } from \\\"@openzeppelin/contracts/utils/Strings.sol\\\";\\nimport { svg } from \\\"./libraries/SVG.sol\\\";\\nimport { svgUtils } from \\\"./libraries/SVGUtils.sol\\\";\\nimport { SVGColor } from \\\"./libraries/SVGColor.sol\\\";\\n\\ncontract SVGRender is Ownable {\\n  using Strings for uint256;\\n  address public svgColor;\\n\\n  constructor(address _svgColor) {\\n    svgColor = _svgColor;\\n  }\\n\\n  function generate(uint256 _tokenId, string memory _alias) public view returns (string memory) {\\n    string memory _bgDef = svgUtils.getDefURL(\\\"charcoal\\\");\\n\\n    return\\n      string(\\n        abi.encodePacked(\\n          svg.start(),\\n          _getDefs(),\\n          svg.rect(\\n            string.concat(\\n              svg.prop(\\\"fill\\\", _bgDef),\\n              svg.prop(\\\"x\\\", \\\"0\\\"),\\n              svg.prop(\\\"y\\\", \\\"0\\\"),\\n              svg.prop(\\\"width\\\", \\\"100%\\\"),\\n              svg.prop(\\\"height\\\", \\\"100%\\\")\\n            ),\\n            svgUtils.NULL\\n          ),\\n          svg.text(\\n            string.concat(\\n              svg.prop(\\\"x\\\", \\\"50%\\\"),\\n              svg.prop(\\\"y\\\", \\\"50%\\\"),\\n              svg.prop(\\\"dominant-baseline\\\", \\\"middle\\\"),\\n              svg.prop(\\\"text-anchor\\\", \\\"middle\\\"),\\n              svg.prop(\\\"font-size\\\", \\\"48px\\\"),\\n              svg.prop(\\\"fill\\\", \\\"white\\\")\\n            ),\\n            string.concat(\\\"CIV #\\\", _tokenId.toString())\\n          ),\\n          svg.text(\\n            string.concat(\\n              svg.prop(\\\"x\\\", \\\"50%\\\"),\\n              svg.prop(\\\"y\\\", \\\"60%\\\"),\\n              svg.prop(\\\"dominant-baseline\\\", \\\"middle\\\"),\\n              svg.prop(\\\"text-anchor\\\", \\\"middle\\\"),\\n              svg.prop(\\\"font-size\\\", \\\"22px\\\"),\\n              svg.prop(\\\"fill\\\", \\\"white\\\")\\n            ),\\n            _alias\\n          ),\\n          svg.end()\\n        )\\n      );\\n  }\\n\\n  function _getDefs() internal view returns (string memory) {\\n    return\\n      svg.defs(\\n        string.concat(\\n          svg.linearGradient(\\n            string.concat(svg.prop(\\\"id\\\", \\\"charcoal\\\"), svg.prop(\\\"gradientTransform\\\", \\\"rotate(140)\\\")),\\n            string.concat(\\n              svg.stop(\\n                string.concat(\\n                  svg.prop(\\\"offset\\\", \\\"0%\\\"),\\n                  svg.prop(\\\"stop-color\\\", SVGColor(svgColor).getRgba(\\\"Dark1\\\"))\\n                )\\n              ),\\n              svg.stop(\\n                string.concat(\\n                  svg.prop(\\\"offset\\\", \\\"70%\\\"),\\n                  svg.prop(\\\"stop-color\\\", SVGColor(svgColor).getRgba(\\\"Dark2\\\"))\\n                )\\n              )\\n            )\\n          )\\n        )\\n      );\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/SVG.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: MIT\\npragma solidity ^0.8.13;\\nimport \\\"@openzeppelin/contracts/utils/Strings.sol\\\";\\nimport \\\"./SVGUtils.sol\\\";\\n\\n/**\\n * @title svg\\n * @author Kames Geraghty\\n * @notice SVG construction library using web-like API.\\n * @dev Original code from w1nt3r-eth/hot-chain-svg (https://github.com/w1nt3r-eth/hot-chain-svg)\\n */\\nlibrary svg {\\n  using Strings for uint256;\\n  using Strings for uint8;\\n\\n  function g(string memory _props, string memory _children) internal pure returns (string memory) {\\n    return el(\\\"g\\\", _props, _children);\\n  }\\n\\n  function path(string memory _props, string memory _children)\\n    internal\\n    pure\\n    returns (string memory)\\n  {\\n    return el(\\\"path\\\", _props, _children);\\n  }\\n\\n  function text(string memory _props, string memory _children)\\n    internal\\n    pure\\n    returns (string memory)\\n  {\\n    return el(\\\"text\\\", _props, _children);\\n  }\\n\\n  function line(string memory _props, string memory _children)\\n    internal\\n    pure\\n    returns (string memory)\\n  {\\n    return el(\\\"line\\\", _props, _children);\\n  }\\n\\n  function circle(string memory _props, string memory _children)\\n    internal\\n    pure\\n    returns (string memory)\\n  {\\n    return el(\\\"circle\\\", _props, _children);\\n  }\\n\\n  function circle(string memory _props) internal pure returns (string memory) {\\n    return el(\\\"circle\\\", _props);\\n  }\\n\\n  function rect(string memory _props, string memory _children)\\n    internal\\n    pure\\n    returns (string memory)\\n  {\\n    return el(\\\"rect\\\", _props, _children);\\n  }\\n\\n  function rect(string memory _props) internal pure returns (string memory) {\\n    return el(\\\"rect\\\", _props);\\n  }\\n\\n  function stop(string memory _props) internal pure returns (string memory) {\\n    return el(\\\"stop\\\", _props);\\n  }\\n\\n  function filter(string memory _props, string memory _children)\\n    internal\\n    pure\\n    returns (string memory)\\n  {\\n    return el(\\\"filter\\\", _props, _children);\\n  }\\n\\n  function defs(string memory _children) internal pure returns (string memory) {\\n    return el(\\\"defs\\\", \\\"\\\", _children);\\n  }\\n\\n  function cdata(string memory _content) internal pure returns (string memory) {\\n    return string.concat(\\\"<![CDATA[\\\", _content, \\\"]]>\\\");\\n  }\\n\\n  /* GRADIENTS */\\n  function radialGradient(string memory _props, string memory _children)\\n    internal\\n    pure\\n    returns (string memory)\\n  {\\n    return el(\\\"radialGradient\\\", _props, _children);\\n  }\\n\\n  function linearGradient(string memory _props, string memory _children)\\n    internal\\n    pure\\n    returns (string memory)\\n  {\\n    return el(\\\"linearGradient\\\", _props, _children);\\n  }\\n\\n  function gradientStop(\\n    uint256 offset,\\n    string memory stopColor,\\n    string memory _props\\n  ) internal pure returns (string memory) {\\n    return\\n      el(\\n        \\\"stop\\\",\\n        string.concat(\\n          prop(\\\"stop-color\\\", stopColor),\\n          \\\" \\\",\\n          prop(\\\"offset\\\", string.concat(svgUtils.uint2str(offset), \\\"%\\\")),\\n          \\\" \\\",\\n          _props\\n        )\\n      );\\n  }\\n\\n  function animateTransform(string memory _props) internal pure returns (string memory) {\\n    return el(\\\"animateTransform\\\", _props);\\n  }\\n\\n  function image(string memory _href, string memory _props) internal pure returns (string memory) {\\n    return el(\\\"image\\\", string.concat(prop(\\\"href\\\", _href), \\\" \\\", _props));\\n  }\\n\\n  function start() internal pure returns (string memory) {\\n    return\\n      string.concat(\\n        '<svg width=\\\"400\\\" height=\\\"400\\\" style=\\\"background:#541563\\\" ',\\n        'viewBox=\\\"0 0 400 400\\\" ',\\n        'xmlns=\\\"http://www.w3.org/2000/svg\\\" ',\\n        \\\">\\\"\\n      );\\n  }\\n\\n  function end() internal pure returns (bytes memory) {\\n    return (\\\"</svg>\\\");\\n  }\\n\\n  /* COMMON */\\n  // A generic element, can be used to construct any SVG (or HTML) element\\n  function el(\\n    string memory _tag,\\n    string memory _props,\\n    string memory _children\\n  ) internal pure returns (string memory) {\\n    return string.concat(\\\"<\\\", _tag, \\\" \\\", _props, \\\">\\\", _children, \\\"</\\\", _tag, \\\">\\\");\\n  }\\n\\n  // A generic element, can be used to construct any SVG (or HTML) element without children\\n  function el(string memory _tag, string memory _props) internal pure returns (string memory) {\\n    return string.concat(\\\"<\\\", _tag, \\\" \\\", _props, \\\"/>\\\");\\n  }\\n\\n  // an SVG attribute\\n  function prop(string memory _key, string memory _val) internal pure returns (string memory) {\\n    return string.concat(_key, \\\"=\\\", '\\\"', _val, '\\\" ');\\n  }\\n\\n  function stringifyIntSet(\\n    bytes memory _data,\\n    uint256 _offset,\\n    uint256 _len\\n  ) public pure returns (bytes memory) {\\n    bytes memory res;\\n    require(_data.length >= _offset + _len, \\\"Out of range\\\");\\n    for (uint256 i = _offset; i < _offset + _len; i++) {\\n      res = abi.encodePacked(res, byte2uint8(_data, i).toString(), \\\" \\\");\\n    }\\n    return res;\\n  }\\n\\n  function byte2uint8(bytes memory _data, uint256 _offset) public pure returns (uint8) {\\n    require(_data.length > _offset, \\\"Out of range\\\");\\n    return uint8(_data[_offset]);\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/SVGColor.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.13;\\nimport \\\"@openzeppelin/contracts/utils/Strings.sol\\\";\\n\\ncontract SVGColor {\\n  using Strings for uint256;\\n  using Strings for uint8;\\n\\n  mapping(string => bytes) public colors;\\n\\n  constructor() {\\n    colors[\\\"Black\\\"] = hex\\\"000000\\\";\\n    colors[\\\"White\\\"] = hex\\\"FFFFFF\\\";\\n    colors[\\\"Dark1\\\"] = hex\\\"232323\\\";\\n    colors[\\\"Dark2\\\"] = hex\\\"464646\\\";\\n  }\\n\\n  function getColor(string memory _colorName) public view returns (bytes memory) {\\n    require(colors[_colorName].length == 3, \\\"Unknown color\\\");\\n    return abi.encodePacked(colors[_colorName], hex\\\"64\\\");\\n  }\\n\\n  function getColor(string memory _colorName, uint8 _alpha) public view returns (bytes memory) {\\n    require(colors[_colorName].length == 3, \\\"Unknown color\\\");\\n    return abi.encodePacked(colors[_colorName], _alpha);\\n  }\\n\\n  function getRgba(string memory _colorName) public view returns (string memory) {\\n    return string(toRgba(getColor(_colorName), 0));\\n  }\\n\\n  // Input: array of colors (without alpha)\\n  // Ouputs a linearGradient\\n  function autoLinearGradient(\\n    bytes memory _colors,\\n    bytes memory _id,\\n    bytes memory _customAttributes\\n  ) public view returns (bytes memory) {\\n    return this.autoLinearGradient(\\\"\\\", _colors, _id, _customAttributes);\\n  }\\n\\n  function autoLinearGradient(\\n    bytes memory _coordinates,\\n    bytes memory _colors,\\n    bytes memory _id,\\n    bytes memory _customAttributes\\n  ) external view returns (bytes memory) {\\n    bytes memory _b;\\n    if (_coordinates.length > 3) {\\n      _b = abi.encodePacked(uint8(128), _coordinates);\\n    } else {\\n      _b = hex\\\"00\\\";\\n    }\\n    // Count the number of colors passed, each on 4 byte\\n    uint256 colorCount = _colors.length / 4;\\n    uint8 i = 0;\\n    while (i < colorCount) {\\n      _b = abi.encodePacked(\\n        _b,\\n        uint8(i * (100 / (colorCount - 1))), // grad. stop %\\n        uint8(_colors[i * 4]),\\n        uint8(_colors[i * 4 + 1]),\\n        uint8(_colors[i * 4 + 2]),\\n        uint8(_colors[i * 4 + 3])\\n      );\\n      i++;\\n    }\\n    return linearGradient(_b, _id, _customAttributes);\\n  }\\n\\n  function linearGradient(\\n    bytes memory _lg,\\n    bytes memory _id,\\n    bytes memory _customAttributes\\n  ) public pure returns (bytes memory) {\\n    bytes memory grdata;\\n    uint8 offset = 1;\\n\\n    if (uint8(_lg[0]) & 128 == 128) {\\n      grdata = abi.encodePacked(\\n        'x1=\\\"',\\n        byte2uint8(_lg, 1).toString(),\\n        '%\\\" x2=\\\"',\\n        byte2uint8(_lg, 2).toString(),\\n        '%\\\" y1=\\\"',\\n        byte2uint8(_lg, 3).toString(),\\n        '%\\\" y2=\\\"',\\n        byte2uint8(_lg, 4).toString(),\\n        '%\\\"'\\n      );\\n      offset = 5;\\n    }\\n    grdata = abi.encodePacked('<linearGradient id=\\\"', _id, '\\\" ', _customAttributes, grdata, \\\">\\\");\\n    for (uint256 i = offset; i < _lg.length; i += 5) {\\n      grdata = abi.encodePacked(\\n        grdata,\\n        '<stop offset=\\\"',\\n        byte2uint8(_lg, i).toString(),\\n        '%\\\" stop-color=\\\"',\\n        toRgba(_lg, i + 1),\\n        '\\\" id=\\\"',\\n        _id,\\n        byte2uint8(_lg, i).toString(),\\n        '\\\"/>'\\n      );\\n    }\\n    return abi.encodePacked(grdata, \\\"</linearGradient>\\\");\\n  }\\n\\n  function toRgba(bytes memory _rgba, uint256 offset) public pure returns (bytes memory) {\\n    return\\n      abi.encodePacked(\\n        \\\"rgba(\\\",\\n        byte2uint8(_rgba, offset).toString(),\\n        \\\",\\\",\\n        byte2uint8(_rgba, offset + 1).toString(),\\n        \\\",\\\",\\n        byte2uint8(_rgba, offset + 2).toString(),\\n        \\\",\\\",\\n        byte2uint8(_rgba, offset + 3).toString(),\\n        \\\"%)\\\"\\n      );\\n  }\\n\\n  function byte2uint8(bytes memory _data, uint256 _offset) public pure returns (uint8) {\\n    require(_data.length > _offset, \\\"Out of range\\\");\\n    return uint8(_data[_offset]);\\n  }\\n\\n  // formats rgba white with a specified opacity / alpha\\n  function white_a(uint256 _a) internal pure returns (string memory) {\\n    return rgba(255, 255, 255, _a);\\n  }\\n\\n  // formats rgba black with a specified opacity / alpha\\n  function black_a(uint256 _a) internal pure returns (string memory) {\\n    return rgba(0, 0, 0, _a);\\n  }\\n\\n  // formats generic rgba color in css\\n  function rgba(\\n    uint256 _r,\\n    uint256 _g,\\n    uint256 _b,\\n    uint256 _a\\n  ) internal pure returns (string memory) {\\n    string memory formattedA = _a < 100 ? string.concat(\\\"0.\\\", uint2str(_a)) : \\\"1\\\";\\n    return\\n      string.concat(\\n        \\\"rgba(\\\",\\n        uint2str(_r),\\n        \\\",\\\",\\n        uint2str(_g),\\n        \\\",\\\",\\n        uint2str(_b),\\n        \\\",\\\",\\n        formattedA,\\n        \\\")\\\"\\n      );\\n  }\\n\\n  function uint2str(uint256 _i) internal pure returns (string memory _uintAsString) {\\n    if (_i == 0) {\\n      return \\\"0\\\";\\n    }\\n    uint256 j = _i;\\n    uint256 len;\\n    while (j != 0) {\\n      len++;\\n      j /= 10;\\n    }\\n    bytes memory bstr = new bytes(len);\\n    uint256 k = len;\\n    while (_i != 0) {\\n      k = k - 1;\\n      uint8 temp = (48 + uint8(_i - (_i / 10) * 10));\\n      bytes1 b1 = bytes1(temp);\\n      bstr[k] = b1;\\n      _i /= 10;\\n    }\\n    return string(bstr);\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/SVGUtils.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: MIT\\npragma solidity ^0.8.13;\\nimport \\\"@openzeppelin/contracts/utils/Strings.sol\\\";\\n/**\\n  * @title  SVG Utilities\\n  * @author Kames Geraghty\\n  * @notice The SVG Utilities Library provides functions for constructing SVG; format CSS and numbers.\\n  * @dev Original code from w1nt3r-eth/hot-chain-svg (https://github.com/w1nt3r-eth/hot-chain-svg)\\n*/\\nlibrary svgUtils {\\n    using Strings for uint256;\\n    using Strings for uint8;\\n    \\n    /// @notice Empty SVG element\\n    string internal constant NULL = \\\"\\\";\\n\\n    /**\\n     * @notice Formats a CSS variable line. Includes a semicolon for formatting.\\n     * @param _key User for which to calculate prize amount.\\n     * @param _val User for which to calculate prize amount.\\n     * @return string Generated CSS variable.\\n    */\\n    function setCssVar(string memory _key, string memory _val)\\n        internal\\n        pure\\n        returns (string memory)\\n    {\\n        return string.concat(\\\"--\\\", _key, \\\":\\\", _val, \\\";\\\");\\n    }\\n\\n    /**\\n     * @notice Formats getting a css variable\\n     * @param _key User for which to calculate prize amount.\\n     * @return string Generated CSS variable.\\n    */\\n    function getCssVar(string memory _key)\\n        internal\\n        pure\\n        returns (string memory)\\n    {\\n        return string.concat(\\\"var(--\\\", _key, \\\")\\\");\\n    }\\n\\n    // formats getting a def URL\\n    function getDefURL(string memory _id)\\n        internal\\n        pure\\n        returns (string memory)\\n    {\\n        return string.concat(\\\"url(#\\\", _id, \\\")\\\");\\n    }\\n\\n    // checks if two strings are equal\\n    function stringsEqual(string memory _a, string memory _b)\\n        internal\\n        pure\\n        returns (bool)\\n    {\\n        return\\n            keccak256(abi.encodePacked(_a)) == keccak256(abi.encodePacked(_b));\\n    }\\n\\n    // returns the length of a string in characters\\n    function utfStringLength(string memory _str)\\n        internal\\n        pure\\n        returns (uint256 length)\\n    {\\n        uint256 i = 0;\\n        bytes memory string_rep = bytes(_str);\\n\\n        while (i < string_rep.length) {\\n            if (string_rep[i] >> 7 == 0) i += 1;\\n            else if (string_rep[i] >> 5 == bytes1(uint8(0x6))) i += 2;\\n            else if (string_rep[i] >> 4 == bytes1(uint8(0xE))) i += 3;\\n            else if (string_rep[i] >> 3 == bytes1(uint8(0x1E)))\\n                i += 4;\\n                //For safety\\n            else i += 1;\\n\\n            length++;\\n        }\\n    }\\n\\n    function round2Txt(\\n        uint256 _value,\\n        uint8 _decimals,\\n        uint8 _prec\\n    ) internal pure returns (bytes memory) {\\n        return abi.encodePacked(\\n            (_value / 10 ** _decimals).toString(), \\n            \\\".\\\",\\n            ( _value / 10 ** (_decimals - _prec) -\\n                _value / 10 ** (_decimals ) * 10 ** _prec\\n            ).toString()\\n        );\\n    }\\n\\n     // converts an unsigned integer to a string\\n     function uint2str(uint256 _i)\\n     internal\\n     pure\\n     returns (string memory _uintAsString)\\n {\\n     if (_i == 0) {\\n         return \\\"0\\\";\\n     }\\n     uint256 j = _i;\\n     uint256 len;\\n     while (j != 0) {\\n         len++;\\n         j /= 10;\\n     }\\n     bytes memory bstr = new bytes(len);\\n     uint256 k = len;\\n     while (_i != 0) {\\n         k = k - 1;\\n         uint8 temp = (48 + uint8(_i - (_i / 10) * 10));\\n         bytes1 b1 = bytes1(temp);\\n         bstr[k] = b1;\\n         _i /= 10;\\n     }\\n     return string(bstr);\\n }\\n}\\n\"\r\n    }\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_svgColor\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"_alias\",\"type\":\"string\"}],\"name\":\"generate\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"svgColor\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"SVGRender","CompilerVersion":"v0.8.15+commit.e14f2714","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000bfa9c6f96cbf4035a3ec79b6512972c1618ccab2","EVMVersion":"Default","Library":"","LicenseType":"GNU GPLv3","Proxy":"0","Implementation":"","SwarmSource":""}]}