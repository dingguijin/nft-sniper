{"status":"1","message":"OK","result":[{"SourceCode":"// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.4;\r\n\r\ninterface IERC20 {\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    function transfer(address to, uint256 amount) external returns (bool);\r\n\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n}\r\n\r\ncontract Ownable {\r\n    address public owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n    constructor(){\r\n        owner = msg.sender;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n   */\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param newOwner The address to transfer ownership to.\r\n   */\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        require(newOwner != address(0));\r\n        emit OwnershipTransferred(owner, newOwner);\r\n        owner = newOwner;\r\n    }\r\n\r\n}\r\n\r\n/**\r\n * @dev Contract module that helps prevent reentrant calls to a function.\r\n *\r\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\r\n * available, which can be applied to functions to make sure there are no nested\r\n * (reentrant) calls to them.\r\n *\r\n * Note that because there is a single `nonReentrant` guard, functions marked as\r\n * `nonReentrant` may not call one another. This can be worked around by making\r\n * those functions `private`, and then adding `external` `nonReentrant` entry\r\n * points to them.\r\n *\r\n * TIP: If you would like to learn more about reentrancy and alternative ways\r\n * to protect against it, check out our blog post\r\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\r\n */\r\nabstract contract ReentrancyGuard {\r\n    // Booleans are more expensive than uint256 or any type that takes up a full\r\n    // word because each write operation emits an extra SLOAD to first read the\r\n    // slot's contents, replace the bits taken up by the boolean, and then write\r\n    // back. This is the compiler's defense against contract upgrades and\r\n    // pointer aliasing, and it cannot be disabled.\r\n\r\n    // The values being non-zero value makes deployment a bit more expensive,\r\n    // but in exchange the refund on every call to nonReentrant will be lower in\r\n    // amount. Since refunds are capped to a percentage of the total\r\n    // transaction's gas, it is best to keep them low in cases like this one, to\r\n    // increase the likelihood of the full refund coming into effect.\r\n    uint256 private constant _NOT_ENTERED = 1;\r\n    uint256 private constant _ENTERED = 2;\r\n\r\n    uint256 private _status;\r\n\r\n    constructor() {\r\n        _status = _NOT_ENTERED;\r\n    }\r\n\r\n    /**\r\n     * @dev Prevents a contract from calling itself, directly or indirectly.\r\n     * Calling a `nonReentrant` function from another `nonReentrant`\r\n     * function is not supported. It is possible to prevent this from happening\r\n     * by making the `nonReentrant` function external, and making it call a\r\n     * `private` function that does the actual work.\r\n     */\r\n    modifier nonReentrant() {\r\n        // On the first call to nonReentrant, _notEntered will be true\r\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\r\n\r\n        // Any calls to nonReentrant after this point will fail\r\n        _status = _ENTERED;\r\n\r\n        _;\r\n\r\n        // By storing the original value once again, a refund is triggered (see\r\n        // https://eips.ethereum.org/EIPS/eip-2200)\r\n        _status = _NOT_ENTERED;\r\n    }\r\n}\r\n\r\n/**\r\n* @notice Stakeable is a contract who is ment to be inherited by other contract that wants Staking capabilities\r\n*/\r\ncontract Stakeable is Ownable, ReentrancyGuard {\r\n\r\n    IERC20 Token;\r\n    uint public totalStaked;\r\n    uint startTime;\r\n\r\n    uint firstRoundTime = 4380 hours;\r\n    uint secondRoundTime = 8760 hours;\r\n    uint thirdRoundTime = 13140 hours;\r\n    uint fourthRoundTime = 21900 hours;\r\n    uint fifthRoundTime = 21900 hours;\r\n\r\n    uint8 firstRoundRewardPercent = 95;\r\n    uint8 secondRoundRewardPercent = 70;\r\n    uint8 thirdRoundRewardPercent = 45;\r\n    uint8 fourthRoundRewardPercent = 20;\r\n    uint8 fifthRoundRewardPercent = 10;\r\n\r\n\r\n    /**\r\n    * @notice Constructor since this contract is not ment to be used without inheritance\r\n    * push once to stakeholders for it to work proplerly\r\n     */\r\n    constructor(address _tokenAddress) {\r\n        // Create token interface\r\n        Token = IERC20(_tokenAddress);\r\n\r\n        startTime = block.timestamp;\r\n        // This push is needed so we avoid index 0 causing bug of index-1\r\n        stakeholders.push();\r\n    }\r\n\r\n    struct Stake{\r\n        address user;\r\n        uint256 amount;\r\n        uint256 since;\r\n        uint percent;\r\n        uint256 claimable;\r\n        uint256 withdrawDelay;\r\n    }\r\n\r\n    struct Stakeholder{\r\n        address user;\r\n        Stake[] address_stakes;\r\n    }\r\n\r\n    struct StakingSummary{\r\n        uint256 total_amount;\r\n        Stake[] stakes;\r\n    }\r\n\r\n    Stakeholder[] internal stakeholders;\r\n\r\n    mapping(address => uint256) internal stakes;\r\n\r\n    event Staked(address indexed user, uint256 amount, uint256 index, uint256 timestamp);\r\n\r\n    modifier checkAllowance(uint amount) {\r\n        require(Token.allowance(msg.sender, address(this)) >= amount, \"Error\");\r\n        _;\r\n    }\r\n\r\n    function getRewardPercent()internal view returns (uint8) {\r\n        uint passedTime = block.timestamp - startTime;\r\n        uint8 percent;\r\n        if(passedTime < firstRoundTime){\r\n            percent = firstRoundRewardPercent;\r\n        } else if (passedTime < secondRoundTime) {\r\n            percent = secondRoundRewardPercent;\r\n        } else if(passedTime < thirdRoundTime){\r\n            percent = thirdRoundRewardPercent;\r\n        } else if(passedTime < fourthRoundTime){\r\n            percent = fourthRoundRewardPercent;\r\n        } else if(passedTime > fifthRoundTime){\r\n            percent = fifthRoundRewardPercent;\r\n        }\r\n        return percent;\r\n    }\r\n\r\n    function _addStakeholder(address staker) internal returns (uint256){\r\n        stakeholders.push();\r\n        uint256 userIndex = stakeholders.length - 1;\r\n        stakeholders[userIndex].user = staker;\r\n        stakes[staker] = userIndex;\r\n        return userIndex;\r\n    }\r\n\r\n    function _stake(uint256 _amount) internal{\r\n        require(_amount > 0, \"Cannot stake nothing\");\r\n        uint256 index = stakes[msg.sender];\r\n        uint256 timestamp = block.timestamp;\r\n        uint8 percent = getRewardPercent();\r\n        if(index == 0){\r\n            index = _addStakeholder(msg.sender);\r\n        }\r\n\r\n        stakeholders[index].address_stakes.push(Stake(msg.sender, _amount, timestamp, percent, 0, 0));\r\n\r\n        emit Staked(msg.sender, _amount, index, timestamp);\r\n    }\r\n\r\n    function _calculatePercent(uint amount, uint percent)internal pure returns (uint )  {\r\n        return amount * percent * 100/10000  ;\r\n    }\r\n\r\n    function _calculateFee(uint amount, uint percent) internal pure returns(uint){\r\n        uint rewardPerYear = _calculatePercent(amount, percent);\r\n        uint rewardPerHoer = rewardPerYear / 8760;\r\n        return rewardPerHoer;\r\n    }\r\n\r\n    function calculateStakeReward(Stake memory _current_stake) internal view returns(uint256){\r\n        uint percent = _current_stake.percent;\r\n        uint rewardPerHour = _calculateFee(_current_stake.amount, percent);\r\n        return (((block.timestamp - _current_stake.since) / 1 hours) * rewardPerHour);\r\n    }\r\n\r\n    function _withdrawStake(uint256 amount, uint256 index) internal returns (uint256){\r\n        uint256 user_index = stakes[msg.sender];\r\n\r\n        Stake memory current_stake = stakeholders[user_index].address_stakes[index];\r\n        require(current_stake.since + 14 days < block.timestamp, \"Stakeable: Less than 14 days have passed since the steak was placed\");\r\n        if (current_stake.withdrawDelay + 14 days < block.timestamp && current_stake.withdrawDelay != 0){\r\n            stakeholders[user_index].address_stakes[index].since = block.timestamp;\r\n        }\r\n\r\n        if (current_stake.withdrawDelay == 0){\r\n            stakeholders[user_index].address_stakes[index].withdrawDelay = block.timestamp;\r\n            return 0;\r\n        }\r\n\r\n        require(current_stake.withdrawDelay + 14 days < block.timestamp, \"Stakeable: 14 day delay after confirmation of staking withdrawal has not passed\");\r\n        require(current_stake.amount >= amount, \"Stakeable: Cannot withdraw more than you have staked\");\r\n\r\n        uint256 reward = calculateStakeReward(current_stake);\r\n        current_stake.amount = current_stake.amount - amount;\r\n        if(current_stake.amount == 0){\r\n            delete stakeholders[user_index].address_stakes[index];\r\n        }else {\r\n            stakeholders[user_index].address_stakes[index].amount = current_stake.amount;\r\n            stakeholders[user_index].address_stakes[index].since = block.timestamp;\r\n        }\r\n        return amount + reward;\r\n    }\r\n\r\n    function hasStake(address _staker) external view returns(StakingSummary memory){\r\n        uint256 totalStakeAmount;\r\n        StakingSummary memory summary = StakingSummary(0, stakeholders[stakes[_staker]].address_stakes);\r\n\r\n        for (uint256 s = 0; s < summary.stakes.length; s += 1){\r\n            uint256 availableReward = calculateStakeReward(summary.stakes[s]);\r\n            summary.stakes[s].claimable = availableReward;\r\n            totalStakeAmount = totalStakeAmount+summary.stakes[s].amount;\r\n        }\r\n\r\n        summary.total_amount = totalStakeAmount;\r\n        return summary;\r\n    }\r\n\r\n\r\n    function stake(uint256 _amount) external nonReentrant checkAllowance(_amount){\r\n        require(_amount <= Token.balanceOf(msg.sender), \"Stakeable: Cannot stake more than you own\");\r\n        _stake(_amount);\r\n        Token.transferFrom(msg.sender, address(this), _amount);\r\n        totalStaked += _amount;\r\n    }\r\n\r\n    function withdrawStake(uint256 amount, uint256 stake_index) external nonReentrant  {\r\n        uint256 amount_to_mint = _withdrawStake(amount, stake_index);\r\n        if(amount_to_mint == 0){\r\n\r\n            } else {\r\n            Token.approve(address(this), amount_to_mint);\r\n            Token.transferFrom(address(this), msg.sender, amount_to_mint);\r\n            totalStaked -= amount;\r\n        }\r\n\r\n    }\r\n\r\n    function refundTokens(address _recipient, address _token) external onlyOwner {\r\n        require(_token != address (Token), \"Stakeable: You cannot debit the rex token using this function. Rex token is withdrawn using the withdraw function\");\r\n        IERC20 token = IERC20(_token);\r\n        require(token.balanceOf(address(this)) > 0, 'Stakeable: No tokens');\r\n        uint256 balance = token.balanceOf(address(this));\r\n        require(balance > 0);\r\n        require(token.transfer(_recipient, balance));\r\n    }\r\n\r\n    receive () external payable {\r\n        revert(\"Stakeable: You cannot send ether to the address of this contract!\");\r\n    }\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenAddress\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"Staked\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_staker\",\"type\":\"address\"}],\"name\":\"hasStake\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"total_amount\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"since\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"percent\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"claimable\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"withdrawDelay\",\"type\":\"uint256\"}],\"internalType\":\"struct Stakeable.Stake[]\",\"name\":\"stakes\",\"type\":\"tuple[]\"}],\"internalType\":\"struct Stakeable.StakingSummary\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_recipient\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"refundTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"stake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalStaked\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"stake_index\",\"type\":\"uint256\"}],\"name\":\"withdrawStake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]","ContractName":"Stakeable","CompilerVersion":"v0.8.4+commit.c7e474f2","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000005bf844122db21ae6f787ddda9806aa7dd6489998","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"ipfs://a102e19955b9b3cf59e074f91492a6ae2d7a32c7f5043b4be74b7f7e104ffdc2"}]}