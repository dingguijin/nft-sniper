{"status":"1","message":"OK","result":[{"SourceCode":"//SPDX-License-Identifier: MIT\r\npragma solidity 0.8.14;\r\n\r\n/**\r\n * @title Owner\r\n * @dev Set & change owner\r\n */\r\ncontract Ownable {\r\n\r\n    address private owner;\r\n    \r\n    // event for EVM logging\r\n    event OwnerSet(address indexed oldOwner, address indexed newOwner);\r\n    \r\n    // modifier to check if caller is owner\r\n    modifier onlyOwner() {\r\n        // If the first argument of 'require' evaluates to 'false', execution terminates and all\r\n        // changes to the state and to Ether balances are reverted.\r\n        // This used to consume all gas in old EVM versions, but not anymore.\r\n        // It is often a good idea to use 'require' to check if functions are called correctly.\r\n        // As a second argument, you can also provide an explanation about what went wrong.\r\n        require(msg.sender == owner, \"Caller is not owner\");\r\n        _;\r\n    }\r\n    \r\n    /**\r\n     * @dev Set contract deployer as owner\r\n     */\r\n    constructor() {\r\n        owner = msg.sender; // 'msg.sender' is sender of current call, contract deployer for a constructor\r\n        emit OwnerSet(address(0), owner);\r\n    }\r\n\r\n    /**\r\n     * @dev Change owner\r\n     * @param newOwner address of new owner\r\n     */\r\n    function changeOwner(address newOwner) public onlyOwner {\r\n        emit OwnerSet(owner, newOwner);\r\n        owner = newOwner;\r\n    }\r\n\r\n    /**\r\n     * @dev Return owner address \r\n     * @return address of owner\r\n     */\r\n    function getOwner() external view returns (address) {\r\n        return owner;\r\n    }\r\n}\r\n\r\ncontract PaymentReceiver is Ownable {\r\n\r\n    // Address -> Allocation\r\n    mapping ( address => uint256 ) public allocations;\r\n\r\n    // All Payees With An Allocation\r\n    address[] public payees;\r\n\r\n    // Total Allocation\r\n    uint256 public totalAllocation;\r\n\r\n    function withdraw() external onlyOwner {\r\n        (bool s,) = payable(msg.sender).call{value: address(this).balance}(\"\");\r\n        require(s, 'Failure to withdraw');\r\n    }\r\n\r\n    function registerPayee(address payee, uint256 allocation) external onlyOwner {\r\n        require(\r\n            allocations[payee] == 0,\r\n            'Already Registered'\r\n        );\r\n        payees.push(payee);\r\n        totalAllocation += allocation;\r\n        allocations[payee] = allocation;\r\n    }\r\n\r\n    function removePayee(address payee) external onlyOwner {\r\n        uint index = payees.length + 1;\r\n        for (uint i = 0; i < payees.length; i++) {\r\n            if (payees[i] == payee) {\r\n                index = i;\r\n                break;\r\n            }\r\n        }\r\n        require(\r\n            index < payees.length,\r\n            'Index Not Found'\r\n        );\r\n\r\n        payees[index] = payees[payees.length - 1];\r\n        payees.pop();\r\n\r\n        totalAllocation -= allocations[payee];\r\n        delete allocations[payee];\r\n    }\r\n\r\n    function distribute() external onlyOwner {\r\n        _distribute();\r\n    }\r\n\r\n    function _distribute() internal {\r\n\r\n        uint bal = address(this).balance;\r\n        if (bal == 0) {\r\n            return;\r\n        }\r\n\r\n        for (uint i = 0; i < payees.length; i++) {\r\n            uint amt = bal * allocations[payees[i]] / totalAllocation;\r\n            if (amt > address(this).balance) {\r\n                amt = address(this).balance;\r\n            }\r\n            if (amt > 0) {\r\n                (bool s,) = payable(payees[i]).call{value: amt}(\"\");\r\n                require(s, 'Failure On ETH Transfer');\r\n            }\r\n        }\r\n    }\r\n\r\n    receive() external payable {}\r\n}","ABI":"[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"oldOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnerSet\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"allocations\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"changeOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"distribute\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"payees\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"payee\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"allocation\",\"type\":\"uint256\"}],\"name\":\"registerPayee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"payee\",\"type\":\"address\"}],\"name\":\"removePayee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalAllocation\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]","ContractName":"PaymentReceiver","CompilerVersion":"v0.8.14+commit.80d49f37","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"ipfs://a1b3ff059c7dca13afb6fea2c015644e5ba3115d9aa7d1a4b3be2031c97e74b3"}]}