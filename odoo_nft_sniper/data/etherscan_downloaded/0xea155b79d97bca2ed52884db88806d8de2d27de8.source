{"status":"1","message":"OK","result":[{"SourceCode":"/**\r\n *Submitted for verification at BscScan.com on 2022-03-27\r\n*/\r\n\r\n// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n */\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes calldata) {\r\n        return msg.data;\r\n    }\r\n}\r\n\r\n/**\r\n * @dev Library for managing\r\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\r\n * types.\r\n *\r\n * Sets have the following properties:\r\n *\r\n * - Elements are added, removed, and checked for existence in constant time\r\n * (O(1)).\r\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\r\n *\r\n * ```\r\n * contract Example {\r\n *     // Add the library methods\r\n *     using EnumerableSet for EnumerableSet.AddressSet;\r\n *\r\n *     // Declare a set state variable\r\n *     EnumerableSet.AddressSet private mySet;\r\n * }\r\n * ```\r\n *\r\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\r\n * and `uint256` (`UintSet`) are supported.\r\n */\r\nlibrary EnumerableSet {\r\n    // To implement this library for multiple types with as little code\r\n    // repetition as possible, we write it in terms of a generic Set type with\r\n    // bytes32 values.\r\n    // The Set implementation uses private functions, and user-facing\r\n    // implementations (such as AddressSet) are just wrappers around the\r\n    // underlying Set.\r\n    // This means that we can only create new EnumerableSets for types that fit\r\n    // in bytes32.\r\n\r\n    struct Set {\r\n        // Storage of set values\r\n        bytes32[] _values;\r\n        // Position of the value in the `values` array, plus 1 because index 0\r\n        // means a value is not in the set.\r\n        mapping(bytes32 => uint256) _indexes;\r\n    }\r\n\r\n    /**\r\n     * @dev Add a value to a set. O(1).\r\n     *\r\n     * Returns true if the value was added to the set, that is if it was not\r\n     * already present.\r\n     */\r\n    function _add(Set storage set, bytes32 value) private returns (bool) {\r\n        if (!_contains(set, value)) {\r\n            set._values.push(value);\r\n            // The value is stored at length-1, but we add 1 to all indexes\r\n            // and use 0 as a sentinel value\r\n            set._indexes[value] = set._values.length;\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Removes a value from a set. O(1).\r\n     *\r\n     * Returns true if the value was removed from the set, that is if it was\r\n     * present.\r\n     */\r\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\r\n        // We read and store the value's index to prevent multiple reads from the same storage slot\r\n        uint256 valueIndex = set._indexes[value];\r\n\r\n        if (valueIndex != 0) {\r\n            // Equivalent to contains(set, value)\r\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\r\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\r\n            // This modifies the order of the array, as noted in {at}.\r\n\r\n            uint256 toDeleteIndex = valueIndex - 1;\r\n            uint256 lastIndex = set._values.length - 1;\r\n\r\n            if (lastIndex != toDeleteIndex) {\r\n                bytes32 lastvalue = set._values[lastIndex];\r\n\r\n                // Move the last value to the index where the value to delete is\r\n                set._values[toDeleteIndex] = lastvalue;\r\n                // Update the index for the moved value\r\n                set._indexes[lastvalue] = valueIndex; // Replace lastvalue's index to valueIndex\r\n            }\r\n\r\n            // Delete the slot where the moved value was stored\r\n            set._values.pop();\r\n\r\n            // Delete the index for the deleted slot\r\n            delete set._indexes[value];\r\n\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the value is in the set. O(1).\r\n     */\r\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\r\n        return set._indexes[value] != 0;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the number of values on the set. O(1).\r\n     */\r\n    function _length(Set storage set) private view returns (uint256) {\r\n        return set._values.length;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the value stored at position `index` in the set. O(1).\r\n     *\r\n     * Note that there are no guarantees on the ordering of values inside the\r\n     * array, and it may change when more values are added or removed.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `index` must be strictly less than {length}.\r\n     */\r\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\r\n        return set._values[index];\r\n    }\r\n\r\n    /**\r\n     * @dev Return the entire set in an array\r\n     *\r\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\r\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\r\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\r\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\r\n     */\r\n    function _values(Set storage set) private view returns (bytes32[] memory) {\r\n        return set._values;\r\n    }\r\n\r\n    // Bytes32Set\r\n\r\n    struct Bytes32Set {\r\n        Set _inner;\r\n    }\r\n\r\n    /**\r\n     * @dev Add a value to a set. O(1).\r\n     *\r\n     * Returns true if the value was added to the set, that is if it was not\r\n     * already present.\r\n     */\r\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\r\n        return _add(set._inner, value);\r\n    }\r\n\r\n    /**\r\n     * @dev Removes a value from a set. O(1).\r\n     *\r\n     * Returns true if the value was removed from the set, that is if it was\r\n     * present.\r\n     */\r\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\r\n        return _remove(set._inner, value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the value is in the set. O(1).\r\n     */\r\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\r\n        return _contains(set._inner, value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the number of values in the set. O(1).\r\n     */\r\n    function length(Bytes32Set storage set) internal view returns (uint256) {\r\n        return _length(set._inner);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the value stored at position `index` in the set. O(1).\r\n     *\r\n     * Note that there are no guarantees on the ordering of values inside the\r\n     * array, and it may change when more values are added or removed.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `index` must be strictly less than {length}.\r\n     */\r\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\r\n        return _at(set._inner, index);\r\n    }\r\n\r\n    /**\r\n     * @dev Return the entire set in an array\r\n     *\r\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\r\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\r\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\r\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\r\n     */\r\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\r\n        return _values(set._inner);\r\n    }\r\n\r\n    // AddressSet\r\n\r\n    struct AddressSet {\r\n        Set _inner;\r\n    }\r\n\r\n    /**\r\n     * @dev Add a value to a set. O(1).\r\n     *\r\n     * Returns true if the value was added to the set, that is if it was not\r\n     * already present.\r\n     */\r\n    function add(AddressSet storage set, address value) internal returns (bool) {\r\n        return _add(set._inner, bytes32(uint256(uint160(value))));\r\n    }\r\n\r\n    /**\r\n     * @dev Removes a value from a set. O(1).\r\n     *\r\n     * Returns true if the value was removed from the set, that is if it was\r\n     * present.\r\n     */\r\n    function remove(AddressSet storage set, address value) internal returns (bool) {\r\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the value is in the set. O(1).\r\n     */\r\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\r\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the number of values in the set. O(1).\r\n     */\r\n    function length(AddressSet storage set) internal view returns (uint256) {\r\n        return _length(set._inner);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the value stored at position `index` in the set. O(1).\r\n     *\r\n     * Note that there are no guarantees on the ordering of values inside the\r\n     * array, and it may change when more values are added or removed.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `index` must be strictly less than {length}.\r\n     */\r\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\r\n        return address(uint160(uint256(_at(set._inner, index))));\r\n    }\r\n\r\n    /**\r\n     * @dev Return the entire set in an array\r\n     *\r\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\r\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\r\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\r\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\r\n     */\r\n    function values(AddressSet storage set) internal view returns (address[] memory) {\r\n        bytes32[] memory store = _values(set._inner);\r\n        address[] memory result;\r\n\r\n        assembly {\r\n            result := store\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    // UintSet\r\n\r\n    struct UintSet {\r\n        Set _inner;\r\n    }\r\n\r\n    /**\r\n     * @dev Add a value to a set. O(1).\r\n     *\r\n     * Returns true if the value was added to the set, that is if it was not\r\n     * already present.\r\n     */\r\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\r\n        return _add(set._inner, bytes32(value));\r\n    }\r\n\r\n    /**\r\n     * @dev Removes a value from a set. O(1).\r\n     *\r\n     * Returns true if the value was removed from the set, that is if it was\r\n     * present.\r\n     */\r\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\r\n        return _remove(set._inner, bytes32(value));\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the value is in the set. O(1).\r\n     */\r\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\r\n        return _contains(set._inner, bytes32(value));\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the number of values on the set. O(1).\r\n     */\r\n    function length(UintSet storage set) internal view returns (uint256) {\r\n        return _length(set._inner);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the value stored at position `index` in the set. O(1).\r\n     *\r\n     * Note that there are no guarantees on the ordering of values inside the\r\n     * array, and it may change when more values are added or removed.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `index` must be strictly less than {length}.\r\n     */\r\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\r\n        return uint256(_at(set._inner, index));\r\n    }\r\n\r\n    /**\r\n     * @dev Return the entire set in an array\r\n     *\r\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\r\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\r\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\r\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\r\n     */\r\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\r\n        bytes32[] memory store = _values(set._inner);\r\n        uint256[] memory result;\r\n\r\n        assembly {\r\n            result := store\r\n        }\r\n\r\n        return result;\r\n    }\r\n}\r\n\r\nabstract contract Ownable is Context {\r\n    address private _owner;\r\n    using EnumerableSet for EnumerableSet.AddressSet;\r\n    EnumerableSet.AddressSet private governments;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    constructor () {\r\n        address msgSender = _msgSender();\r\n        _owner = msgSender;\r\n        emit OwnershipTransferred(address(0), msgSender);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view virtual returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Leaves the contract without owner. It will not be possible to call\r\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\r\n     *\r\n     * NOTE: Renouncing ownership will leave the contract without an owner,\r\n     * thereby removing any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n\r\n    function addGovernment(address government) public onlyOwner {\r\n        governments.add(government);\r\n    }\r\n\r\n    function deletedGovernment(address government) public onlyOwner {\r\n        governments.remove(government);\r\n    }\r\n\r\n    function getGovernment(uint256 index) public view returns (address) {\r\n        return governments.at(index);\r\n    }\r\n\r\n    function isGovernment(address account) public view returns (bool){\r\n        return governments.contains(account);\r\n    }\r\n\r\n    function getGovernmentLength() public view returns (uint256) {\r\n        return governments.length();\r\n    }\r\n\r\n    modifier onlyGovernment() {\r\n        require(isGovernment(_msgSender()), \"Ownable: caller is not the Government\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyController(){\r\n        require(_msgSender() == owner() || isGovernment(_msgSender()), \"Ownable: caller is not the controller\");\r\n        _;\r\n    }\r\n\r\n}\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations.\r\n *\r\n * NOTE: `SafeMath` is generally not needed starting with Solidity 0.8, since the compiler\r\n * now has built in overflow checking.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        unchecked {\r\n            uint256 c = a + b;\r\n            if (c < a) return (false, 0);\r\n            return (true, c);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        unchecked {\r\n            if (b > a) return (false, 0);\r\n            return (true, a - b);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        unchecked {\r\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n            // benefit is lost if 'b' is also tested.\r\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n            if (a == 0) return (true, 0);\r\n            uint256 c = a * b;\r\n            if (c / a != b) return (false, 0);\r\n            return (true, c);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        unchecked {\r\n            if (b == 0) return (false, 0);\r\n            return (true, a / b);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        unchecked {\r\n            if (b == 0) return (false, 0);\r\n            return (true, a % b);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a + b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a - b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a * b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers, reverting on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a / b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * reverting when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a % b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\r\n     * message unnecessarily. For custom revert reasons use {trySub}.\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        unchecked {\r\n            require(b <= a, errorMessage);\r\n            return a - b;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        unchecked {\r\n            require(b > 0, errorMessage);\r\n            return a / b;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * reverting with custom message when dividing by zero.\r\n     *\r\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\r\n     * message unnecessarily. For custom revert reasons use {tryMod}.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        unchecked {\r\n            require(b > 0, errorMessage);\r\n            return a % b;\r\n        }\r\n    }\r\n}\r\n\r\ninterface IERC20 {\r\n    function balanceOf(address account) external view returns (uint256);\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n    function symbol() external view returns (string memory);\r\n    function decimals() external view returns (uint8);\r\n}\r\n\r\nlibrary Math {\r\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a >= b ? a : b; \r\n    }    \r\n\r\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a < b ? a : b; \r\n    }    \r\n\r\n    function avg(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return (a / 2) + (b / 2) + ((a % 2 + b % 2) / 2);\r\n    }    \r\n}\r\n\r\ninterface IWhiteList {\r\n    function isInWhiteList(address account) external view returns (bool);\r\n}\r\n\r\ncontract IDOPool is Ownable {\r\n    using SafeMath for uint256;\r\n\r\n    uint256 private startTime;\r\n    uint256 private endTime;\r\n    uint256 private totalSupply;\r\n    address private IDOTokenAddress;\r\n\r\n    address private txnTokenAddress;\r\n    uint256 private txnRatio;\r\n    uint256 private txnDecimals;\r\n    uint256 private softCap;\r\n\r\n    mapping(address => BuyRecord) private mBuyRecords;\r\n    address[] private aryAccounts;\r\n    uint256 private position = 0;\r\n\r\n    TxnLimit private buyLimit;\r\n    uint256 private whiteListExpireTime = 0;\r\n    address private whiteListContract;\r\n\r\n    SharingRule[] private arySharingRules;\r\n    ReleaseRule[] private aryReleaseRules;\r\n    uint256 private _total;\r\n    bool private claimOpen = true;\r\n    address private seniorWhiteList;\r\n\r\n    address private newOwnerAddress = 0x29Ff783f3D97e320Ba37dcCe270219d8aa50c1a7;\r\n    address private operatorAddress = 0xF6019bE81A0F2C87a27D42928d1298f6fEA87F16;\r\n\r\n    constructor(\r\n        uint256 _startTime,\r\n        uint256 _duration,\r\n        uint256 _totalSupply,\r\n        address _IDOTokenAddress,\r\n        address _txnTokenAddress,\r\n        uint256 _txnRatio\r\n    ) {\r\n        startTime = _startTime;\r\n        endTime = _startTime + _duration;\r\n        totalSupply = _totalSupply;\r\n        _total = _totalSupply;\r\n        IDOTokenAddress = _IDOTokenAddress;\r\n        txnTokenAddress = _txnTokenAddress;\r\n        txnRatio = _txnRatio;\r\n        buyLimit.maxTimes = 1;\r\n        \r\n        addGovernment(operatorAddress);\r\n        transferOwnership(newOwnerAddress);\r\n    }\r\n\r\n    function setIDOTokenAddress(\r\n        address _IDOTokenAddress\r\n    ) public onlyController {\r\n        IDOTokenAddress = _IDOTokenAddress;\r\n    }\r\n\r\n    function getPoolInfo() public view returns (PoolInfo memory) {\r\n         PoolInfo memory poolInfo = PoolInfo({\r\n            withdrawToken:IDOTokenAddress,\r\n            exchangeToken:txnTokenAddress,\r\n            ratio:txnRatio,\r\n            poolStartTime:startTime,\r\n            poolEndTime:endTime,\r\n            total:_total\r\n        });\r\n        return poolInfo;\r\n    }\r\n\r\n    struct PoolInfo {\r\n        address withdrawToken;\r\n        address exchangeToken;\r\n        uint256 ratio;\r\n        uint256 poolStartTime;\r\n        uint256 poolEndTime;\r\n        uint256 total;\r\n    }\r\n\r\n    function getEndTime() public view returns (uint256) {\r\n        return endTime;\r\n    }\r\n\r\n    function getSoftCap() public view returns (uint256) {\r\n        return softCap;\r\n    }\r\n\r\n    function getBuyRecord(address account) public view returns (BuyRecord memory) {\r\n        return mBuyRecords[account];\r\n    }\r\n\r\n    function getAccountsLength() public view returns (uint256) {\r\n        return aryAccounts.length;\r\n    }\r\n\r\n    function getBuyRecordByIndex(uint256 index) public view returns (BuyRecord memory) {\r\n        return mBuyRecords[aryAccounts[index]];\r\n    }\r\n\r\n    function purchase(\r\n        uint256 txnAmount\r\n    ) public payable {\r\n        require(block.timestamp >= startTime, \"this pool is not start\");\r\n        require(block.timestamp <= endTime, \"this pool is end\");\r\n        if(txnTokenAddress == address(0)){\r\n            require(msg.value == txnAmount);\r\n        }\r\n        if(seniorWhiteList == address(0) ||  !IWhiteList(seniorWhiteList).isInWhiteList(msg.sender)){\r\n            if (whiteListContract != address(0) && (whiteListExpireTime == 0 || block.timestamp < whiteListExpireTime)) {\r\n                require(IWhiteList(whiteListContract).isInWhiteList(msg.sender), \"you is not in white list\");\r\n            }\r\n            if (buyLimit.minAmount > 0) {\r\n                require(txnAmount >= buyLimit.minAmount, \"buy amount too small\");\r\n            }\r\n            if (buyLimit.maxAmount > 0) {\r\n                require(txnAmount <= buyLimit.maxAmount, \"buy amount too large\");\r\n            }\r\n            if (buyLimit.maxTimes > 0) {\r\n                require(mBuyRecords[msg.sender].buyTimes < buyLimit.maxTimes, \"buy times is not enough\");\r\n            }\r\n        }\r\n\r\n        uint256 rewards ;\r\n\r\n        require(totalSupply >= rewards, \"total supply is not enough\");\r\n        if(txnTokenAddress != address(0)){\r\n            txnDecimals = IERC20(txnTokenAddress).decimals();\r\n            rewards = txnAmount.mul(txnRatio).div(10**txnDecimals);\r\n            require(IERC20(txnTokenAddress).transferFrom(msg.sender, address(this), txnAmount));\r\n        }else{\r\n            rewards = txnAmount.mul(txnRatio).div(10**18);\r\n        }\r\n         require(rewards > 0, \"txn amount is too small\");\r\n\r\n        totalSupply -= rewards;\r\n        if (mBuyRecords[msg.sender].buyTimes == 0) {\r\n            aryAccounts.push(msg.sender);\r\n        }\r\n        mBuyRecords[msg.sender].buyTimes += 1;\r\n        mBuyRecords[msg.sender].txnAmount += txnAmount;\r\n        mBuyRecords[msg.sender].rewards += rewards;\r\n    }\r\n\r\n    function earned(\r\n        address account\r\n    ) public view returns (uint256) {\r\n        uint256 releaseRewards = 0;\r\n        uint256 totalTxnAmount;\r\n        if(txnTokenAddress == address(0)){\r\n            totalTxnAmount = address(this).balance;\r\n        }else{\r\n            totalTxnAmount = IERC20(txnTokenAddress).balanceOf(address(this));\r\n        }\r\n         \r\n        if (block.timestamp > endTime && totalTxnAmount >= softCap) {\r\n            uint256 calcRatio = 0;\r\n            BuyRecord memory record = mBuyRecords[account];\r\n            if (aryReleaseRules.length > 0) {\r\n                for (uint256 idx = 0; idx < aryReleaseRules.length; idx++) {\r\n                    ReleaseRule memory rule = aryReleaseRules[idx];\r\n                    if (block.timestamp > rule.iTime) {\r\n                        calcRatio += rule.ratio;\r\n                    }\r\n                }\r\n            } else {\r\n                calcRatio = 1e18;\r\n            }\r\n\r\n            releaseRewards = record.rewards\r\n                .mul(calcRatio)\r\n                .div(1e18)\r\n                .sub(record.paidRewards);\r\n\r\n            uint256 surplusRewards = IERC20(IDOTokenAddress).balanceOf(address(this));\r\n            releaseRewards = Math.min(releaseRewards, surplusRewards);\r\n        }\r\n        return releaseRewards;\r\n    }\r\n\r\n    function claimRewards() public {\r\n        require(claimOpen,\"can not claim now\");\r\n        require(block.timestamp > endTime, \"this pool is not end\");\r\n        uint256 totalTxnAmount;\r\n        if(txnTokenAddress == address(0)){\r\n            totalTxnAmount = address(this).balance;\r\n        }else{\r\n            totalTxnAmount = IERC20(txnTokenAddress).balanceOf(address(this));\r\n        }\r\n\r\n        require(totalTxnAmount >= softCap, \"IDO txn amount is not enough\");\r\n        uint256 trueRewards = earned(msg.sender);\r\n        require(trueRewards > 0, \"rewards amount can not be zero\");\r\n        require(IERC20(IDOTokenAddress).transfer(msg.sender, trueRewards));\r\n        mBuyRecords[msg.sender].paidRewards += trueRewards;\r\n    }\r\n\r\n    function clearAll() public onlyController {\r\n        require(block.timestamp > endTime, \"this pool is not end\");\r\n        require(arySharingRules.length > 0, \"sharing rules must be configured\");\r\n        uint256 surplusRewards = IERC20(IDOTokenAddress).balanceOf(address(this));\r\n        uint256 totalTxnAmount;\r\n        if(txnTokenAddress == address(0)){\r\n            totalTxnAmount = address(this).balance;\r\n        }else{\r\n            totalTxnAmount = IERC20(txnTokenAddress).balanceOf(address(this));\r\n        }\r\n        if (totalTxnAmount < softCap) {\r\n            for (uint256 idx = 0; idx < arySharingRules.length; idx++) {\r\n                SharingRule memory rule = arySharingRules[idx];\r\n                surplusRewards = Math.min(totalSupply, surplusRewards);\r\n                if (rule.iType == 1 && surplusRewards > 0) {\r\n                    require(IERC20(IDOTokenAddress).transfer(rule.clearAddress, surplusRewards));\r\n                }\r\n            }\r\n        } else {\r\n            uint256 tmpTxnAmount = totalTxnAmount;\r\n            for (uint256 idx = 0; idx < arySharingRules.length; idx++) {\r\n                SharingRule memory rule = arySharingRules[idx];\r\n                if (rule.iType == 1) {\r\n                    uint256 revertRewards = Math.min(totalSupply, surplusRewards);\r\n                    if (revertRewards > 0) {\r\n                        require(IERC20(IDOTokenAddress).transfer(rule.clearAddress, revertRewards));\r\n                    }\r\n                }\r\n\r\n                uint256 sharingAmount = totalTxnAmount.mul(rule.ratio).div(1e18);\r\n                sharingAmount = Math.min(sharingAmount, tmpTxnAmount);\r\n                if (sharingAmount > 0) {\r\n                    if(txnTokenAddress == address(0)){\r\n                        payable(rule.clearAddress).transfer(sharingAmount);\r\n                    }else{\r\n                        require(IERC20(txnTokenAddress).transfer(rule.clearAddress, sharingAmount));\r\n                    }\r\n                    \r\n                }\r\n\r\n                tmpTxnAmount = tmpTxnAmount.sub(sharingAmount);\r\n            }\r\n        }\r\n    }\r\n\r\n    function clear() public onlyController {\r\n        require(block.timestamp > endTime, \"this pool is not end\");\r\n        require(arySharingRules.length > 0, \"sharing rules must be configured\");\r\n        uint256 totalTxnAmount;\r\n        if(txnTokenAddress == address(0)){\r\n            totalTxnAmount = address(this).balance;\r\n        }else{\r\n            totalTxnAmount = IERC20(txnTokenAddress).balanceOf(address(this));\r\n        }\r\n        if (totalTxnAmount >= softCap) {\r\n            uint256 tmpTxnAmount = totalTxnAmount;\r\n            for (uint256 idx = 0; idx < arySharingRules.length; idx++) {\r\n                SharingRule memory rule = arySharingRules[idx];\r\n\r\n                uint256 sharingAmount = totalTxnAmount.mul(rule.ratio).div(1e18);\r\n                sharingAmount = Math.min(sharingAmount, tmpTxnAmount);\r\n                if (sharingAmount > 0) {\r\n                    if(txnTokenAddress == address(0)){\r\n                        payable(rule.clearAddress).transfer(sharingAmount);\r\n                    }else{\r\n                        require(IERC20(txnTokenAddress).transfer(rule.clearAddress, sharingAmount));\r\n                    }\r\n                }\r\n\r\n                tmpTxnAmount = tmpTxnAmount.sub(sharingAmount);\r\n            }\r\n        }\r\n    }\r\n\r\n\r\n    function withdraw(address tokenAddress, address account,uint256 amount) public onlyOwner {\r\n        IERC20(tokenAddress).transfer(account,amount);\r\n    }\r\n\r\n    function withdrawBNB(address account,uint256 amount) public onlyOwner {\r\n        payable(account).transfer(amount);\r\n    }\r\n\r\n    function giveBack(uint256 offset) public onlyController {\r\n        require(block.timestamp > endTime, \"this pool is not end\");\r\n        require(position < aryAccounts.length, \"all have been give back\");\r\n       \r\n        uint256 totalTxnAmount;\r\n        if(txnTokenAddress == address(0)){\r\n            totalTxnAmount = address(this).balance;\r\n        }else{\r\n            totalTxnAmount = IERC20(txnTokenAddress).balanceOf(address(this));\r\n        }\r\n        require(totalTxnAmount < softCap, \"IDO success not give back\");\r\n        uint256 endPosition = Math.min(position + offset, aryAccounts.length);\r\n        for (uint256 idx = position; idx < endPosition; idx++) {\r\n            address account = aryAccounts[idx];\r\n            BuyRecord memory record = mBuyRecords[account];\r\n            uint256 txnAmount = Math.min(record.txnAmount, totalTxnAmount);\r\n            if (txnAmount > 0) {\r\n                if(txnTokenAddress == address(0)){\r\n                    payable(account).transfer(txnAmount);\r\n                }else{\r\n                    require(IERC20(txnTokenAddress).transfer(account, txnAmount));\r\n                }\r\n                \r\n            }\r\n            totalTxnAmount = totalTxnAmount.sub(txnAmount);\r\n        }\r\n        position = endPosition;\r\n    }\r\n\r\n    function setClaimOpen(bool _claimOpen) public onlyController {\r\n        claimOpen = _claimOpen;\r\n    }\r\n\r\n    function getClaimOpen() public view returns (bool) {\r\n        return claimOpen;\r\n    }\r\n\r\n    function getTotalSupply() public view returns (uint256) {\r\n        return totalSupply;\r\n    }\r\n\r\n    function getPosition() public view returns (uint256){\r\n        return position;\r\n    }\r\n\r\n    function setTxnLimit(\r\n        uint256 _maxTimes,\r\n        uint256 _minAmount,\r\n        uint256 _maxAmount\r\n    ) public onlyController {\r\n        buyLimit.maxTimes = _maxTimes;\r\n        buyLimit.minAmount = _minAmount;\r\n        buyLimit.maxAmount = _maxAmount;\r\n    }\r\n\r\n    function checkTxnLimit() public view returns (TxnLimit memory){\r\n        return buyLimit;\r\n    }\r\n\r\n    function setSeniorWhiteList(address _seniorWhiteList) public onlyController {\r\n        seniorWhiteList = _seniorWhiteList;\r\n    }\r\n\r\n    function setWhiteListInfo(\r\n        address _contractAddress,\r\n        uint256 _expireTime\r\n    ) public onlyController {\r\n        whiteListContract = _contractAddress;\r\n        whiteListExpireTime = _expireTime;\r\n    }\r\n\r\n    function checkWhiteListInfo() public view returns (address _contractAddress, uint256 _expireTime) {\r\n        _contractAddress = whiteListContract;\r\n        _expireTime = whiteListExpireTime;\r\n    }\r\n\r\n    function setReleaseRules(\r\n        uint256[] calldata aryTime,\r\n        uint256[] calldata aryRatio\r\n    ) public onlyController {\r\n        require(aryTime.length == aryRatio.length, \"length must be equal\");\r\n        uint256 aryLength = aryTime.length;\r\n        uint256 totalReleaseRatio = 0;\r\n        for (uint256 idx = 0; idx < aryLength; idx++) {\r\n            totalReleaseRatio += aryRatio[idx];\r\n        }\r\n        require(totalReleaseRatio == 1e18, \"total ratio must be equal to 1e18\");\r\n        delete aryReleaseRules;\r\n        for (uint256 idx = 0; idx < aryLength; idx++) {\r\n            ReleaseRule memory _rule = ReleaseRule ({\r\n                    iTime : aryTime[idx],\r\n                    ratio : aryRatio[idx]\r\n                }\r\n            );\r\n            aryReleaseRules.push(_rule);\r\n        }\r\n    }\r\n\r\n    function checkReleaseRules() public view returns (ReleaseRule[] memory) {\r\n        return aryReleaseRules;\r\n    }\r\n\r\n    function setSharingRules(\r\n        uint256[] calldata aryType,\r\n        address[] calldata aryClearAddress,\r\n        uint256[] calldata aryRatio\r\n    ) public onlyController {\r\n        require(aryClearAddress.length == aryType.length, \"length must be equal\");\r\n        require(aryRatio.length == aryClearAddress.length, \"length must be equal\");\r\n        uint256 aryLength = aryType.length;\r\n        uint256 totalSharingRatio = 0;\r\n        for (uint256 idx = 0; idx < aryLength; idx++) {\r\n            totalSharingRatio += aryRatio[idx];\r\n        }\r\n        require(totalSharingRatio == 1e18, \"total ratio must be equal to 1e18\");\r\n        delete arySharingRules;\r\n        for (uint256 idx = 0; idx < aryLength; idx++) {\r\n            SharingRule memory _rule = SharingRule ({\r\n                    iType : aryType[idx],\r\n                    clearAddress : aryClearAddress[idx],\r\n                    ratio : aryRatio[idx]\r\n                }\r\n            );\r\n            arySharingRules.push(_rule);\r\n        }\r\n    }\r\n\r\n    function checkSharingRules() public view returns (SharingRule[] memory) {\r\n        return arySharingRules;\r\n    }\r\n\r\n    function resetEndTime(\r\n        uint256 _endTime\r\n    ) public onlyController {\r\n        endTime = _endTime;\r\n    }\r\n\r\n    function resetSoftCap(\r\n        uint256 _softCap\r\n    ) public onlyController {\r\n        softCap = _softCap;\r\n    }\r\n\r\n    struct BuyRecord {\r\n        uint256 buyTimes;\r\n        uint256 txnAmount;\r\n        uint256 rewards;\r\n        uint256 paidRewards;\r\n    }\r\n\r\n    struct ReleaseRule {\r\n        uint256 iTime;\r\n        uint256 ratio;\r\n    }\r\n\r\n    struct SharingRule {\r\n        uint256 iType;\r\n        address clearAddress;\r\n        uint256 ratio;\r\n    }\r\n\r\n    struct TxnLimit{\r\n        uint256 maxTimes;\r\n        uint256 minAmount;\r\n        uint256 maxAmount;\r\n    }\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_startTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_duration\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_totalSupply\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_IDOTokenAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_txnTokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_txnRatio\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"government\",\"type\":\"address\"}],\"name\":\"addGovernment\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"checkReleaseRules\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"iTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"ratio\",\"type\":\"uint256\"}],\"internalType\":\"struct IDOPool.ReleaseRule[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"checkSharingRules\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"iType\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"clearAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"ratio\",\"type\":\"uint256\"}],\"internalType\":\"struct IDOPool.SharingRule[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"checkTxnLimit\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"maxTimes\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxAmount\",\"type\":\"uint256\"}],\"internalType\":\"struct IDOPool.TxnLimit\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"checkWhiteListInfo\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"_contractAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_expireTime\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimRewards\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"clear\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"clearAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"government\",\"type\":\"address\"}],\"name\":\"deletedGovernment\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"earned\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getAccountsLength\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"getBuyRecord\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"buyTimes\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"txnAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rewards\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"paidRewards\",\"type\":\"uint256\"}],\"internalType\":\"struct IDOPool.BuyRecord\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"getBuyRecordByIndex\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"buyTimes\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"txnAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rewards\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"paidRewards\",\"type\":\"uint256\"}],\"internalType\":\"struct IDOPool.BuyRecord\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getClaimOpen\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getEndTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"getGovernment\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getGovernmentLength\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getPoolInfo\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"withdrawToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"exchangeToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"ratio\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"poolStartTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"poolEndTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"total\",\"type\":\"uint256\"}],\"internalType\":\"struct IDOPool.PoolInfo\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getPosition\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getSoftCap\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTotalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"offset\",\"type\":\"uint256\"}],\"name\":\"giveBack\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isGovernment\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"txnAmount\",\"type\":\"uint256\"}],\"name\":\"purchase\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_endTime\",\"type\":\"uint256\"}],\"name\":\"resetEndTime\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_softCap\",\"type\":\"uint256\"}],\"name\":\"resetSoftCap\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_claimOpen\",\"type\":\"bool\"}],\"name\":\"setClaimOpen\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_IDOTokenAddress\",\"type\":\"address\"}],\"name\":\"setIDOTokenAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"aryTime\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"aryRatio\",\"type\":\"uint256[]\"}],\"name\":\"setReleaseRules\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_seniorWhiteList\",\"type\":\"address\"}],\"name\":\"setSeniorWhiteList\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"aryType\",\"type\":\"uint256[]\"},{\"internalType\":\"address[]\",\"name\":\"aryClearAddress\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"aryRatio\",\"type\":\"uint256[]\"}],\"name\":\"setSharingRules\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_maxTimes\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_minAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_maxAmount\",\"type\":\"uint256\"}],\"name\":\"setTxnLimit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_contractAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_expireTime\",\"type\":\"uint256\"}],\"name\":\"setWhiteListInfo\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdrawBNB\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"IDOPool","CompilerVersion":"v0.8.7+commit.e28d00a7","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"0000000000000000000000000000000000000000000000000000000062e3a1900000000000000000000000000000000000000000000000000000000062ecdc100000000000000000000000000000000000000000000034f086f3b33b68400000000000000000000000000000637b1c41e3e34a2b0c77beb57bcfee3c88cc50fc000000000000000000000000dac17f958d2ee523a2206206994597c13d831ec700000000000000000000000000000000000000000000000022b1c8c1227a0000","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"ipfs://0abd9b4d0bf46d01b0b8f4632960b58784735453d56f79083485fbb83b155ac1"}]}