{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"CorvusToken.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.13;\\n\\nimport \\\"IERC20.sol\\\";\\nimport \\\"CorvusStaking.sol\\\";\\n\\ncontract CorvusToken is IERC20, CorvusStaking {\\n\\n    string private _name;\\n    string private _symbol;\\n    uint8 private _decimals;\\n    uint256 private _totalSupply;\\n\\n    mapping(address => uint256) balances;\\n    mapping(address => mapping(address => uint256)) allowed;\\n\\n    constructor(string memory name_, string memory symbol_) {\\n        _name = name_;\\n        _symbol = symbol_;\\n        balances[msg.sender] = totalSupply();\\n    }\\n\\n    function name() public view returns (string memory) {\\n        return _name;\\n    }\\n\\n    function symbol() public view returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    function decimals() external pure returns (uint8) {\\n        return 9;\\n    }\\n\\n    function totalSupply() public pure returns (uint256) {\\n        return 4.333333333e9 * 1e9;\\n    }\\n\\n    function balanceOf(address _address) external view returns (uint256) {\\n        return balances[_address];\\n    }\\n\\n    function transfer(address _to, uint256 _value) external virtual override returns (bool) {\\n        _transfer(msg.sender, _to, _value);\\n        return true;\\n    }\\n\\n    function transferFrom (address _from, address _to, uint256 _value) external virtual override returns (bool) {\\n        require(allowed[_from][msg.sender] >= _value, \\\"Insufficient allowance\\\");\\n        allowed[_from][msg.sender] = allowed[_from][msg.sender] - _value;\\n        _transfer(_from, _to, _value);\\n        return true;\\n    }\\n\\n    function _transfer(address _from, address _to, uint256 _value) internal {\\n        require(balances[_from] >= _value, \\\"Insufficient balance\\\");\\n        balances[_from] = balances[_from] - _value;\\n        balances[_to] = balances[_to] + _value;\\n        emit Transfer(_from, _to, _value);\\n    }\\n\\n    function approve(address _spender, uint256 _value) external returns (bool) {\\n        allowed[msg.sender][_spender] = _value;\\n        emit Approval(msg.sender, _spender, _value);\\n        return true;\\n    }\\n\\n    function allowance(address _owner, address _spender) external view returns (uint256) {\\n        return allowed[_owner][_spender];\\n    }\\n\\n    function _burn(address account, uint256 amount) internal {\\n        require(account != address(0), \\\"Cannot burn from zero address\\\");\\n        require(balances[account] >= amount, \\\"Cannot burn more than the account owns\\\");\\n\\n        balances[account] = balances[account] - amount;\\n        _totalSupply = _totalSupply - amount;\\n        emit Transfer(account, address(0), amount);\\n    }\\n\\n    function _mint(address account, uint256 amount) internal {\\n        require(account != address(0), \\\"Cannot mint to zero address\\\");\\n\\n        _totalSupply = _totalSupply + (amount);\\n        balances[account] = balances[account] + amount;\\n        emit Transfer(address(0), account, amount);\\n    }\\n\\n    function stake(uint256 _amount) public {\\n        require(_amount < balances[msg.sender], \\\"Cannot stake more than you own\\\");\\n        _stake(_amount);\\n        _burn(msg.sender, _amount);\\n    }\\n\\n    function withdrawStake(uint256 amount, uint256 stake_index)  public {\\n        uint256 amount_to_mint = _withdrawStake(amount, stake_index);\\n        _mint(msg.sender, amount_to_mint);\\n    }\\n}\\n\"\r\n    },\r\n    \"IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.13;\\n\\n\\ninterface IERC20 {\\n    function name() external view returns (string memory);\\n    function symbol() external view returns (string memory);\\n    function decimals() external pure returns (uint8);\\n    function totalSupply() external pure returns (uint256);\\n    function balanceOf(address account) external view returns (uint256);\\n    function transfer(address to, uint256 amount) external returns (bool);\\n    function transferFrom(address from, address to, uint256 value) external returns (bool success);\\n    function approve(address spender, uint256 amount) external returns (bool);\\n    function allowance(address owner, address spender) external view returns (uint256);\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"CorvusStaking.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.13;\\n\\ncontract CorvusStaking {\\n\\n    uint256 internal rewardPerHour = 1000;\\n    Stakeholder[] internal stakeHolders;\\n    mapping(address => uint256) internal stakes;\\n    event Staked(address indexed user, uint256 amount, uint256 index, uint256 timestamp);\\n\\n    constructor() {\\n        stakeHolders.push();\\n    }\\n\\n    struct Stake {\\n        address user;\\n        uint256 amount;\\n        uint256 since;\\n        uint256 claimable;\\n    }\\n\\n    struct Stakeholder {\\n        address user;\\n        Stake[] address_stakes;\\n    }\\n\\n    struct StakingSummary {\\n        uint256 total_amount;\\n        Stake[] stakes;\\n    }\\n\\n    function _addStakeholder(address staker) internal returns (uint256) {\\n        stakeHolders.push();\\n        uint256 userIndex = stakeHolders.length - 1;\\n        stakeHolders[userIndex].user = staker;\\n        stakes[staker] = userIndex;\\n        return userIndex;\\n    }\\n\\n    function _stake(uint256 _amount) internal {\\n        require(_amount > 0, \\\"Cannot stake nothing\\\");\\n        uint256 index = stakes[msg.sender];\\n        uint256 timestamp = block.timestamp;\\n        if (index == 0) {\\n            index = _addStakeholder(msg.sender);\\n        }\\n        stakeHolders[index].address_stakes.push(Stake(msg.sender, _amount, timestamp, 0));\\n        emit Staked(msg.sender, _amount, index,timestamp);\\n    }\\n\\n    function calculateStakeReward(Stake memory _current_stake) internal view returns(uint256){\\n        return (((block.timestamp - _current_stake.since) / 1 hours) * _current_stake.amount) / rewardPerHour;\\n    }\\n\\n    function _withdrawStake(uint256 amount, uint256 index) internal returns(uint256){\\n        uint256 user_index = stakes[msg.sender];\\n        Stake memory current_stake = stakeHolders[user_index].address_stakes[index];\\n        require(current_stake.amount >= amount, \\\"Cannot withdraw more than you have staked\\\");\\n\\n        uint256 reward = calculateStakeReward(current_stake);\\n        current_stake.amount = current_stake.amount - amount;\\n        if (current_stake.amount == 0) {\\n            delete stakeHolders[user_index].address_stakes[index];\\n        } else {\\n            stakeHolders[user_index].address_stakes[index].amount = current_stake.amount;\\n            stakeHolders[user_index].address_stakes[index].since = block.timestamp;\\n        }\\n\\n        return amount+reward;\\n    }\\n\\n    function hasStake(address _staker) public view returns(StakingSummary memory){\\n        uint256 totalStakeAmount;\\n        StakingSummary memory summary = StakingSummary(0, stakeHolders[stakes[_staker]].address_stakes);\\n        for (uint256 s = 0; s < summary.stakes.length; s += 1){\\n           uint256 availableReward = calculateStakeReward(summary.stakes[s]);\\n           summary.stakes[s].claimable = availableReward;\\n           totalStakeAmount = totalStakeAmount+summary.stakes[s].amount;\\n        }\\n        summary.total_amount = totalStakeAmount;\\n        return summary;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"evmVersion\": \"istanbul\",\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"libraries\": {\r\n      \"CorvusToken.sol\": {}\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"string\",\"name\":\"name_\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"symbol_\",\"type\":\"string\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"Staked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_staker\",\"type\":\"address\"}],\"name\":\"hasStake\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"total_amount\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"since\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"claimable\",\"type\":\"uint256\"}],\"internalType\":\"struct CorvusStaking.Stake[]\",\"name\":\"stakes\",\"type\":\"tuple[]\"}],\"internalType\":\"struct CorvusStaking.StakingSummary\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"stake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"stake_index\",\"type\":\"uint256\"}],\"name\":\"withdrawStake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"CorvusToken","CompilerVersion":"v0.8.15+commit.e14f2714","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000000800000000000000000000000000000000000000000000000000000000000000006436f72767573000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000034352530000000000000000000000000000000000000000000000000000000000","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":""}]}