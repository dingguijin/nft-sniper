{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.6.7;\r\n\r\n/// @dev Models a address -> uint mapping where it is possible to iterate over all keys.\r\nlibrary IterableBalances {\r\n    struct iterableBalances {\r\n        mapping(address => Balances) balances;\r\n        KeyFlag[] keys;\r\n        uint256 size;\r\n    }\r\n\r\n    struct Balances {\r\n        uint256 keyIndex;\r\n        uint256 balance;\r\n        uint256 locked;\r\n    }\r\n    struct KeyFlag {\r\n        address key;\r\n        bool deleted;\r\n    }\r\n\r\n    function insert(\r\n        iterableBalances storage self,\r\n        address key,\r\n        uint256 balance\r\n    ) public {\r\n        uint256 keyIndex = self.balances[key].keyIndex;\r\n        self.balances[key].balance = balance;\r\n\r\n        if (keyIndex == 0) {\r\n            keyIndex = self.keys.length;\r\n            self.keys.push();\r\n            self.balances[key].keyIndex = keyIndex + 1;\r\n            self.keys[keyIndex].key = key;\r\n            self.size++;\r\n        }\r\n    }\r\n\r\n    function remove(iterableBalances storage self, address key) public {\r\n        uint256 keyIndex = self.balances[key].keyIndex;\r\n\r\n        require(\r\n            keyIndex != 0,\r\n            \"Cannot remove balance : key is not in balances\"\r\n        );\r\n\r\n        delete self.balances[key];\r\n        self.keys[keyIndex - 1].deleted = true;\r\n        self.size--;\r\n    }\r\n\r\n    function contains(iterableBalances storage self, address key)\r\n        public\r\n        view\r\n        returns (bool)\r\n    {\r\n        return self.balances[key].keyIndex > 0;\r\n    }\r\n\r\n    function iterate_start(iterableBalances storage self)\r\n        public\r\n        view\r\n        returns (uint256 keyIndex)\r\n    {\r\n        return iterate_next(self, uint256(-1));\r\n    }\r\n\r\n    function iterate_valid(iterableBalances storage self, uint256 keyIndex)\r\n        public\r\n        view\r\n        returns (bool)\r\n    {\r\n        return keyIndex < self.keys.length;\r\n    }\r\n\r\n    function iterate_next(iterableBalances storage self, uint256 keyIndex)\r\n        public\r\n        view\r\n        returns (uint256 r_keyIndex)\r\n    {\r\n        keyIndex++;\r\n\r\n        while (keyIndex < self.keys.length && self.keys[keyIndex].deleted) {\r\n            keyIndex++;\r\n        }\r\n\r\n        return keyIndex;\r\n    }\r\n\r\n    function iterate_get(iterableBalances storage self, uint256 keyIndex)\r\n        public\r\n        view\r\n        returns (\r\n            address key,\r\n            uint256 balance,\r\n            uint256 locked\r\n        )\r\n    {\r\n        key = self.keys[keyIndex].key;\r\n        balance = self.balances[key].balance;\r\n        locked = self.balances[key].locked;\r\n    }\r\n\r\n    event Dummy(); // Needed otherwise typechain has no output\r\n}","ABI":"[{\"anonymous\":false,\"inputs\":[],\"name\":\"Dummy\",\"type\":\"event\"}]","ContractName":"IterableBalances","CompilerVersion":"v0.6.7+commit.b8d736ae","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"Apache-2.0","Proxy":"0","Implementation":"","SwarmSource":"ipfs://f1b78474387ad8b6247a658fb55ecaf770c99ce767f50e990599743021c1850b"}]}